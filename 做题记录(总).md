# 做题记录

## 模板记录

```md
### Tx 题目名称

#### 题目描述

#### 题目分析

#### 参考代码
```

## Content

- [COCI2020-2021 #1](#COCI2020-2021 #1)
	- [T1 Patkice](#T1 Patkice)
	- [T2 Bajka](#T2 Bajka)
	- [T3 Histogram](#T3 Histogram)
	- [T4 Papricice](#T4 Papricice)
	- [T5 Tenis](#T5 Tenis)
- [COCI2020-2021 #2](#COCI2020-2021 #2)
	- [T1 Crtanje](#T1 Crtanje)
	- [T2 Odasiljaci](#T2 Odasiljaci)
	- [T3 Euklid](#T3 Euklid)
	- [T4 Sjekira](#T4 Sjekira)
	- [T5 Svjetlo](#T5 Svjetlo)
- [COCI2020-2021 #3](#COCI2020-2021 #3)
	- [T1 Knjige](#T1 Knjige)
	- [T2 Vlak](#T2 Vlak)
	- [T3 Sateliti](#T3 Sateliti)
	- [T4 Selotejp](#T4 Selotejp)
	- [T5 Specijacija](#T5 Specijacija)
- [COCI2020-2021 #4](#COCI2020-2021 #4)
	- [T1 Pizza](#T1 Pizza)
	- [T2 Vepar](#T2 Vepar)
	- [T3 Hop](#T3 Hop)
	- [T4 Janjetina](#T4 Janjetina)
	- [T5 Patkice II](#T5 Patkice II)
- [COCI2020-2021 #5](#COCI2020-2021 #5)
	- [T1 Sifra](#T1 Sifra)
	- [T2 Po](#T2 Po)
	- [T3 Megenta](#T3 Megenta)
	- [T4 Planine](#T4 Planine)
	- [T5 Sjeckanje](#T5 Sjeckanje)
- [20220207 重庆育才2022寒假集训 选拔测试试题](#20220207)
	- [T1 社交距离(socdist)](#T1 社交距离)
	- [T2 路径(path)](#T2 路径)
	- [T3 倾斜的线(slope)](#T3 倾斜的线)
	- [T4 符文(runes)](#T4 符文)
	- [T5 购票(tickets)](#T5 购票)
- [20220210 重庆市育才中学2022年 寒假联合模拟 Round 3](#20220210)
	- [T1 商贸(trade)](#T1 商贸)
	- [T2 部队集结(gather)](#T2 部队集结)
	- [T3 虫群扩张(proliferate)](#T3 虫群扩张)
	- [T4 推演(calc)](#T4 推演)
- [20220212 重庆市育才中学2022年 寒假联合模拟 Round 4](#20220212)
	- [T1 魔法阵(magic)](#T1 魔法阵)
	- [T2 区域侦测(detect)](#T2 区域侦测)
	- [T3 加固(reinforce)](#T3 加固)
	- [T4 斩首行动(assassinate)](#T4 斩首行动)
- [20220219 重庆市育才中学2022年 联合模拟](#20220219)
	- [T1 photo](#T1 photo)
	- [T2 swap](#T2 swap)
	- [T3 tree](#T3 tree)
	- [T4 rabbit](#T4 rabbit)
	- [T5 ball](#T5 ball)
- [20220226 重庆市育才中学2022年 联合模拟](#20220226)
	- [T1 输出练习(output)](#T1 输出练习)
	- [T2 最近距离(dis)](#T2 最近距离)
	- [T3 字典序题(sort)](#T3 字典序题)
	- [T4 区间求和(sum)](#T4 区间求和)
	- [T5 智慧博弈(game)](#T5 智慧博弈)
- [20220227 重庆市育才中学2022年 寒假联合模拟 Round 5](#20220227)
	- [T1 烽火石(tower)](#T1 烽火石)
	- [T2 博弈(game)](#T2 博弈)
	- [T3 染色(draw)](#T3 染色)
	- [T4 排列计数(permutation)](#T4 排列计数)
	
## COCI2020-2021 #1

### T1 Patkice

#### 题目描述

不是很久之前，在一个遥远的大陆上，住着三只橡皮鸭。在一个炎热的夏日，躺在沙滩上的鸭子们决定旅行到一座相邻的小岛(用一把老旧的黑色雨伞)。

鸭子们是经验丰富的海洋探险家，在旅行之前，他们会检查当前海洋的海图。在海图上，鸭子们目前居住的岛屿被字符 `o` 标记，鸭子们可以朝东(E)南(S)西(W)北(N)中的任意方向开始他们的旅途。

海洋中的洋流会像四个方向移动，在海图上，向东的洋流被标记为 `>`，向西的洋流被标记为 `<`，向北的洋流被标记为 `^`，向南的洋流被标记为 `v`。当鸭子们位于洋流中的某一个位置时，他们会移动到洋流所指向的下一个位置。这片海洋中的洋流比较特殊，它不会让鸭子们移动到海图之外的地方，同时，洋流也没有形成环路。

平静的海洋在海图中被标记为 `.`。如果洋流带鸭子们到达了平静海域，或者时开始的岛屿，那么他们就无法继续他们的旅途了。他们想要到达的岛在图上被标记为 `x`。

你的任务是帮鸭子们判断它们能否到达目的地。如果可以的话，他们需要选择哪一个方向。

鉴于鸭子们并不喜欢海上漂泊的感觉，如果存在多个可以到达目的地的方向，你需要找到行动距离最短的方向。如果存在行动距离相同的方向，请按照方向的字典序输出字典序最小的方向。

#### 输入描述

第一行包括两个整数 $r$ 和 $s(3\leq r,s\leq 100)$，表示海图的行数和列数。

接下来的 $r$ 行，每一行包含 $s$ 个字符，字符集为 `o<>v^.x`，代表海洋的情况。图中保证只存在唯一的 `o` 和 `x`。保证字符 `o` 不会出现在第一行，第一列，最后一行，最后一列。

#### 输出描述

如果鸭子们无法到达目的小岛，输出 `:(`。

否则，请在第一行输出 `:)`。在第二行，输出它们出发的方向(N表示向北，E表示向东，W表示向西，S表示向南)。

#### 题目分析

加强版:[Patkice II](#T5 Patkice II)。

水题一道，只不过细节有一点小多。首先，现将小鸭子们移动到上下左右四个格子，然后再暴力模拟下鸭子最终会移动到哪个点，并判断其是否为终点。注意：三只小鸭可能会走回起点，如果忽略了起点可能会死循环然后超时。

时间复杂度为 $O(n^2)$。

#### 参考代码

```c++
#include<bits/stdc++.h>
#define van long long
#define N 1010
#define ywhin cin
#define ywhout cout
using namespace std;
van n,m;
char cha[N][N];
van len;char ans;
van DFS(van x,van y)
{
	switch(cha[x][y])
	{
		case '.':return -1e18;break;
		case 'o':return -1e18;break;//注意判断是否会回到起点
		case 'x':return 0;break;
		case '>':return DFS(x,y+1)+1;break;
		case '<':return DFS(x,y-1)+1;break;
		case 'v':return DFS(x+1,y)+1;break;
		case '^':return DFS(x-1,y)+1;break;
	}
}
int main()
{
//	ifstream ywhin("patkice.in");
//	ofstream ywhout("patkice.out");
	ywhin>>n>>m;ans='z',len=1e18;
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) ywhin>>cha[i][j];
	van sx,sy;
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) if (cha[i][j]=='o') sx=i,sy=j;
	van res=DFS(sx,sy+1);
	if (res>=0&&res<=len) ans=(len==res)?min(ans,'E'):'E',len=res;
	res=DFS(sx-1,sy);
	if (res>=0&&res<=len) ans=(len==res)?min(ans,'N'):'N',len=res;
	res=DFS(sx+1,sy);
	if (res>=0&&res<=len) ans=(len==res)?min(ans,'S'):'S',len=res;
	res=DFS(sx,sy-1);//注意移动方向不要写错了
	if (res>=0&&res<=len) ans=(len==res)?min(ans,'W'):'W',len=res;
	if (ans!='z') 
	{
		ywhout<<":)"<<endl;
		ywhout<<ans;
		return 0;
	}
	ywhout<<":(";
	return 0;
}
```

### T2 Bajka

#### 题目描述

小 $𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 已经对图画书感到厌倦了，于是他决定开始阅读他的第一本童话书。不幸的是，$𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 经常会遇见一些让他感到害怕的词语。为了战胜恐惧，他会玩一个他自己发明的游戏。

令我们的小主人公感到恐惧的词语是一个长度为 $𝑛$ 的小写字母序列。开始这个游戏时，$𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 会把他的手指放在这个字符序列的一个位置上，随后把这个位置上的字符写到一张纸上。接下来，他会执行下面的两个操作中的某一个，他会进行任意次这样的操作执行。

1.将手指移动到现在指向的字符的左边一个字符或者右边一个字符(如果存在的话)。同时，$𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 也会把这个新的字符写在原来的最后一个字符后面。

2.将手指移动到任意一个与现在指向字符相同的字符处。这一行动不会导致任何字母书写。

移动手指从位置 $𝑥$ 到位置 $𝑦$ 需要花费的时间为 $|𝑥−𝑦|$。

如果在游戏的最后，$𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 最喜欢的词语会出现在纸上，那么他就会克服他的恐惧。他想要尽快看完这本童话书，因此他希望你可以告诉他，最短需要多少时间，他才能够克服恐惧。

#### 输入描述

输入的第一行包括正整数 $𝑛$ 和 $𝑚(1\leq 𝑛,𝑚\leq 3000)$（原题 $1\leq n,m\leq 300$，在此处只能获得70Pts）。

输入的第二行包括 $𝑛$ 个小写字母，表示 $𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 害怕的单词。

输入的第三行包括 $𝑚$ 个小写字母，表示 $𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 最喜欢的单词。

#### 输出描述

输出 $𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 生成最喜欢的单词需要的最短时间，如果无法生成这个单词，那么输出 `−1`。

#### 题目分析

##### 30Pts

硬暴力。直接挨个去搜索就行了。

时间复杂度为 $O(m)$。

##### 70Pts

设 $dp[i][j]$ 为已经找到 $i$ 个字符且当前所在的位置为 $j$ 所需要的最小步数。

预处理某一个字母究竟在哪些地方出现过，然后再 DP 的过程中可以快速查找出下一步究竟可以到达哪一些位置，并且加上二者的位置之差就可以转移到下一个位置了。

由于字符串有可能全部都是一样的，因此可能会导致单个状态转移的时间复杂度为 $O(n)$，因此，

总时间复杂度为 $O(n^3)$，过 COCI 数据是没有问题了。

##### 100Pts

考虑如何降低时间复杂度。

我们可以每次记录到某一个状态时每个符合条件的点的最小步数，然后从左扫一遍，记录到某一个点时的最小步数 $step$，并将符合条件的下一个点的步数赋值为 $step$，再从右向左扫一遍，与从左往右扫一遍获得的答案比较，保留小的，再去寻找下一个状态。

时间复杂度为 $O(n^2)$

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 3010
#define ywhin cin
#define ywhout cout
using namespace std;
van f[N];
vector<van> where['z'+1];
char hate[N],like[N];
int main()
{
	memset(f,(1<<8)-1,sizeof f);
	van n,m;
	ywhin>>n>>m;
	for (int i=1;i<=n;i++) ywhin>>hate[i];
	for (int i=1;i<=m;i++) ywhin>>like[i];
	queue<pair<van,van> > q;
	for (int i=1;i<=n;i++) if (hate[i]==like[1]) q.push(make_pair(i,0));
	for (int i=2;i<=m;i++)
	{
		memset(f,(1<<6)-1,sizeof f);
		while (!q.empty())
		{
			pair<van,van> p=q.front();q.pop();
			van place=p.first,step=p.second;
			if (hate[place-1]==like[i]&&place>1) f[place-1]=min(f[place-1],step+1);
			if (hate[place+1]==like[i]&&place<n) f[place+1]=min(f[place+1],step+1);
		}//将上一轮的结果复制到f数组里
		van minans=1e18,pos=0;
		for (int j=1;j<=n;j++) if (hate[j]==like[i])
		{
			van dis=minans+j-pos;
			if (dis>f[j]) minans=f[j],pos=j;
			else if (dis<f[j]) f[j]=dis;
		}//从左往右扫一遍
		minans=1e18,pos=n+1;
		for (int j=n;j>=1;j--) if (hate[j]==like[i])
		{
			van dis=minans+pos-j;
			if (dis>f[j]) minans=f[j],pos=j;
			else if (dis<f[j]) f[j]=dis;
			if (f[j]<1e18) q.push(make_pair(j,f[j]));
		}//从右往左扫一遍
		if (q.empty())
		{
			ywhout<<-1<<endl;
			return 0;
		}//如果没有符合条件的点就可以输出-1了
	}
	van ans=1e18;
	while (!q.empty())
	{
		pair<van,van> p=q.front();q.pop();
		ans=min(ans,p.second);
	}
	ywhout<<ans;
	return 0;
}
```

### T3 Histogram

#### 题目描述

有一个长度为 $N$ 的3D直方图。第 $i$ 个棱柱的宽度为 1 米，高度为 $a_i$，长度为 $b_i$。换句话说，其主视图(从正面看)是一个长方形序列，第 $i$ 个长方形高为 $a_i$，宽为 1。其俯视图(从上方看)是一个长方形序列，第 $i$ 个长方形高为 $b_i$，宽为 1。

你的任务是找出这个直方图内可以放下的容积最大的棱柱。要求棱柱的棱与直方图的棱平行。

#### 输入描述

输入的第一行包括一个正整数 $N(1\leq N\leq 2\times10^5)$。表示这个直方图的长度。 

接下来的 $n$ 行，第 $i$ 行包括两个正整数 $a_i$ 和 $b_i(1\leq a_i,b_i\leq 10^6)$，含义见题面描述。

#### 输出描述

输入最大内接棱柱的容积。

#### 题目分析

##### 20Pts

爆肝一遍就完事了。枚举区间的 $l$ 节点与区间长度，然后计算答案并且与  $ans$ 比较即可。

时间复杂度为 $O(n^2)$ 。

##### 100Pts

考虑使用分治解决此题。

将区间 $[l,r]$ 分为两部分。不难发现，$a$ 的最小值与 $b$ 的最小值的分布只会有两种情况。即 $a$ 的最小值在左边/右边与 $b$ 的最小值在左边/右边。

分开讨论，当 $a,b$ 的最小值在同一边时，枚举 $a,b$ 的最小值并在另一边查找能走到的最远的地方就行了。

当 $a,b$ 的最小值不在同一边时，设 $c_i=\min(a_{mid},a_{mid-1},...,a_{mid-i}),d_i=\min(b_{mid+1},b_{mid+2},...,b_{mid+i})$，以及 $f_j(i)=-i\times d_j+j\times d_j,i\leq j$。线段树维护 $[l,r]$ 这个区间里所有函数的凸包，最后查询这个线段树的值再乘上 $c_i$ 的值就行了。

另一种同理。

时间复杂度为 $O(n\log_2^2n)$。

#### 参考代码

代码链接:[[DS记录\]P7164 [COCI2020-2021#1] 3D Histogram - command_block 的博客 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/command-block/ds-ji-lu-p7164-coci2020-20211-3d-histogram)

```C++
#include<algorithm>
#include<cstdio>
#include<vector>
#define pb push_back
#define ll long long
#define MaxN 200500
using namespace std;
const int INF=1000000000;
struct Line{
  ll k,b;
  ll get(int x)
  {return k*x+b;}
  bool operator < (const Line &B) const
  {return k<B.k;}
};
bool chk(const Line &A,const Line &B,const Line &C){
  ll x1=A.k-B.k,y1=A.b-B.b
    ,x2=C.k-B.k,y2=C.b-B.b;
  return x1*y2-y1*x2>0; 
}
#define Hull vector<Line>
Line st[MaxN];
void max(const Hull &A,const Hull &B,Hull &C)
{
  merge(A.begin(),A.end(),B.begin(),B.end(),st);
  int n=A.size()+B.size();
  C.clear();
  for (int i=0;i<n;i++){
    while(C.size()>=2&&!chk(C[C.size()-2],C.back(),st[i]))C.pop_back();
    C.pb(st[i]);
  }
}
struct Node{Hull s;int p;};
ll get(Hull &s,int &p,int x){
  while(p+1<s.size()&&s[p+1].get(x)>s[p].get(x))p++;
  return s[p].get(x);
}
struct HullDS
{
  Node a[1<<18|500];
  Line sl[MaxN];
  int tl,tr;
  void build(int l,int r,int u)
  {
    a[u].s.clear();a[u].p=0;
    if (l==r){a[u].s.pb(sl[l]);return ;}
    int mid=(l+r)>>1;
    build(l,mid,u<<1);
    build(mid+1,r,u<<1|1);
    max(a[u<<1].s,a[u<<1|1].s,a[u].s);
  }
  int wfl,wfr,wfx;ll ret;
  void _qry(int l,int r,int u)
  {
    if (wfl<=l&&r<=wfr){
      ret=max(ret,get(a[u].s,a[u].p,wfx));
      return ;
    }int mid=(l+r)>>1;
    if (wfl<=mid)_qry(l,mid,u<<1);
    if (mid<wfr)_qry(mid+1,r,u<<1|1);
  }
  ll qry(int l,int r,int x){
    wfl=l;wfr=r;wfx=x;
    ret=0;_qry(tl,tr,1);
    return ret;
  }
}T0,T1,T01;
struct Data{int x0,x1;}s[MaxN];
int h0[MaxN],h1[MaxN];ll ans;
void solve(int l,int r)
{
  if (l==r)return ;
  int mid=(l+r)>>1;
  solve(l,mid);solve(mid+1,r);
  h1[mid]=h0[mid]=INF;
  T0.tl=T1.tl=T01.tl=mid+1;
  T0.tr=T1.tr=T01.tr=r;
  // (c0+c1)*min(t0,h0)*min(t1,h1)
  for (int i=mid+1;i<=r;i++){
    h0[i]=min(s[i].x0,h0[i-1]);
    h1[i]=min(s[i].x1,h1[i-1]);
    T0.sl[i]=(Line){h0[i],1ll*h0[i]*(i-mid)};
    //(c0+c1)*h0*t1 = t1*(c0*h0+c1*h0)
    T1.sl[i]=(Line){h1[i],1ll*h1[i]*(i-mid)};
    //(c0+c1)*t0*h1 = t0*(c0*h1+c1*h1)
    T01.sl[i]=(Line){1ll*h0[i]*h1[i],1ll*h0[i]*h1[i]*(i-mid)};
    //(c0+c1)*h0*h1 = c0*h0*h1+c1*h0*h1
  }
  T0.build(mid+1,r,1);
  T1.build(mid+1,r,1);
  T01.build(mid+1,r,1);
  for (int i=mid,t0=INF,t1=INF,p0=mid,p1=mid;i>=l;i--){
    t0=min(t0,s[i].x0);
    t1=min(t1,s[i].x1);
    while(p0<r&&h0[p0+1]>=t0)p0++;
    while(p1<r&&h1[p1+1]>=t1)p1++;
    ans=max(ans,1ll*(min(p0,p1)-i+1)*t0*t1);
    if (p0<p1)ans=max(ans,t1*T0.qry(p0+1,p1,mid-i+1));
    if (p1<p0)ans=max(ans,t0*T1.qry(p1+1,p0,mid-i+1));
    if (max(p0,p1)<r)ans=max(ans,T01.qry(max(p0,p1)+1,r,mid-i+1));
  }
}
int n;
int main()
{
  scanf("%d",&n);
  for (int i=1;i<=n;i++){
    scanf("%d%d",&s[i].x0,&s[i].x1);
    ans=max(ans,1ll*s[i].x0*s[i].x1);
  }solve(1,n);
  printf("%lld",ans);
  return 0;
}
```

### T4 Papricice

#### 题目描述

在花园忙碌了一个早上之后。M 先生决定用自己种的干辣椒奖励一下自己。 

M 先生有 $n$ 颗辣椒，这些辣椒由 $n-1$ 条线链接而成。任意两颗辣椒都可以通过若干条线连接起来。简单来说，这 $n$ 颗辣椒和这 $n-1$ 条线连接成了一棵树。 

M 先生今天要吃三顿饭，因此他需要剪断两条线。获得三串小的辣椒。每一顿饭需要使用一串辣椒。

显然，一顿饭不能太辣，因此他会选择一种分割方法，使得**辣椒最多的辣椒串和辣椒最少的辣椒串的数量差距最小。**你的任务就是求出这个最小的差距。

#### 输入描述

输入的第一行包含一个整数 $n(1\leq n\leq 2\times10^5)$，表示辣椒的数量。辣椒从1到 $n$ 编号。 

接下来的 $n-1$ 行，每行包括两个整数 $x$ 和 $y(1\leq x,y\leq n)$。表示由一条连接编号为 $x$ 的辣椒和编号为 $y$ 的辣椒的线。

#### 输出描述

输出一行，一个整数，即最小的最大辣椒串和最小辣椒串的数量差距。

#### 题目分析

##### 50Pts

暴力枚举要删除的那两个点，然后计算这三个部分的点的数量并更新 $ans$ 的值就行了。

时间复杂度为 $O(n^2)$。

##### 100Pts

假设我们已经切掉了点 $x$ 与其父亲节点所形成的的边，现在我们需要查找下一个需要删除的边究竟是哪一条。

分成两种情况考虑：

1. 当另一条边在其祖先节点上，那么我们需要分出的另一个部分的节点数量最好为 $\frac{n-size[x]}{2}$。由于其祖先节点 $y$ 的 $size_y$ 包含了 $x$ 的子树下所有的节点，因此我们只需要找到 $x$ 的祖先节点中子树的节点数最靠近 $\frac{n+size[x]}{2}$ 的一个点并计算当前情况下的最终结果并将其与 $ans$ 比较即可。

2. 当另一条边在已经被访问过的子树上时，我们只需要找到已经访问过的节点中子树的节点数最接近 $\frac{n-size[x]}{2}$ 的一个点并计算当前情况下的最终结果并将其与 $ans$ 比较。

至于如何查找，使用 multiset 自带的 lower_bound 函数即可。

时间复杂度为 $O(n\log_2n )$。

#### 参考代码

```c++
#include<bits/stdc++.h>
#define van long long
#define N 200010
#define ywhin cin
#define ywhout cout
using namespace std;
van n;vector<van> g[N];
bool used[N];van siz[N],ans=1e18;
multiset<van> father,son;
void init(van now)
{
//	cout<<now<<endl;
	used[now]=1,siz[now]=1;van v;
	for (int i=0;i<g[now].size();i++) if (!used[v=g[now][i]]) init(v),siz[now]+=siz[v];
}//计算子树中的节点数
void DFS(van now)
{
	used[now]=1;van v;
	multiset<van>::iterator it;van siz2,last,tmpans;
	if (!father.empty())
	{
		it=father.lower_bound((n-siz[now])/2+siz[now]);
		if (it!=father.end())
		{
			siz2=*it-siz[now];
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
		if (it!=father.begin())
		{
			it--;
			siz2=*it-siz[now];
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
	}//第一种情况
	if (!son.empty())
	{
		it=son.lower_bound((n-siz[now])/2);
		if (it!=son.end())
		{
			siz2=*it;
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
		if (it!=son.begin())
		{
			it--;
			siz2=*it;
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
	}//第二种情况
	if (now!=1) father.insert(siz[now]);//将自己加到祖先集合中
	for (int i=0;i<g[now].size();i++) if (!used[v=g[now][i]]) DFS(v);
	if (now!=1) father.erase(father.find(siz[now]));//将自己移除祖先集合
	if (now!=1) son.insert(siz[now]);//将自己移入已访问的节点的集合
}
int main()
{
	ywhin>>n;
	for (int i=1;i<n;i++)
	{
		van f,s;
		scanf("%lld %lld",&f,&s);
		g[f].push_back(s);
		g[s].push_back(f);
	}//建图
	init(1);
	memset(used,0,sizeof used);
	DFS(1);
	ywhout<<ans<<endl;
	return 0;
}
```

### T5 Tenis

#### 题目描述

米尔科先生是一个网球的狂热粉丝。不久之后，一个重要的锦标赛就要开始了，这场锦标赛一共有 $n$ 位参赛选手。米尔科先生花费了多年时间研究参赛者们并收集了大量的数据。它将他们在三种不同场地上的实力调查清楚。并按照每一个不同的场地给运动员们进行了一个排序，排序为一的表示在这一场地上，这一运动员是最强的。排序最后的最弱。

在这次的锦标赛中，每两位选手都会正好交手一次。因此一共会有 $\frac{n(n-1)}{2}$ 场比赛。一场网球赛是不会有平局的，**在这个场地上实力排序更强的选手会获得胜利。**主办方对此心知肚明，因此他们决定将每场比赛安排在胜者水平最高的场地，也就是说排名最靠前的场地上。如果存在两个场地胜者排名相同(例如：运动员 A 和 B 进行比赛，A 在场地 1 上会获胜，B 在场地 2 上会获胜，但是二者在对应的场地上拥有相同的排名)，他们就会选择败方排名最好的场地，如果败方排名相同，那么他们就会选择编号最小的场地。 

你的任务是算出锦标赛的结果，包括：不同场地上的比赛场数，每一位运动员的获胜次数。

#### 输入描述

输入的第一行包括一个整数 $n(1\leq n\leq 10^5)$，表示运动员的数量，运动员们从 1 到 $n$ 编号。 

接下来的 3 行输入，每一行是一个长度为 $n$ 的序列，这个序列是 $1$ ~ $n$ 的一个排列，表示在这个场地上选手的实力排序，第一个输入的编号就是这个场地上实力最强的选手编号，以此类推。

#### 输出描述

输出的第一行，包括三个整数，分别表示在场地 1,2,3 上举办的比赛的数量。 

输出的第二行包括 $n$ 个整数，分别表示编号从 1 到 $n$ 的每一位选手的获胜场次。

#### 题目分析

我们将比赛分成两类：第一种是严格的胜利，即赢家的获胜位置严格小于输家的获胜位置。第二种是非严格的胜利，这意味着球员在球场上的获胜位置是相等的。

现在问题转化为在一个 3 列的网格上统计。从左往右扫一遍，对于这一列的每个球员是第一次出现，那么我们统计 $(i+1,n)$ 的答案；否则直接跳过。具体我们要维护 $cnt[8][3]$ 表示在状态 $mask$ 的第 $i$ 行排的最小且球场编号最小的球员的位置。

现在我们计算非严格胜利。枚举 $i$ , $j$ 行 $(i<j)$, 如果 $x$, $y$ 都不等于 0 $(x\not=y)$, 我们可以枚举 $k\in [0,2]$ , 使得在输家位置最靠前的情况下场地编号最小，就可以比较出 $x$ , $y$ 的结果。

常数大概有 $2^3\times 3^2=72$。时间复杂度为 $O(72\times n)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 100010
#define ywhin cin
#define ywhout cout
using namespace std;
van garbage[3][N],n;
van que[N][3],cnt[8][3];
van ans1[N],ans2[N];
van in[N];
void add(van w,van d)
{
	for(int i=1;i<=7;i++) 
	{
		van min_=-1;
		for (int j=0;j<3;j++) if ((i>>j&1)&&(min_==-1||que[w][j]<que[w][min_])) min_=j;
		cnt[i][min_]+=d;
	}
}//维护cnt
int main()
{
	ywhin>>n;
	for (int i=0;i<3;i++) for (int j=1;j<=n;j++) ywhin>>garbage[i][j];
	for (int i=0;i<3;i++) for (int j=1;j<=n;j++) que[garbage[i][j]][i]=j;
	for (int i=1;i<=n;i++) add(i,1);
	for (int i=1;i<=n;i++) 
	{
		for (int j=0;j<3;j++) 
			if (in[garbage[j][i]]) garbage[j][i]=0;
			else
			{
				add(garbage[j][i],-1);
				for (int k=j;k<3;k++) if (garbage[k][i]==garbage[j][i]) in[garbage[j][i]]|=1<<k;
			}
		for (int j=0;j<3;j++) if (garbage[j][i])
		{
			van haha=garbage[j][i];
			for (int k=0;k<3;k++)
			{
				ans1[k]+=cnt[in[haha]][k];
				ans2[haha]+=cnt[in[haha]][k];
			}
			for (int k=j+1;k<3;k++) if (garbage[k][i])
			{
				van ha=garbage[k][i];
				pair<van,van> min_=make_pair(n+1,n+1);
				for (int l=0;l<3;l++) 
				{
					if (que[haha][l]==i) min_=min(min_,make_pair(que[ha][l],(van)l));
					if (que[ha][l]==i) min_=min(min_,make_pair(que[haha][l],(van)l));
				}
				ans1[min_.second]++;
				ans2[que[haha][min_.second]==i?haha:ha]++;
			}
		}
	}
	ywhout<<ans1[0]<<" "<<ans1[1]<<" "<<ans1[2]<<endl;
	for (int i=1;i<=n;i++) ywhout<<ans2[i]<<" ";
	ywhout<<endl;
	return 0;
}
```

## COCI2020-2021 #2

### T1 Crtanje

#### 题目描述 

J 先生过去在 Logo 公司工作，他热爱画图，不过这些天他非常沮丧，因为他被辞退了。为了表示怀念，他决定绘制一条曲线来表示他曾经的公司在过去 $n$ 天的业绩。

对于这 $n$ 天中的每一天，公司的业绩要么增长一个单位(用符号 `+`)来表示，要么减少一个单位(用符号 `-` 来表示)，或者保持不变(用符号 `=` 来表示)。我们把第一天公司的业绩定义为标准 0。

J 先生会在一个巨大的无限字符矩阵中绘制这这一条曲线。矩阵的行表示公司的业绩，标准 0 上的第 $i$ 行，表示公司的收益为 $i$ 个单位。对于第 $i$ 天的业务变化，J 先生会在第 $i$ 列上绘制一些字符。这一列上每一行的字符遵循如下原则：

如果第 $i$ 天公司的业务增长了，那么他就会在代表当天开始的时候公司业绩的对应行 $x$ 的第 $i$ 列设置为字符 `/`。

如果第 $i$ 天公司的业务不变，则会在字符矩阵中把对应的位置设置为 `_`。如果第 $i$ 天的公司业务降低了，则会把字符矩阵的对应位置设置为 `\`。矩阵中的所有其他位置都是字符 `.`。

你的任务是输出最小的，可以包含整个曲线的子矩阵。

#### 输入描述

输入的第一行包括一个正整数 $n(1\leq n\leq 100)$，表示记录的天数。

输入的第二行是一个长度为 $n$ 的由字符 `+` , `-` 和 `=` 组成的字符串，表示在给定的时间中，共色的业绩变化情况。

#### 输出描述

输出包含了业绩曲线的最小子矩阵。

#### 题目分析

水题一道，只需要挨着一个一个地去找这个字符应该画在哪儿就可以了。

时间复杂度为 $O(n^2)$(主要是输出复杂度)。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 1010
#define ywhin cin
#define ywhout cout
using namespace std;
char ans[N][N],cha[N];van n,max_,min_=1e18;
int main()
{
//	ifstream ywhin("crtanje.in");
//	ofstream ywhout("crtanje.out");
	van n;ywhin>>n;
	for (int i=1;i<=n;i++) ywhin>>cha[i];
	for (van i=1,now=500;i<=n;i++)
	{
		if (cha[i]=='=')
		{
			if (cha[i-1]=='-') now--;
			ans[now][i]='_';
			max_=max(max_,now);
			min_=min(min_,now);
		}
		else if (cha[i]=='-')
		{
			if (cha[i-1]!='-') now++;
			max_=max(max_,now);
			min_=min(min_,now);
			ans[now++][i]='\\';
		}
		else if (cha[i]=='+')
		{
			if (cha[i-1]=='-') now--;
			max_=max(max_,now);
			min_=min(min_,now);
			ans[now--][i]='/';
		}
	}//以y=500为基准线来查找这个曲线究竟长啥样
	for (int i=min_;i<=max_;i++)
	{
		for (int j=1;j<=n;j++) ywhout<<(ans[i][j]==0?'.':ans[i][j]);
		ywhout<<endl;
	}//输出矩阵
	return 0;
}
```

### T2 Odasiljaci

#### 题目描述

这是 Sean 最后一次在银幕上出演 James Bond(007)。

他的任务是让 $n$ 座坐落在广阔沙漠中的基站连接成一个网络。这个沙漠可以用一个二维坐标系来表示。007可以决定所有基站(基站的信号强度必须是统一的)的信号强度，信号强度可以用一个非负整数 $r$ 来表示。一个基站的覆盖范围包括以基站坐标为圆心的半径为 $r$ 内的所有区域。如果两个基站存在公共覆盖点 $c$。我们就称这两个基站之间是可以通信的。如果基站 A 和基站 B，基站 B 和基站 C 可以通信。那么我们称基站 A 和基站 C 之间也可以建立通信。

007需要让任意两个基站之间都可以通信。鉴于军情6处经费有限，而越强的信号需要的经费也就越高。你需要帮007求出最小的可以让所有基站互相通信的信号强度 $r$。

#### 输入描述

输入的第一行是一个正整数 $n(1\leq n\leq 1000)$，表示基站的数目。

接下来的 $n$ 行，每行两个正整数 $x,y(1\leq x,y\leq 10^9)$，表示第 $i$ 个基站的坐标。 

#### 输出描述

输出最小的信号强度 $r$。采用实数比较模式，与标准答案的差距小于 $10^{-6}$ 即为正确。

#### 题目分析

首先计算每两个点之间所需要的 $r_{min}$，排序之后挨个判断继续加上这条边后能否使得任意两个基站之间都可以通信，并且记录能使得上述条件成立的 $r$ 的最小值。至于判断上述条件如何成立，只需要用一个并查集来维护即可。

时间复杂度为 $O(2n^2\log_2n)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 1010
#define ywhin cin
#define ywhout cout
using namespace std;
struct node
{
	double num;
	van a,b;
}line[N*N];
van n;double x[N],y[N],ans;van cnt;
van f[N];
van FindFather(van x)
{
	if (x==f[x]) return x;
	return f[x]=FindFather(f[x]);
}//并查集
bool cmp(node a,node b)
{
	return a.num<b.num;
}
int main()
{
//	ifstream ywhin("odasiljaci.in");
//	ofstream ywhout("odasiljaci.out");
	ywhin>>n;
	for (int i=1;i<=n;i++) ywhin>>x[i]>>y[i];
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<i;j++)
		{
			double dis=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
			dis=sqrt(dis);
			dis/=2;
			line[++cnt].num=dis;
			line[cnt].a=i,line[cnt].b=j;
		}
	}//计算任意两个点之间的r的最小值
	for (int i=1;i<=n;i++) f[i]=i;
	sort(line+1,line+cnt+1,cmp);//按照每两个点之间的r的最小值排序
	for (int i=1;i<=cnt;i++)
	{
		if (FindFather(line[i].a)!=FindFather(line[i].b))
		{
			f[FindFather(line[i].a)]=f[FindFather(line[i].b)];
			ans=line[i].num;
		}
	}//并查集查找答案
	ywhout<<fixed<<setprecision(7)<<ans<<endl;
	return 0;
}
```

### T3 Euklid 

#### 题目描述

小 E 是一个对数学非常感兴趣的孩子，一天，他突发奇想发明了一个函数 R。
$$
R(a,b)=
\begin{cases}
R(b,a), a<b\\\\
R(\frac{a}{b},b), a\geq b>1\\\\
a, a\geq b=1
\end{cases}
$$
你的任务是，对于给定的正整数 **$g$** 和 **$h$**。找到一对正整数(a,b)，使得 **$a$ 和 $b$ 的最大公约数为 $g$，同时 $R(a,b)=h$**。

#### 输入描述

输入的第一行包含一个正整数 $t(1\leq t\leq 40)$。表示测试数据的数目。

接下来的 $t$ 行，每行两个正整数 $g$ 和 $h(h\geq 2)$，含义见题目描述。 

#### 输出描述

总共输出 $t$ 行，对于第 $i$ 行，输出两个正整数 $a_i,b_i$。满足 $\gcd(a_i,b_i)=g_i$ 且 $R(a_i,b_i)=h_i$。

输出的数字大小不能超过 $10^{18}$，保证这样的解总是存在的。如果由多组解，输出任意一组。

#### 题目分析

##### 4Pts

当 $g=h$ 时，特解 $a=b=g$ 能恰好使得 $\gcd(a,b)=g$ 且 $R(a,b)=g=h$。

##### 12Pts

在完成Subtask1的基础上考虑如何解决Subtask2。

不难发现，当 $h=2$ 时，特解 $a=5\times g,b=2\times g$ 能恰好使得 $\gcd(a,b)=g$ 且 $R(a,b)=2$。

注意：$a=5\times g,b=2\times g$ 并不是该Subtask的唯一解。

##### 20Pts

在完成Subtask1和Subtask2的基础上考虑如何解决Subtask3。

不难发现，当 $g=h^2$ 时，特解 $a=h^3,b=h^2$ 能恰好使得 $\gcd(a,b)=h^2=g$ 且 $R(a,b)=h$。

注意：$a=h^3,b=h^2$ 并不是该Subtask的唯一解

##### 100Pts

在完成前3个Subtask的基础上考虑如何解决此题。

由于 $h=R(h,1)=R(1,h)=R(b,h)$，则计算 $k$ 次 $\lfloor\frac{b}{h}\rfloor$ 的最终结果一定为1。

考虑暴力 $b$ 的值，由于 $\gcd(a,b)=g$，则 $b=yg$，暴力枚举 $yg$ 是否符合上述条件即可。

对于计算 $a$ 的值，由于 $\gcd(a,b)=g$，则可以令 $a=xg$，由于 $R(a,b)=R(xg,yg)=R(yg,h)=R(h,1)$，即 $\lfloor\frac{x}{y}\rfloor=h$，那么我们可以令 $x=hy+1$，这样既满足 $R(a,b)=h$，也能使得 $\gcd(a,b)=g$。

时间复杂度为 $O(\sum_{i=1}^t x_i)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 100010
#define ywhin cin
#define ywhout cout
using namespace std;
van t;
int main()
{
//	ifstream ywhin("euklid.in");
//	ofstream ywhout("euklid.out");
	ywhin>>t;
	while(t--)
	{
		van g,h;
		ywhin>>g>>h;
		if (g==h) ywhout<<g<<" "<<g<<endl;//Subtask1
		else if (g==h*h) ywhout<<h*h*h<<" "<<h*h<<endl;//Subtask3
		else if (h==2) ywhout<<5*g<<" "<<2*g<<endl;//Subtask2
		else
		{
			van now=2*g;bool ok=false;
			while (!ok)
			{
				van tmp=now;
				while(tmp>1) tmp/=h;
				if (tmp==1)
				{
					ywhout<<now*h+g<<" "<<now<<endl;
					ok=true;
				}
				now+=g;
			}//暴力枚举b的值是否符合条件
		}
	}
	return 0;
}
```

### T4 Sjekira

#### 题目描述

M 先生是一个程序员，不过，他赚够了钱，来到了一个小村子定居。现在，凛冬将至，M 先生不得不砍伐木材生火过冬。

M 先生面前有一棵巨大的树。M 先生将这棵物理意义上的树抽象成了数据结构中的一棵树。树上的每一个节点存在一个坚硬程度 $t_i$。当 M 先生想要砍掉树上的一条边时，他的斧头的受损程度会增加 $t_x+t_y$。$x$ 和 $y$ 分别是砍去这条边后形成的两个子树内 $t_i$ 最大的节点。

你的任务是求出一个砍伐方案，将这棵树的所有边全部砍掉，使得 M 先生的斧头受到的损伤程度最小。

#### 输入描述

输入的第一行包含一个整数 $n$，表示树的大小，树的节点编号从 1 到 $n$。

第二行包含一个 $n$ 个整数，第 $i$ 个整数即为 $t_i(1\leq t_i\leq 10^9)$。含义见题面。

接下来的 $n-1$ 行，每一行由两个整数 $x$ 和 $y(1\leq x,y\leq n)$。表示这棵树上的边。

#### 输出描述

输出一行，一个整数，即最小的斧头磨损程度。

#### 题目分析

##### 40Pts

此档数据范围 $n\leq 1000$，在 $O(n^2)$ 的时间复杂度下完全能够通过此题。不难发现，当从权值最大的节点开始砍直到权值最小的节点的最终的损伤程度一定不劣于随便砍后最终的损伤程度。

最后从根节点开始扫就行了，找到以当前节点为根的子树中权值最大的节点并将其砍掉，再从这个权值最大的点的子树开始扫，直到所有节点都被砍掉即可。

时间复杂度为 $O(n^2)$。

##### 100Pts

按照上述思路进行观察。若某一个节点被找到了的话，那么其所在的子树在上一轮被分割时的最大值一定是它。然后在分割时其又会对最终结果产生 $t_i\times g_i$ 的贡献(设 $g_i$ 为 $i$ 节点的没被砍掉的边的数量)。因此，除权值最大的节点外，其他节点对最终结果的贡献值为 $t_i\times (g_i+1)$。由于权值最大的节点是第一个被分割的，因此在此之前没有进行分割操作，其对最终结果的贡献应为 $t_i\times g_i$。这样我们就可以通过对节点的权值排序再去计算每个结点对最终结果的贡献。最终计算时的时间复杂度仅为 $O(n)$。

时间复杂度为 $O(n\log_2 n)$(主要是排序时间复杂度)。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 100010
using namespace std;
van n,line[N],sum;vector<van> g[N];
struct node{van num,id;}ans[N];
bool cmp(node a,node b){return a.num>b.num;}
int main(){
	cin>>n;
	for (int i=1;i<=n;i++) cin>>ans[i].num,ans[i].id=i;
	for (int i=1;i<n;i++){
		van f,s;
		cin>>f>>s;
		g[f].push_back(s);
		g[s].push_back(f);//建边
		line[s]++,line[f]++;//计算某个点所连接的边的数量
	}
    sort(ans+1,ans+n+1,cmp);
	sum+=line[ans[1].id]*ans[1].num;
	for (int i=0;i<g[ans[1].id].size();i++) line[g[ans[1].id][i]]--;//特殊处理权值最大的点
	for (int i=2;i<=n;i++){
		sum+=(line[ans[i].id]+1)*ans[i].num;
		for (int j=0;j<g[ans[i].id].size();j++) line[g[ans[i].id][j]]--;
	}//处理其他的点
	cout<<sum<<endl;
	return 0;
}
```

### T5 Svjetlo

原文链接: [COCI 2020/2021 Svjetlo（树形DP）_ZSJZ_liuzian的博客-CSDN博客](https://blog.csdn.net/qq_39565901/article/details/110502442)

#### 题目描述

小 F 家的一些灯关上了。现在，小 F 得去把所有的灯打开。小 F 家的灯结构比较特殊，灯泡和电线组成了一个**树结构**。

对于一个灯泡，有一个唯一对应的开关。如果灯是关着的，那么按一下开关之后，灯就会打开，如果灯是打开的，那么按一下开关之后灯就会灭掉。

小 F 按灯泡有一个奇怪的癖好，他会沿着一条**树上的路径**依次找到所有节点对应的开关然后按下开关。你的任务是寻找一条最短的路径，沿着这条路径按开关，会使得**所有的灯泡都被打开**。

输入数据保证至少由一个灯泡在最初的时候是熄灭的。

#### 输入描述

输入的第一行包括一个正整数 $n$。表示灯泡的数量，灯泡的编号从 1 到 $n$。

输入的第二行是一个长度为 $n$ 的由`0`和`1`组成的字符串。如果字符串的第 $i$ 位为`0`，那就表示编号为 $i$ 的灯泡最开始是熄灭的。如果字符串的第 $i$ 位为`1`，就表示编号为 $i$ 的灯泡最开始是打开的。

接下来的 $n-1$ 行，每行两个整数 $x$ 和 $y(1\leq x,y\leq n)$，表示树上的一条连接 $x$ 和 $y$ 的边。

#### 输出描述

输出最小的使得所有灯泡打开的按开关路径，保证存在解，路径的长度定义为路径上点的数目。

#### 题目分析

路径是可以重复的，简单的树形DP可能难以处理，考虑路径的拼接。

设 $f_{i,j,k}$ 表示第 $i$ 个点的子树内（除了自己）的奇偶性已经满足，且子树内（包括自己）的路径端点数有 $j$ 个，第 $i$ 个点的奇偶性为 $k$ 的最短路径长度，其中 $j\in \{0,1,2\},k\in\{0,1\}$。

转移的时候有很多种情况，但它们都是类似的，端点个数（状态第二维）的转移有：

1、儿子子树内均为 0 个端点 –> 自己子树 0 个端点

2、儿子子树内均为 0 个端点 + 自己作为某一个端点 –> 自己子树内 1 个端点

3、儿子子树内均为 0 个端点 + 自己作为两个端点 –> 自己子树内 2 个端点

4、一个儿子子树内 1 个端点 + 其他儿子子树内均为 0 个端点 –> 自己子树内 1 个端点	

5、一个儿子子树内 1 个端点 + 其他儿子子树内均为 0 个端点 + 自己作为某个端点 –> 自己子树内 2 个端点

6、一个儿子子树内 2 个端点 + 其他儿子子树内均为 0 个端点 –> 自己子树内 2 个端点

7、两个儿子子树内各 1 个端点 + 其他儿子子树内均为 0 个端点 –> 自己子树内 2 个端点

第二维的 $j$ 可以理解为是伸出了多少个“头”，然后每个子树相连拼接上，再用剩下的“头”继续往上转移。0 和 2 都是两个“头”， 1 是一个“头”。

儿子之间合并的时候要注意答案所求的是路径点的个数，所以不能把每个儿子所有“2”都延长 2 的长度到父亲，不然儿子之间相接时会算重，而应该少延长一个”头“，最后更新答案时再只加多 1。

如何保证儿子子树内的奇偶性都满足条件？如果从儿子节点尚不满足奇偶性的点转移时，需要多加上 2 的长度，表示到了父亲再往下到儿子走一个来回。

至于第三维是转移到当前节点的 0 还是 1，需要看转移上来的偶儿子（指 $j$ 为偶数的儿子）个数的奇偶性。

还要注意，根节点剩下的两个“头”会相连，不仅答案会减 1 ，而且对他而言奇偶性还会再多变一次。

这样就做完了吗？

写到后面可能会很容易忽略的是，这样写会默认每个节点都至少被经过一次，而其实并不然，所以根节点设为任意一个奇偶性条件为 1 点，同时在枚举儿子转移时，若整个子树都已经满足了就直接跳过。

#### 参考代码

```C++
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define N 500010
int last[N], nxt[N * 2], to[N * 2], len = 0;
int f[N][3][2], a[N], s[N];
void add(int x, int y) {
	to[++len] = y;
	nxt[len] = last[x];
	last[x] = len;
}//加边
void dfs(int k, int fa) {
	int s0 = 0, s1 = 1e9, s2 = 1e9, s3 = 1e9, s4 = 1e9, s5 = 1e9, s6 = 1e9, s7 = 1e9; 
	int t0, t1;
	if(!a[k]) s[k]++;
	for(int i = last[k]; i; i = nxt[i]) if(to[i] != fa) {
		int x = to[i];
		dfs(x, k);
		if(!s[to[i]]) continue;
		s[k] += s[to[i]];
		t0 = min(s7 + f[x][0][1] + 1, s6 + f[x][0][0] + 3), t1 = min(s6 + f[x][0][1] + 1, s7 + f[x][0][0] + 3);
		s6 = t0, s7 = t1;
		t0 = min(s2 + f[x][1][1], s3 + f[x][1][0] + 2), t1 = min(s3 + f[x][1][1], s2 + f[x][1][0] + 2);
		s6 = min(s6, t0), s7 = min(s7, t1);
		
		t0 = min(s5 + f[x][0][1] + 1, s4 + f[x][0][0] + 3), t1 = min(s4 + f[x][0][1] + 1, s5 + f[x][0][0] + 3);
		s4 = t0, s5 = t1;
		t0 = min(s1 + f[x][2][1] + 1, s0 + f[x][2][0] + 3), t1 = min(s0 + f[x][2][1] + 1, s1 + f[x][2][0] + 3);
		s4 = min(s4, t0), s5 = min(s5, t1);
		
		t0 = min(s3 + f[x][0][1] + 1, s2 + f[x][0][0] + 3), t1 = min(s2 + f[x][0][1] + 1, s3 + f[x][0][0] + 3);
		s2 = t0, s3 = t1;
		t0 = min(s0 + f[x][1][1], s1 + f[x][1][0] + 2), t1 = min(s1 + f[x][1][1], s0 + f[x][1][0] + 2);
		s2 = min(s2, t0), s3 = min(s3, t1);
		
		t0 = min(s1 + f[x][0][1] + 1, s0 + f[x][0][0] + 3), t1 = min(s0 + f[x][0][1] + 1, s1 + f[x][0][0] + 3);
		s0 = t0, s1 = t1;
	
	}//快乐状态转移方程
	f[k][0][a[k]] = s1 + 1;
	f[k][0][a[k] ^ 1] = s0 + 1;
	f[k][1][a[k]] = min(s3, s1) + 1;
	f[k][1][a[k] ^ 1] = min(s2, s0) + 1;
	f[k][2][a[k]] = min(min(s0 + 2, s5 + 1), min(s6 + 2, s2 + 2));
	f[k][2][a[k] ^ 1] = min(min(s1 + 2, s4 + 1), min(s7 + 2, s3 + 2));//赋值
}
int main() {
	int n, i, x, y;
	scanf("%d\n", &n);
	for(i = 1; i <= n; i++) {
		a[i] = getchar() - '0';
	}
	for(i = 1; i < n; i++) {
		scanf("%d%d", &x, &y);
		add(x, y), add(y, x);
	}//输入
	for(i = 1; i <= n; i++) if(!a[i]) break;//查找第一个没有打开的灯
	dfs(i, 0);
	printf("%d\n", f[i][2][0] - 1);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

## COCI2020-2021 #3

### T1 Knjige

#### 题目描述

小 A 同学的家里有两个书桌，其中的一个桌子上摆着一摞书，另一个书桌则是空的。小 A 同学是一个强迫症，他总是希望书籍按照自己的厚度堆放。具体的说，最厚的书应该放在最下面， 次厚的书应该放在倒数第二本的位置，以此类推。可惜，现在堆放着书的书桌并没有按照这个规则来摆放。小 A 同学决定进行整理。每一次，小 A 同学会执行如下两个操作中的一个：

1.将一本书从一摞书的顶部拿到自己的某一只手上，前提是这只手上之前没有别的书。 

2.将自己某一只手上的书放到某个书桌上那一摞书的顶部。

小 A 虽然热爱运动，身体强健，但是并不擅长于整理书籍，因此，他希望你能够给他一个操作序列，根据这个操作序列的顺序执行，就可以将所有的书籍整理到**左侧书桌**上，且书籍按照**从厚到薄的顺序从下往上堆叠。**

#### 输出描述

输入的第一行包括一个正整数 $n(1\leq n\leq 100)$，表示书籍的数量。 

输入的第二行是一个长度为 $n$ 的数组 $d$，$d_i(1\leq d_i\leq 1000)$ 表示最开始左侧书桌上的那一摞书从上往下数第 $i$ 本书的厚度。

#### 输出描述

输出的第一行是一个整数 $k(0\leq k\leq 10^5)$，表示你给出的答案操作序列的长度。 

接下来的 $k$ 行每一行是一个格式为: `INSTRUCTION HAND SHELF` 的指令，各个参数意义如下: 

1.`INSTRUCTION` 是下列单词中的一个: `UZMI` (表示从某一个书架顶拿书)，`STAVI`(将一本 书放在某一个书架上) 

2.`HAND` 只能是字符 `L` 和 `D` 中的一个，`L `表示左手，`D` 表示右手。

3.`SHELF` 也只能是字符 `L` 和 `D` 中的一个，`L` 表示左侧书架，`D` 表示右侧书架。

例如:`UZMI L L` 表示的意思就是从左侧书架顶上取出一本书拿在左手上。你不需要最小化你的操作序列长度 $k$。不过操作序列的长度不能超过 $10^5$。可以保证存在满足这个条件的操作序列。

#### 题目分析

由于此题没要求最小化操作序列长度 $k$，因此只需要随便输出可行方案即可。

最简单的一个思路就是现将所有的书籍全部转移到右书桌上，再在右书桌中依次寻找剩下的书本中最大的一个并将其放置左书桌上。

至于如何操作，我们可以先将某一本当前状态下最厚的书以上的所有书籍全部通过某一只手放到另一个书架上，再将当前这本书拿起来，并用另外一只手将刚刚我们所拿到另外一个书架上的书全部拿回来，再将手上的这本书放到另外一个书架上。

对于 $k\leq 10^5$ 的限制，由于每次转移时放到另外一个书架上的书的本数不会超过 $n$，因此每次放书所要执行的操作次数不会超过 $4n$。总操作次数不会超过 $4n^2\leq 4\times 10^4$。

时间复杂度为 $O(n^2)$

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 1010
#define ywhin cin
#define ywhout cout
using namespace std;
van n,d[N],tmp[N],cnt;bool used[N];
struct res 
{
	string op;
	char hand,shelf;
}ans[N*N];
void Output(bool get,bool left_hand,bool left_shelf) {
	cnt++;
	if (get) ans[cnt].op="UZMI";
	else ans[cnt].op="STAVI";
	if (left_hand) ans[cnt].hand='L';
	else ans[cnt].hand='D';
	if (left_shelf) ans[cnt].shelf='L';
	else ans[cnt].shelf='D';
}//添加输出
int main() {
	ywhin>>n;
	for (int i=1;i<=n;i++) {
		ywhin>>d[i];
	}
	memcpy(tmp,d,sizeof tmp);
	sort(tmp+1,tmp+n+1);
	for (int i=1;i<=n;i++) {
		Output(1,1,1);
		Output(0,1,0);
	}//将所有书放到右书架上
    for (int i=n;i>=1;i--) {
		van ct=n;
		while(ct>=1) {
			if (!used[ct]&&d[ct]==tmp[i]) break;
			ct--;
		}//查找最厚的书的上面有多少本书
		used[ct]=1;
		for (int j=n;j>ct;j--) if (!used[j]) {
			Output(1,1,0);
			Output(0,1,1);
		}//将其上面的书全部放到另一个书架上
		Output(1,1,0);//拿起这本书
		for (int j=n;j>ct;j--) if (!used[j]) {
			Output(1,0,1);
			Output(0,0,0);
		}//将刚刚拿走的书通过另一只手拿回来
		Output(0,1,1);//将这本书放下去
	}
	ywhout<<cnt<<endl;
	for (int i=1;i<=cnt;i++) {
		ywhout<<ans[i].op<<" "<<ans[i].hand<<" "<<ans[i].shelf<<endl;
	}
	return 0;
}
```

### T2 Vlak

#### 题目描述

Nina 和 Emilija 正在玩一个特殊的游戏。这个游戏是在一张最开始为空白的纸上进行的。在每一个人的行动回合内，这个人会在这张纸上当前的单词后面加入一个字母。她们会轮流行动， 而 Nina 先手行动。 

操作者必须保证这样一个条件：在添加完一个字符后，整张纸上的单词必须是操作人最喜欢的歌曲的一个单词的前缀。如果不满足条件，进行这个操作的人就输了。

你的问题是，如果两个人都采取最优策略，那么谁会获得最后的胜利。

#### 输出描述

输入的第一行是一个正整数 $n$，表示 Nina 最喜欢的歌曲内的单词数目。

接下来的 $n$ 行，每行包含一个字符串，即 Nina 最喜欢的歌曲内的一个单词。

接下来的一行是一个正整数 $n$，表示 Emilija 最喜欢的歌曲的单词数目。 

接下来的 $m$ 行，每行包含一个字符串，即 Emilija 最喜欢的歌曲内的一个单词。

#### 输出描述

输出获胜者的名字，即 Nina 或 Emilija。

#### 题目分析

很明显的一个 Trie 加博弈论。

由于所有字母的总长度小于等于 $2\times 10^5$，因此我们可以将所有的字母全部扔进 Trie 树里，并标记某个单词究竟是谁的。

最后一遍 DFS 扫描 Trie 树来判断最后究竟是谁获胜即可。

时间复杂度为 $O(\sum_{i=1}^n s_i.size()+\sum_{i=1}^ms_i.size())$ (实际上就是字符串的总长度)。

#### 参考代码

```C++
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt;
struct Trie {
	int son[26];
	bool w[2];
} a[200009];
string s;
void add(string t,bool p) {
	int id=0;
	for(int i=0; i<t.size(); i++) {
		if(a[id].son[t[i]-'a']==0)
			a[id].son[t[i]-'a']=++cnt;
		id=a[id].son[t[i]-'a'];
		a[id].w[p]=1;
	}
}
bool dfs(int x,bool r) {
	Trie now=a[x];
	for(int i=0; i<26; i++) {
		int v=now.son[i];
		if(v==0) continue;
		if(a[v].w[r]&&dfs(v,!r)==r) return r;
	}
	return (!r);
}
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; i++) {
		cin>>s;
		add(s,1);
	}
	scanf("%d",&m);
	for(int i=1; i<=m; i++) {
		cin>>s;
		add(s,0);
	}
	if(dfs(0,1)) cout<<"Nina";
	else cout<<"Emilija";
	return 0;
}
```

### T3 Sateliti

#### 题目描述

一个科学团队正在使用科学望远镜观测土星的卫星。为此，科学家们必须对不同卫星的照片进行分类。这个任务相当困难，因为从不同角度上看过去，卫星的面貌是不一样的。 

卫星图片可以被看成是一个 $n\times m$ 的字符矩阵，矩阵上由两种字符 `*` 和 `.` 构成。我们说两个图片表示的是同一个卫星，表示通过一些**行列平移**，两张图片会变得完全相同。 

为了区分不同的卫星，科学家每需要找到每一个卫星的**字典序最小**的字符矩阵。注意，当我们比较两个字符矩阵的字典序的时候，你可以理解为比较两个字符矩阵**按行拼接**起来的字符串的字典序。你的任务是对于一个给定的字符矩阵，找出它经过行列平移后字典序最小的形式。

#### 输出描述

输入的第一行包含两个正整数 $n,m(q\leq n,m\leq 1000)$。表示字符矩阵的大小。

接下来的 $n$ 行，每行一个长度为 $m$ 的字符串，字符串仅由 `*` 和 `.`构成。

#### 输出描述

输出 $n$ 行，每行 $m$ 个字符，表示我们需要找到的字典序最小的字符矩阵。

#### 题目分析

由于涉及到比较字典序，考虑使用二维哈希算法。

设 $hash(c_{i,j})=p^i\times q^j\times c_{i,j}$，则一个二维矩阵的哈希值可以用这个矩阵中的每一个字符的哈希值之和来表示。至于如何求出某一矩阵中每一个字符的哈希值之和，可以考虑使用二维前缀和。设 $sum_{i,j}$ 为以 $(1,1)$ 为起始点的长为 $i$，宽为 $j$ 的矩阵中所有字符的哈希值之和。则一个起点为 $(x,y)$ 且长为 $l$，宽为 $w$ 的矩阵哈希为 $sum_{x+l-1,y+j-1}-sum_{x-1,y+j-1}-sum_{x+i-1,y-1}+sum_{x-1,y-1}$。

接下来两个二分查找就可以确定两个矩阵的最长公共前缀。先将两个矩阵移动到相同的位置，将整个矩阵乘上 $p^i\times q^j$ 即可。再比较两个矩阵最多有多少行是相等的，最后比较两个矩阵的下一行有多上个字符是相等的。

执行完以上操作之后，比较下一位的字符，更小的代表该矩阵的字典序最小。

时间复杂度为 $O(n^2\log_2 n)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 3010
#define ywhin cin
#define ywhout cout
using namespace std;
const van p=131,q=133;
char ch[N][N];
van n,m,sx=1,sy=1;
unsigned van hash[N][N],sum[N][N];
unsigned van power(van a,van b) {
	unsigned van ans=1,base=a;
	while (b>0){
		if (b%2==1) ans*=base;
		base*=base,b>>=1; 
	}
	return ans;
}//计算乘方
unsigned van HashCalc(van i,van j) {
	return power(p,i)*power(q,j)*ch[i][j];
}//计算单点哈希
void init() {
	for (int i=1;i<=n*2;i++) {
		for (int j=1;j<=m*2;j++) {
			sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+hash[i][j];
		}
	}
}//计算二维前缀和
unsigned van Calc_Matrix(van sx,van sy,van height,van width) {
	van ex=sx+height-1,ey=sy+width-1;sx--,sy--;
	return sum[ex][ey]-sum[sx][ey]-sum[ex][sy]+sum[sx][sy];
}//查询矩阵哈希
//ifstream ywhin("sateliti.in");
//ofstream ywhout("sateliti.out");
int main() {
	ywhin>>n>>m;
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++) {
			ywhin>>ch[i][j];
			ch[i][j+m]=ch[i+n][j]=ch[i+n][j+m]=ch[i][j];
		}
	}//开个四倍数组
	for (int i=1;i<=n*2;i++) {
		for (int j=1;j<=m*2;j++) {
//			cout<<power(2,2)<<endl;
			hash[i][j]=HashCalc(i,j);
		}
	}//计算单点哈希
	init();
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++) {
			if (i!=1||j!=1) {
				unsigned van base1=power(p,sx-i)*power(q,sy-j),
							 base2=power(p,i-sx)*power(q,j-sy);//移位
				van l=1,r=n,tmp=0;
				while(l<=r) {
					van mid=l+r>>1;
					unsigned van matrix1=Calc_Matrix(i,j,mid,m)*base1,
								 matrix2=Calc_Matrix(sx,sy,mid,m)*base2;
					if (matrix1==matrix2) {
						tmp=mid;l=mid+1;
					}
					else r=mid-1;
				}//计算最多有多少行是相等的
//				cout<<i<<" "<<j<<" "<<sx<<" "<<sy<<" "<<tmp<<endl;
				l=1,r=m;van tmp2=0;
				while (l<=r) {
					van mid=l+r>>1;
					unsigned van matrix1=Calc_Matrix(i+tmp,j,1,mid)*base1,
								 matrix2=Calc_Matrix(sx+tmp,sy,1,mid)*base2;
					if (matrix1==matrix2) {
						tmp2=mid,l=mid+1;
					}
					else r=mid-1;
				}//计算下一行有多少个相等的连续的字符
				if (ch[i+tmp][j+tmp2]<ch[sx+tmp][sy+tmp2]) sx=i,sy=j;//比较上述结果的下一位的字符
//				cout<<i<<" "<<j<<" "<<sx<<" "<<sy<<endl;
			}
		}
	}
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++) {
			ywhout<<ch[i+sx-1][j+sy-1];
		}
		ywhout<<endl;
	}
	return 0;
}
```

### T4 Selotejp

#### 题目描述

M 先生的手中有一个大小为 $n\times m$ 的棋盘，每一个棋盘的格子大小都是 $1\times 1$。不幸的是，有一些格子已经弄脏了，需要重新粉刷。

一次粉刷可以粉刷同一行或者同一列的某一些格子。但是 M 先生不允许粉刷到不需要粉刷的格子。你的任务是，求出最少需要粉刷多少次，才能够把棋盘上的脏格子全部粉刷一遍。

#### 输出描述

输入的第一行包含两个整数 $n,m(1\leq n\leq 1000,1\leq m\leq 10)$，表示棋盘的大小。 

接下来的 $n$ 行，每行一个长度为 $m$ 的字符串。只由字符 `.` 和 `#` 组成。字符 `.` 表示这个格子是干净的，字符 `#` 表示这个格子是脏的，需要粉刷。

#### 输出描述

输出一行，一个整数，最少粉刷次数。

#### 题目分析

##### 50Pts

由于 $m\leq 10$，很自然而然地就会想到时间复杂度会出现一个 $2^m$。

考虑使用状压 DP，设 $f[x][k]$ 为搜索到 $x$ 行且当前行的状态为 $k$ 时需要的最小粉刷步数。

枚举上一次的状态与当前行的状态，判断可行性后再进行步数的转移。

时间复杂度为 $O(n\times 2^{2m})$ (据说优化一下还可以拿到满分)。

##### 100Pts

在完成 Subtask1 的基础上继续完成此题。考虑使用轮廓线 DP，记录 $f[i][j][k]$ 为枚举到第 $i$ 行 $j$ 列且前 $m$ 个格子状态为 $k$ 时需要用到的最小步数。

设 $ch[i][j]$ 为输入数组，$(ii,jj)$ 为所要转移到的下一个点的左边。分两种情况进行状态转移：

1.当 `ch[i][j]='.'` 时，`f[i][j][k]` 可以直接转移到 `f[ii][jj][k>>1]`。

2.当 `ch[i][j]='#'` 时，`f[i][j][k]` 可以转移到 `f[ii][jj][(k>>1)+(1<<m-1)]`，且当 `k&(1<<(m-1))&&j>1` 不成立时步数需要加一。在此状态下，`f[i][j][k]` 还可以转移到 `f[ii][jj][k>>1]`，且当 `((k&1)==0&&i>1&&ch[i-1][j]=='#')` 不成立时步数需要加一。

最后输出 `f[n+1][1]` 状态下的最大值即可。

时间复杂度为 $O(nm\times 2^m)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 1010
#define ywhin cin
#define ywhout cout
using namespace std;
van f[N][11][1<<11];
char ch[N][11];
van n,m;
int main(){
	memset(f,(1<<6)-1,sizeof f);
	ywhin>>n>>m;
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++) {
			ywhin>>ch[i][j];
		}
	}
	f[1][1][0]=0;
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++) {
			for (int k=0;k<(1<<m);k++) {
				van ii=i,jj=j+1;
				if (jj>m) jj-=m,ii++;//下一个点的坐标
				if (ch[i][j]=='.') {
					f[ii][jj][k>>1]=min(f[ii][jj][k>>1],f[i][j][k]);
				}//第一种情况
				else {
					f[ii][jj][(k>>1)+(1<<(m-1))]=min(f[ii][jj][(k>>1)+(1<<(m-1))],f[i][j][k]+!(k&(1<<(m-1))&&j>1));
					f[ii][jj][k>>1]=min(f[ii][jj][k>>1],f[i][j][k]+!((k&1)==0&&i>1&&ch[i-1][j]=='#'));
				}//第二种情况
			}
		}
	}
	van ans=1e18;
	for (int i=0;i<(1<<m);i++) ans=min(ans,f[n+1][1][i]);//查找最终状态下的最大值
	ywhout<<ans<<endl;
	return 0;
}
```

### T5 Specijacija

#### 题目描述

给定一个长度为 $n$ 的正整数序列 $a_1,a_1,...,a_n$。其中 $\frac{i(i-1)}{2}<a_i\leq \frac{i(i+1)}{2}$ 。 

这个序列会生成一个包含 $\frac{(n+1)(n+2)}{2}$ 个节点的树。树高为 $n+1$。比如，序列 (1,2,6) 就会生成 下面这棵树： 

![image-20210827145513885](./T5-题目描述-1.jpg)

树的第 $i$ 层包含了节点 $\frac{i(i-1)}{2}+1,...,\frac{i(i+1)}{2}$ 。在这一层中，只有节点 $a_i$ 由两个孩子，其他的节点都只有一个孩子。

你的问题是回答 $q$ 个询问，每一个询问会询问你节点 $x,y$ 的最近公共祖先。

#### 输入描述

输入的第一行包括三个正整数 $n,q,t(1\leq n,q\leq 2\times 10^5,t\in {0,1})$。分别表示生成树的序列的长度，查询的数目以及是否强制在线。 

输入的第二行是一个长度为 $n$ 的数组 $a_i(\frac{i(i-1)}{2}<a_i\frac{i(i+1)}{2})$。这就是生成树的数组。接下来的 $n$ 行，每行两个正整数 $\tilde{x},\tilde{y}(1\leq \tilde{x_i},\tilde{y_i}\leq \frac{i(i+1)}{2})$。这两个数会决定最终询问的 $x,y$。 我们令 $z_i$ 表示第 $i$ 个询问操作的答案，并令 $z_0=0$。$x_i$ 和 $y_i$ 可以用如下方法求出:
$$
x_i=((\tilde{x_i}-1+t\times z_{i-1})\ mod\ \frac{(n+1)
(n+2)}{2})+1\\
y_i=((\tilde{y_i}-1+t\times z_{i-1})\ mod\ \frac{(n+1)(n+2)}{2})+1
$$
$mod$ 表示整数取模运算。需要注意的是，如果 $t=0$，那么就有 $x_i=\tilde{x_i}$ 而 $y_i=\tilde{y_i}$。

#### 输出描述

输出 $q$ 行，每行一个正整数，即 $x,y$ 的最近公共祖先的编号。

#### 题目分析

##### 20Pts

直接建出一棵树然后跑个 LCA 就行了。

时间复杂度为 $O(q\log_2n)$，但 $n\leq 1000$。

##### 100Pts

注意：此方法惨遭卡常，在运气好的情况下可以拿到满分。

由于需要支持在线查询，且 $n\leq 2\times 10^5$，直接建树空间一定会炸，考虑使用可持久化线段树来建树。

我们需要建两颗主席树，一颗用来维护建到当前深度时还有哪些点没有被使用过，一颗用来维护应该接在哪一个节点上。

每一次输入一个 $a[i]$ 时，计算 $a[i]$ 所在的行 $x$ 与列 $y$，在第一颗主席树中二分查询第 $y$ 个没有被使用的点 $k$，将这个点加入我们新建的一个节点 $node[cnt]$ 中。并将其与第二颗主席树上第 $k$ 与 $k+1$ 个点连边，将第一颗主席树的第 $k+1$ 个节点赋值为 0。

接着在节点数组 $node$ 上跑一遍正常的 DFS，计算出其树状结构下的深度与它上升 $2^0$ 的深度后的节点，再通过递推计算出某一个节点上升 $2^z$ 的深度后的节点。

接下来的查询操作，先将两个数 $x$ 与 $y$ 解密出来，计算出 $x$ 与 $y$ 所在的行 $f_x,f_y$ 与列 $g_x,g_y$，再在第二颗主席树中查询当其建树深度为 $f_x,f_y$ 时对应的节点 $x',y'$。并从这个节点开始在所有 $node$ 节点所构成的树上进行正常的 LCA。若发现这两个在同一条链上，则直接输出行数较低的那一个，否则输出 $x',y'$ 的最近公共祖先的真实编号。

时间复杂度为 $O(n\log_2^2n)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
using namespace std;
const van k=21,N=4e5+5;
struct node {
	van ls,rs;
	van num;
};
van up[N][k],n,a[N],RealNum[N<<2],cnt;
van root[N],cnt2,root2[N],cnt3;
node tree[N<<5],tree2[N<<5];
vector<van> g[N];van deep[N],q,t;
van Calc(van x) {
	return x*(x-1)/2;
}
pair<van,van> GetPos(van num) {
	van l=1,r=n+1,ans;
	while (l<=r) {
		van mid=l+r>>1;
		if (Calc(mid)<num) ans=mid,l=mid+1;
		else r=mid-1;
	}
	return make_pair(ans,num-Calc(ans));
}//由某一个数获取到其所在的行与列
van BuildTree(van l,van r) {
	van now=++cnt2;
	if (l==r) {
		++cnt;RealNum[cnt]=Calc(n+1)+l;
		tree[now].num=cnt;
		return now;
	}
	van mid=l+r>>1;
	tree[now].ls=BuildTree(l,mid);
	tree[now].rs=BuildTree(mid+1,r);
	return now;
}//建立第一颗主席树(及上文所提到的第二颗主席树)
van ChangeTree(van p,van l,van r,van where,van num) {
	van now=++cnt2;
	tree[now]=tree[p];
	if (l==r) {
		++cnt;RealNum[cnt]=num;
		tree[now].num=cnt;
		return now;
	}
	van mid=l+r>>1;
	if (where<=mid) tree[now].ls=ChangeTree(tree[p].ls,l,mid,where,num);
	else tree[now].rs=ChangeTree(tree[p].rs,mid+1,r,where,num);
	return now;
}//单点修改主席树上某一节点的值
van QueryTree(van p,van l,van r,van num) {
	if (l==r) return tree[p].num;
	van mid=l+r>>1;
	if (num<=mid) return QueryTree(tree[p].ls,l,mid,num);
	else return QueryTree(tree[p].rs,mid+1,r,num);
}//单点查询主席树上某一节点的值
van BuildTree2(van l,van r) {
	van now=++cnt3;
	if (l==r) {
		tree2[now].num=1;
		return now;
	}
	van mid=l+r>>1;
	tree2[now].ls=BuildTree2(l,mid);
	tree2[now].rs=BuildTree2(mid+1,r);
	tree2[now].num=tree2[tree2[now].ls].num+tree2[tree2[now].rs].num;
	return now;
}//建立第二颗主席树(及上文所提到的第一颗主席树)
van ChangeTree2(van p,van l,van r,van where,van num) {
	van now=++cnt3;
	tree2[now]=tree2[p];
	if (l==r) {
		tree2[now].num=num;
		return now;
	}
	van mid=l+r>>1;
	if (where<=mid) tree2[now].ls=ChangeTree2(tree2[p].ls,l,mid,where,num);
	else tree2[now].rs=ChangeTree2(tree2[p].rs,mid+1,r,where,num);
	tree2[now].num=tree2[tree2[now].ls].num+tree2[tree2[now].rs].num;
	return now;
}//单点修改第二颗主席树的值
van QueryTree2(van p,van l,van r,van L,van R) {
	if (L<=l&&r<=R) {
		return tree2[p].num;
	}
	van mid=l+r>>1,sum=0;
	if (L<=mid) sum+=QueryTree2(tree2[p].ls,l,mid,L,R);
	if (R>mid) sum+=QueryTree2(tree2[p].rs,mid+1,r,L,R);
	return sum;
}//区间查询第二颗主席树上某一些节点的值的和
void AddLine(van father,van son) {
	g[father].push_back(son);
	g[son].push_back(father);
}//新建一条边
void initDFS(van now,van f) {
	for (int i=0;i<g[now].size();i++) {
		if (g[now][i]!=f) {
			deep[g[now][i]]=deep[now]+1;
			up[g[now][i]][0]=now;
			initDFS(g[now][i],now);
		}
	}
}//预处理节点深度与up[i][0]数组
void initLCA() {
	deep[cnt]=1;
	initDFS(cnt,0);
	for (int j=1;j<k;j++) {
		for (int i=1;i<=cnt;i++) {
			up[i][j]=up[up[i][j-1]][j-1];
		}
	}
}//递推处理up数组
van GetDeep(van num) {
	return GetPos(num).first;
}
van LCA(van a,van b,van a1,van b1) {
	if (deep[a1]<deep[b1]) swap(a1,b1),swap(a,b);
	for (int i=k-1;i>=0;i--) {
		if (deep[up[a1][i]]>=deep[b1]) {
			a1=up[a1][i];
		}
	}
	if (a1==b1) {
		return (GetDeep(a)<GetDeep(b)?a:b);
	}
	for (int i=k-1;i>=0;i--) {
		if (up[a1][i]!=up[b1][i]) {
			a1=up[a1][i],b1=up[b1][i];
		}
	}
	return RealNum[up[a1][0]];
} //正常的LCA(但直接返回最终结果)
inline van read() {
    van x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}//快读
inline void write(van x) {
    char F[200];
    van tmp=x>0?x:-x ;
    if(x<0)putchar('-') ;
    van cnt=0 ;
    while(tmp>0)
    {
    	F[cnt++]=tmp%10+'0';
        tmp/=10;
    }
    while(cnt>0)putchar(F[--cnt]) ;
    putchar('\n');
}//快输
int main() {
	n=read(),q=read(),t=read();
	for (int i=1;i<=n;i++) {
		a[i]=read();
	}
	root[n+1]=BuildTree(1,n+1);
	root2[n+1]=BuildTree2(1,n+1);//建树
	for (int i=n;i>=1;i--) {
		pair<van,van> pos=GetPos(a[i]);
		van l=1,r=n+1,tmp1,tmp2;
		while (l<=r) {
			van mid=l+r>>1;
			if (QueryTree2(root2[i+1],1,n+1,1,mid)>=pos.second) {
				tmp1=mid;r=mid-1;
			} 
			else l=mid+1;
		}//查找应该接在哪一列
		l=1,r=n+1;
		while (l<=r) {
			van mid=l+r>>1;
			if (QueryTree2(root2[i+1],1,n+1,1,mid)>=pos.second+1) {
				tmp2=mid,r=mid-1;
			}
			else l=mid+1;
		}//查找下一个有值的列
		van son1=QueryTree(root[i+1],1,n+1,tmp1),
			son2=QueryTree(root[i+1],1,n+1,tmp2);
		root[i]=ChangeTree(root[i+1],1,n+1,tmp1,a[i]);
		van now=QueryTree(root[i],1,n+1,tmp1);
		AddLine(now,son1);AddLine(now,son2);//建边
		root2[i]=ChangeTree2(root2[i+1],1,n+1,tmp1,1);
		root2[i]=ChangeTree2(root2[i],1,n+1,tmp2,0);//修改第二颗主席树某一节点的边权
	} 
	initLCA();
	van z=0;
	while (q--) {
		van x,y;
		x=read(),y=read();
		if (t) {
			x=(x-1+t*z)%Calc(n+2)+1;
			y=(y-1+t*z)%Calc(n+2)+1;
		}//解密x&y
		pair<van,van> posx=GetPos(x),posy=GetPos(y);
		van l=1,r=n+1,tmp1,tmp2;
		while (l<=r) {
			van mid=l+r>>1;
			if (QueryTree2(root2[posx.first],1,n+1,1,mid)>=posx.second) {
				tmp1=mid,r=mid-1;
			}
			else l=mid+1;
		}
		l=1,r=n+1;
		while (l<=r) {
			van mid=l+r>>1;
			if (QueryTree2(root2[posy.first],1,n+1,1,mid)>=posy.second) {
				tmp2=mid,r=mid-1;
			}
			else l=mid+1;
		}//二分查询x&y节点在某一状态下所在的列
		van x1=QueryTree(root[posx.first],1,n+1,tmp1),
			y1=QueryTree(root[posy.first],1,n+1,tmp2);
		z=LCA(x,y,x1,y1);
		write(z);
	}
}
```

## COCI2020-2021 #4

### T1 Pizza

#### 题目描述

在一整天的漫长工作之后，M先生决定晚饭吃一顿披萨来犒劳一下自己。在桌上堆积如山的文件内，他找到了附近一家披萨餐厅的一张传单。 

餐厅内提供 $m$ 种不同的披萨，每种披萨有不同的浇料，这些浇料用正整数编号来表示，第𝑖种披萨有 $k_i$ 种浇料，编号分别为 $b_{i,1},b_{i,2},...,b_{i,k_i}$。 

M先生对于吃东西时非常挑剔的，在所有的这些浇料中，有 $n$ 种浇料是M先生完全不想接触的，他们的编号分别是 $a_1,a_2,...,a_n$。因此，他希望点的披萨是那些完全不包括这 $n$ 种浇料的披萨，你的任务是帮他找出，**有多少种披萨是M先生可以点的**。

#### 输入描述

输入的第一行最开始是一个正整数 $n(1\leq n\leq 100)$。接下来有 $n$ 个互不相同的整数 $a_i(1\leq a_i\leq 100)$，表示M先生不喜欢的浇料的编号。

接下来的一行包括一个正整数 $m(1\leq m\leq 100)$，表示披萨的种类数目。 

接下来的 $m$ 行，每行描述一种披萨，最开始是一个整数 $k_i(1\leq k_i\leq 100)$，表示浇料的种类， 接下来是 $k_i$ 个互不相同的整数 $b_{i,j}(1\leq b_{i,j}\leq 100)$，表示披萨浇料的编号。

#### 输出描述

输出M先生可以点的披萨的数目。

#### 题目分析

水题一道，只需要在输入每一块披萨需要用到的浇料同时比较这种浇料是不是M先生喜欢的就行了。

时间复杂度为 $O(nm^2)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 110
using namespace std;
van n,m,a[N],ans;
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i];
	cin>>m;
	for (int i=1;i<=m;i++)
	{
		van sum;bool ok=true;
		cin>>sum;
		for (int j=1;j<=sum;j++)
		{
			van tmp;
			cin>>tmp;
			for (int k=1;k<=n;k++) if (a[k]==tmp) ok=false;
		}
		ans+=ok;
	}
	cout<<ans;
	return 0;
}
```

### T2 Vepar

#### 题目描述

给定两个正整数区间 $\{a,a+1,..,b\}$ 以及 $\{c,c+1,...,d\}$ 。请你判断 $c(c+1)...d$ 是否被 $a(a+1)...b$ 整除。

#### 输入描述

输入的第一行包括一个正整数 $t(1\leq t\leq 10)$，表示独立的数据的组数。 

接下来的 $t$ 行，每行四个正整数 $a_i,b_i,c_i,d_i(1\leq a_i\leq b_i\leq 10^7,1\leq c_i\leq d_i\leq 10^7)$。

#### 输出描述

输出 $t$ 行，对于第 $i$ 组数据，如果可以整除，请输出 `DA`，否则输出 `NE`。

#### 题目分析

##### 45Pts

只需要一个个挨着顺序去找这个连乘的结果所能拆分出来的质因数就行了。

然后将比较每一个能拆分出来的质因数。若 $c(c+1)...d$ 的质因数 $i$ 的个数小于 $a(a+1)...b$。

时间复杂度为 $O(tn\log_2n)$。

##### 100Pts

例题：阶乘分解

$c(c+1)...d$ 等价于 $\frac{d!}{(c-1)!}$，$a(a+1)...b$ 等价于 $\frac{b!}{(a-1)!}$，对于 $c(c+1)...d$ 的质因数，只需要算出 $d!$ 的质因数然后减去 $(c-1)!$ 的质因数即可。对于 $a(a+1)...b$ 同理。

接下来的比较与45Pts的做法相同。

时间复杂度为 $O(tn)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 10001000
using namespace std;
van t,a,b,c,d;
bool prime[N];
van A[1000100],B[1000100],C[1000100],D[1000100];
vector<van> p;
void init()
{
	for (van i=2;i<=1e7;i++) if (!prime[i]) for (van j=i*i;j<=1e7;j+=i) prime[j]=true;
	for (van i=2;i<=1e7;i++) if (!prime[i]) p.push_back(i);
}//埃式筛法求出1-10^7里的质因数
void calc(van res[N],van n)
{
	for (int i=0;i<p.size();i++)
	{
		van base=1;
		if (p[i]>n) break;
		for (int j=1;j<=log(n)/log(p[i]);j++)
		{
			base*=p[i];
			res[i]+=n/base;
		}
	}
}//计算n!的质因数及个数
int main()
{
	init();
	cin>>t;
	while (t--)
	{
		cin>>a>>b>>c>>d;
		memset(A,0,sizeof A);
		memset(B,0,sizeof B);
		memset(C,0,sizeof C);
		memset(D,0,sizeof D);//清空质因数数组
		calc(A,a-1);calc(B,b);calc(C,c-1);calc(D,d);//计算四个阶乘的质因数
		bool ok=true;
		for (int i=0;i<p.size();i++)
			if (D[i]-C[i]<B[i]-A[i]) ok=false;//检查能否被整除
		cout<<(ok?"DA":"NE")<<endl;
	}
	return 0;
}

```

### T3 Hop

#### 题目描述

池塘内有𝑛朵睡莲，第𝑖朵睡莲上有一个正整数 $x_i$。序列 $(x_i)_{1\leq i\leq n}$ **严格单调递增**。 

每一组数对 $(a,b)$，$(1\leq a<b\leq n)$，属于**三只青蛙**中的一只。一只青蛙可以从睡莲 $i$ 跳到睡莲 $j(j>i)$，当且仅当数对 $(i,j)$属于它，并且**$x_i|x_j$(即$x_i$整除$x_j$)**。

 给青蛙分配数对使得没有任何青蛙可以连续跳跃超过三次。

#### 输入描述

输入的第一行包括一个正整数 $n(1\leq n\leq 1000)$，表示睡莲的数量。

输入的第二行包括 $n$ 个正整数 $x_i(1\leq x_i\leq 10^{18})$，表示睡莲上的数字。

#### 输出描述

输出 $n-1$ 行，在第 $i$ 行内，输出 $i$ 个数字，每一个数字为 $\{1,2,3\}$ 中的一个，第 $i$ 行的第 $j$ 个数字 表示边 $(j,i+1)$ 的归属。

#### 题目分析

##### 1-3Pts

rand一下就行了。能得多少分全靠运气了。

##### 100Pts

由于 $(x_i)_{1\leq i\leq n}$ 且 $x_i|x_j$，则 $x_i<x_j$，因此 $x_j$ 最少都会是 $x_i$ 的两倍。由于每只青蛙最多只能连续跳三次，因此它连续跳三次之后到达的数最小都会是当前这个数的 $2^3$ 倍。接下来我们将整个区块按照数的highbit值分为4部分，每一部分的数的范围分别为 $[1,2^{16}-1],[2^{16},2^{32}-1],[2^{32},2^{48}-1],[2^{48},2^{64}-1]$，再将已经分好的4个部分里又分成4个小部分，这16个部分里的数又分别为 $[1,2^4-1],[2^4,2^8-1],...$，以此类推。因为 $10^{18}\approx 2^{64}$ 且 $10^{18}<2^{64}$，因此我们可以让第一只青蛙只能分别在这16个小部分里面去跳，不能跳出某一小部分到另外的部分去了，这样第一只青蛙无论怎么跳最多只能跳三次。接下来我们又让第二只青蛙只在这4个大部分里去跳，但又只能在这某一个部分里面去跳，又不能从某一个小部分又跳到这一个小部分，最后我们再将剩下的没有跳过的边给第三只青蛙。这样我们就保证了一只青蛙只能连续跳3次。整个过程的模拟如下图所示：

![image-20210819193143586](./T3-分析-100Pts-1.jpg)

时间复杂度为 $O(n^2)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 1010
using namespace std;
van n,a[N];
van belong[N][N];
van highbit(van x)
{
	van tmp=x,ans=0,now=0;
	while (x)
	{
		if(x%2) ans=now;
		now++,x/=2;
	}
	return ans;
}//计算高位highbit
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i];
	for (int i=1;i<=n;i++)
		for (int j=i+1;j<=n;j++)
		{
			if (a[j]%a[i]!=0) belong[i][j]=1;
			else
			{
				if (highbit(a[i])/4==highbit(a[j])/4) belong[i][j]=1;
				else if (highbit(a[i])/16==highbit(a[j])/16) belong[i][j]=2;
				else belong[i][j]=3;
			}
		}//输入并计算点对i,j究竟应该给哪只青蛙
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<i;j++) cout<<belong[j][i]<<" ";
		cout<<endl;
	}//输出结果
	return 0;
}
```

### T4 Janjetina

#### 题目描述

在长期的封锁终于结束之后，M先生决定开始一场盛大的旅行享受风景，以及最重要的美食。 M先生计划可能旅行的城市一共有 $n$ 座，这 $n$ 座城市由 $n-1$ 条道路连接起来，每条道路连接两个城市，并且任意两个点之间都有路径可以联通。 所有连接两个城市的路上都有若干餐厅，他们的美味程度可以用一个数字 $w_i$ 来表示。M先生计划的旅行会从一个城市 $x$ 出发，沿着最短路到另一个城市 $y$ 结束。我们假定每一条连接两个城市的长度都记为一个单位长度。旅行过程中，**M先生会在美味程度最高的一条道路上享用美食**。 对于一次经过 $l$ 个单位长度距离，享受的美食美味程度为 $w$ 的一次旅行，如果 $w-l\geq k$，M先生就会对这次旅行感到满意。你的任务是求出会令M先生感到满意的城市对的数目。

#### 输入描述

输入的第一行包含两个正整数 $n$ 和 $k(1\leq n,k\leq 10^5)$，表示城市的数目以及满意的阈值。 

接下来的 $n-1$ 行，每行三个正整数 $x,y,w(1\leq x,y\leq n,x\not=y,1\leq w\leq 10^5)$，这表示有 一条连接城市 $x$ 和城市 $y$ 的道路，道路上的餐厅美味程度为$w$。

#### 输出描述

输出不同的可以令M先生感到满意的城市对。定义两个城市对 $(x_1,y_1)$，$(x_2,y_2)$ 不同，这两个数对至少满足 $x_1\not=x_2$ 以及 $y_1\not=y_2$ 中的一个。

#### 题目分析

##### 15Pts

此档数据范围 $n\leq 1000$，枚举两个点再通过LCA求出 $w$ 与 $l$ 的值与 $k$ 比较，若符合条件则 $ans$ 加上1。

时间复杂度为 $O(n^2\log_2n)$。

##### 50Pts

在完成Subtask1的基础上考虑如何解决Subtask2。

由于在Subtask2中一定会形成一条链，考虑采用线性的方法解决这个Subtask。我们先将整幅图分为两个区间，计算左区间的某一个点与右区间的某一个点符合条件的情况有多少种。再将左区间分为两个区间，在这两个区间内继续执行上面的操作……以此类推，我们就可以通过分治来解决这个Subtask。当然，在每次都平分这个区间的情况下，能最小化时间复杂度。

时间复杂度为 $O(n\log_2n)$。

##### 100Pts

在完成Subtask2的基础上继续考虑如何解决此问题。

首先，Subtask2中使用到了分治的方法解决线性的问题，那么我们可以考虑在一棵树上使用分治来解决Subtask3，即点分治。

剩下的只需要将点分治的模板套上去就可以解决此问题了。

点分治的参考链接：[【算法学习】点分治 - 粉兔 - 博客园 (cnblogs.com)](https://www.cnblogs.com/PinkRabbit/p/8593080.html)

时间复杂度为 $O(nlog_2^2n)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 100010
using namespace std;
vector<pair<van,van> > g[N];
van size[N],n,k,deep[N],cnt;bool used[N];
pair<van,van> wei[N];van c[N],ans,center,mx;
void FindSize(van root,van f,van s)
{
	size[root]=1;van num=0;
	for (int i=0;i<g[root].size();i++) if (g[root][i].first!=f&&!used[g[root][i].first])
	{
		FindSize(g[root][i].first,root,s);
		size[root]+=size[g[root][i].first];
		if (num<size[g[root][i].first]) num=size[g[root][i].first];
	}
	if (num<s-size[root]) num=s-size[root];
	if (num<mx) mx=num,center=root;
}//查找以root为根节点的树的大小，并且计算这棵树的重心
void FindWeight(van root,van weight,van f)
{
	wei[++cnt]=make_pair(weight,deep[root]);
	for (int i=0;i<g[root].size();i++) if (g[root][i].first!=f&&!used[g[root][i].first])
	{
		deep[g[root][i].first]=deep[root]+1;
		FindWeight(g[root][i].first,max(weight,g[root][i].second),root);
	}
}//计算从root到其子节点的w值
van lowbit(van x){return x&-x;}
void add(van x,van num)
{
	while (x<N)//不能是n，因为w值有可能会大于n
	{
		c[x]+=num;
		x+=lowbit(x);
	}
}
van query(van x)
{
	van ans=0;
	while (x>0)
	{
		ans+=c[x];
		x-=lowbit(x);
	}
	return ans;
}//树状数组快速计算答案
van CalcAnswer(van root,van weight,van d)
{
	cnt=0;deep[root]=d;van tmp=0;
	FindWeight(root,weight,0);
	sort(wei+1,wei+cnt+1);
	for (int i=1;i<=cnt;i++)
	{
		tmp+=query(wei[i].first-k-wei[i].second+1);
		add(wei[i].second+1,1);
	}
	for (int i=1;i<=cnt;i++) add(wei[i].second+1,-1);
	return tmp;
}//计算以root为根节点的答案
void Division(van root)
{
	ans+=CalcAnswer(root,0,0);
	used[root]=1;
	for (int i=0;i<g[root].size();i++) if (!used[g[root][i].first]) ans-=CalcAnswer(g[root][i].first,g[root][i].second,1);//容斥原理减去CalcAnswer(root,0,0)加多了的
	for (int i=0;i<g[root].size();i++) if (!used[g[root][i].first])//到其子树下继续执行点分治
	{
		mx=1e18;
		FindSize(g[root][i].first,root,size[g[root][i].first]);//重新计算树的重心与树的大小
		Division(center);
	}
};
int main()
{
	cin>>n>>k;
	for (int i=1;i<n;i++)
	{
		van f,s,w;
		scanf("%lld%lld%lld",&f,&s,&w);
		g[f].push_back(make_pair(s,w));
		g[s].push_back(make_pair(f,w));//建边
	}
	mx=1e18;FindSize(1,0,n);//查找树的大小以及树的重心
	memset(used,0,sizeof used);
	Division(center);//点分治
	cout<<ans*2<<endl;//由于每两个点只计算了一次，因此最后答案需要乘以2
}
```

### T5 Patkice II

#### 题目描述

三只小鸭，再出发！这一次，海洋会更加汹涌。 

海洋的情况可以用一张大小为 $r\times s$ 的海图表示，海图中的每一个格子会是`<>v^ox`中的一个 字符。其中`o`表示起点,`x`表示终点。字符`<>v^`表示洋流，表示如果小鸭子们到达对应的格子， 会被洋流推向一个相邻的格子`<`表示被洋流推向西侧的格子，`>`表示被洋流推向东侧的格子，`v`表示被洋流推向南侧的格子，`^`表示被洋流推向北侧的格子。`.`则表示一片平静的海洋，到达这种格子之后，小鸭子们就会结束他们的旅途。 

小鸭子们最开始从`o`所在的位置出发，选择东西南北四个方向中的一个，到达相邻的格子， **随后，只能随着洋流移动**。很显然，不能保证小鸭子们一定可以到达目的地，即字符`x`所在的格 子。现在，你被赋予改变自然的能力，必须想办法让鸭子们可以从`o`出发到达`x`。你可以修改海洋中的任何一个格子所在的海域(将对应格子修改为`v^<>.`中的一个，不能修改`o`，`x`所在的格子)。

你需要求出，最少需要修改多少个格子的海域，才能够让小鸭子们从`o`出发，到达`x`。

#### 输入描述

输入的第一行包括两个整数 $r,s(3\leq r,s\leq 2000)$，表示海图的大小。 接下来的 $r$ 行，每行一个长为 $s$ 的字符串，字符集为`o<>v^.x`，表示当前的海洋情况。保证地图中只有一个`o`字符以及`x`字符，并且二者不会相邻。

#### 输出描述

输出的第一行包括一个正整数 $k$，表示最少需要修改的海域的数目。 

接下来的 $r$ 行，每行一个长度为 $s$ 的字符串，描述修改之后海域的形态，描述方法与输入的形式相同。如果存在多种可能的答案，输出任意一种。

#### 题目分析

我们可以通过 01BFS 来解决此问题，将当前漩涡所指向的下一个节点与当前节点所形成的边的权值设置为 0，将其他三个方向的边设置为 1，并使用一个 deque 容器来解决这个 01BFS 问题。最后在使用一个 DFS 来查找需要修改的点并将合法方案输出。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van int
#define N 2010
using namespace std;
struct node
{
	van x,y;
	van step;
};
char cha[N][N];
van n,m,VanGo[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
bool used[N][N];van f[N][N];
deque<node> q;
van sx,sy,ex,ey;
pair<van,van> GetDirByChar(char x)
{
	if (x=='^') return make_pair(-1,0);
	if (x=='v') return make_pair(1,0);
	if (x=='<') return make_pair(0,-1);
	if (x=='>') return make_pair(0,1);
}//根据漩涡的方向来推断要修改的坐标
char GetCharByDir(van x,van y)
{
	if (x==1&&y==0) return 'v';
	if (x==-1&&y==0) return '^';
	if (x==0&&y==1) return '>';
	if (x==0&&y==-1) return '<';
}//根据修改的坐标来推断漩涡的方向
bool in(van x,van y)
{
	return x>0&&x<=n&&y>0&&y<=m;
}//判断(x,y)是否在图内
void DFS(van x,van y)
{
	used[x][y]=1;
	if (x==ex&&y==ey)
	{
		for(int i=1;i<=n;i++)
		{
			for (int j=1;j<=m;j++) cout<<cha[i][j];
			cout<<endl;
		}
		exit(0);
	}//查找到了合法的图
	char tmp=cha[x][y];
	for (int i=0;i<4;i++)
	{
		van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
		if (!in(xx,yy)||used[xx][yy]) continue;
		van w=GetCharByDir(VanGo[i][0],VanGo[i][1])==tmp||tmp=='o'||tmp=='x'?0:1;//计算边的权值
		if (f[xx][yy]==f[x][y]+w)//(xx,yy)有可能是(x,y)的下一个点
		{
			if (cha[x][y]!='o') cha[x][y]=GetCharByDir(VanGo[i][0],VanGo[i][1]);
			DFS(xx,yy);
		}
	}
	cha[x][y]=tmp;//回溯
}
int main()
{
	srand(time(0));
	cin>>n>>m;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) cin>>cha[i][j];//输入地图
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++)
	{
		if (cha[i][j]=='o') sx=i,sy=j;
		if (cha[i][j]=='x') ex=i,ey=j;
	}//判断起点与终点
	q.push_back((node){sx,sy,0});
	while (!q.empty())
	{
		node now=q.front();q.pop_front();
		if (used[now.x][now.y]) continue;
		used[now.x][now.y]=1;f[now.x][now.y]=now.step;
		if (now.x==ex&&now.y==ey) break;
		char tmp=cha[now.x][now.y];
		for (int i=0;i<4;i++)
		{
			node new_elem=now;
			new_elem.x+=VanGo[i][0],new_elem.y+=VanGo[i][1];
			if (!in(new_elem.x,new_elem.y)) continue;
			new_elem.step+=GetCharByDir(VanGo[i][0],VanGo[i][1])==tmp||tmp=='o'||tmp=='x'?0:1;
			if (new_elem.step-now.step==1) q.push_back(new_elem);
			else q.push_front(new_elem);
		}
	}//01BFS解决边权为0或1的最短路问题
	cout<<f[ex][ey]<<endl;//输出(ex,ey)的最小权值即修改次数
	memset(used,0,sizeof used);
	DFS(sx,sy);//DFS查找修改后的图
	return 0;
}
```

## COCI2020-2021 #5

### T1 Sifra

#### 题目描述

骑士 $Borna$ 正在试图破译一封来自他的敌人的秘密信件。这封信件由一个由小写字母和数字符号组成， $Borna$ 需要破译出来的密码就是字符串内不同的数字个数。(连续的数字字符看成一个数字，不可拆开) 

输入保证字符串中的每一个数字都没有前导零。你的任务就是求出不同的数字的个数。

#### 输入描述

第一行包含一个字符串，长度在1到100之间，字符串由小写字母和数字字符组成。输入保 证所有的数字最多只由三个数字字符组成。

#### 输出描述

输出字符串内不同的数字数量。

#### 题目分析

水题一道，从左往右扫一遍字符串，当扫到了某一个数字的时候，在循环内部继续扫下去，直到扫不到数字了为止，并将外层循环的 $i$ 赋值为当前的位置，至于计算这个数字是多少，只需要按照快读的思路计算就行了。

时间复杂度为 $O(s.size())$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 1010
#define ywhin cin
#define ywhout cout
using namespace std;
bool used[N];van an;
int main()
{
//	ifstream ywhin("sifra.in");
//	ofstream ywhout("sifra.out");
	string x;
	ywhin>>x;
	for (int i=0;i<x.size();i++)
	{
		van ans=0;
		while (x[i]>='0'&&x[i]<='9') ans*=10,ans+=x[i]-'0',i++;
		if (ans!=0) used[ans]=1,i--;
	}
	for (int i=0;i<=1000;i++) if (used[i]) an++;
	ywhout<<ans<<endl;
	return 0;
}
```

### T2 Po

#### 题目描述

你会获得一个长度为 $n$ 的序列 $a_i$，这个序列是由一个初始序列经过若干变换得到的。初始序列是一个长度为 $n$ 的全0序列。可能出现的变换规则如下：

单个变换的效果为选择一个区间 [$l$, $r$]，将 $a_l,a_{l+1},...,a_r$ 的值加上一个正整数 $x$。任意两次变换的区间只能**互不相交或者一个区间包含另一个区间**。 

你的问题是，对于给定的序列 $a_i$，这个序列至少是进行了多少次变换得到的。

#### 输入描述

输入的第一行是一个整数 $n(1\leq n\leq 10^5)$，表示序列的长度。

输入的第二行包含𝑛个非负整数 $a_i(0\leq a_i\leq 10^9)$。表示经过若干次变换得到的序列。

#### 输出描述

输出一个整数$m$，表示要得到这个区间的最少的变换次数。

#### 题目分析

分析题意，首先这个题加上的这个正整数 $x$ 只能是个正整数，这意味着我们在每次变换时只能变换到当前区间最小的一个值，如果变换到的不是最小的一个值，那么就再也变换不到当前区间的最小值了。

考虑通过分治来解决此问题。每次变换时查询当前区间的最小值，并根据这个最小值在当前区间所出现的位置来将当前区间拆分为若干个子区间继续进行分治，并且将 $ans$ 的值增加1，直到 $l<r$ 就可以退出该递归函数了。

注意，当区间的最小值为0时， $ans$ 的值不需要增加1，因为此时不需要进行一次变换。

时间复杂度为 $O(n\log_2^2n)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 100010
#define ywhin cin
#define ywhout cout
using namespace std;
van n,a[N],tmp[N];
van tree[N*4],ans;
vector<van> place[N];
void build(van p,van l,van r)
{
	if (l==r){tree[p]=a[l];return;}
	van mid=l+r>>1;
	build(p*2,l,mid);build(p*2+1,mid+1,r);
	tree[p]=min(tree[p*2],tree[p*2+1]);
}//构建线段树
van query(van p,van l,van r,van L,van R)
{
	if (L<=l&&r<=R) return tree[p];
	van mid=l+r>>1;
	van x=1e18;
	if (L<=mid) x=min(x,query(p*2,l,mid,L,R));
	if (R>mid) x=min(x,query(p*2+1,mid+1,r,L,R));
	return x;
}//在线段树内查询最小值
void solve(van l,van r)
{
	if (l>r) return;
	van min_=query(1,1,n,l,r);//获取[l,r]的最小值
	if (tmp[min_]!=0) ans++;//注意:当最小值为0时是不需要ans++的
	van ll=0,rr=place[min_].size()-1,lll;
	while (ll<=rr)
	{
		van mid=ll+rr>>1;
		if (place[min_][mid]>=l) lll=mid,rr=mid-1;
		else ll=mid+1;
	}//二分查找最小值所在的位置id最小的位置
	ll=0,rr=place[min_].size()-1;van rrr;
	while (ll<=rr)
	{
		van mid=ll+rr>>1;
		if (place[min_][mid]<=r) rrr=mid,ll=mid+1;
		else rr=mid-1;
	}//二分查找最小值所在的位置id最大的位置
	solve(l,place[min_][lll]-1);//解决[l,a_l-1]的区间
	for (int i=lll;i<rrr;i++) solve(place[min_][i]+1,place[min_][i+1]-1);//解决[a_i+1,a_{i+1}-1]所在的区间
	solve(place[min_][rrr]+1,r);//解决[a_r+1,r]的区间
}//分治解决问题
int main()
{
//	ifstream ywhin("po.in");
//	ofstream ywhout("po.out");
	ywhin>>n;
	for (int i=1;i<=n;i++) ywhin>>a[i];
	memcpy(tmp,a,sizeof tmp);
	sort(tmp+1,tmp+n+1);
	van cnt=unique(tmp+1,tmp+n+1)-tmp-1;
	for (int i=1;i<=n;i++) a[i]=lower_bound(tmp+1,tmp+cnt+1,a[i])-tmp;//离散化
	for (int i=1;i<=n;i++) place[a[i]].push_back(i);//记录某一个离散化后的数会出现在哪些位置
	build(1,1,n);
	solve(1,n);
	ywhout<<ans<<endl;
	return 0;
}
```

### T3 Megenta

#### 题目描述

小P和小M在玩一个游戏，游戏的内容是这样的。 

有一棵 $n$ 个节点的树，树上的 $𝑛−1$ 条边由三种标记，分别为 $𝑚𝑎𝑔𝑒𝑛𝑡𝑎,𝑝𝑙𝑎𝑣𝑎,c𝑟𝑣𝑒𝑛𝑎$ 。游戏开始的时候，小P的棋子位于节点 $a$ ，小M的棋子位于节点 $b$ 。游戏开始后，小P先行动，他需要选择一条边，从节点 $a$ 沿着边走到另一端，要求小M的棋子另一端并且边的标记为 $𝑝𝑙𝑎𝑣𝑎$ 或者 $𝑚𝑎𝑔𝑒𝑛𝑡𝑎$ 。随后由小M操作，同样沿着一条边走，要求小P的棋子不在另一端，边的标记为 $𝑐𝑟𝑣𝑒𝑛𝑎$ 或 $𝑚𝑎𝑔𝑒𝑛𝑡𝑎$ 。二人轮流操作，首先无法操作的人失败。 

现在，我们假设二人都是绝对理性和聪明的，请问谁会获得胜利。

#### 输入描述

输入的第一行包括一个正整数 $n(1\leq n\leq 10^5)$ ，表示树上的节点的数目。

输入的第二行包括两个正整数 $a,b(1\leq a,b\leq n,a\not=b)$ ，表示最开始小P和小M的棋子所在的 位置。 

接下来的 $n-1$ 行，每行的格式如下" $x\ y\ signal$ "。表示边 $<x,y>$ 上的标记为 $signal$。$signal\in\{magenta,crvena,plava\}$。

#### 输出描述

如果小P会获胜，输出" $Paula$ ",如果小M获胜，输出" $Marin$ "。如果平局，输出" $Magenta$ "。

#### 题目分析

##### 30Pts

由于每条路对于每个人都是可以走的，因此只需要判断两个人之间的距离就行了。

##### 100Pts

令当轮到自己行动前与对方的距离为偶数的一方killer，另一方为loser，则killer只会赢或平局，毕竟其走不到对方的棋子上(当killer根本无法行走时，要注意判断)。

搜索killer能走到的路径，并在这条路径上的每一条父节点扩展他还能到达的子节点标记为1，再搜索loser能否到达这些标记为1的点，即loser能否成功逃脱，若loser能成功逃脱，则为平局，否则loser输。

分类讨论:

1.若先手无处可走，后手赢。

2.若后手无处可走，先手赢。

3.若loser能够成功逃脱，平局。

4.否则killer赢。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 100010
#define pb push_back
#define mp make_pair
using namespace std;
van n,a,b,fa[N],dis[N],len;
vector<pair<van,van> > graph[N];
bool used1[N],used2[N];
van cnt1,cnt2,killer,loser;
void PutError(string info)
{
	cout<<info;
	exit(0);
}//错误输出
void A(){printf("Paula");exit(0);}//先手赢
void B(){printf("Marin");exit(0);}//后手赢
void C(){printf("Magenta");exit(0);}//平局
void DFS1(van u,van f)
{
	fa[u]=f;
	for (int i=0;i<graph[u].size();i++) if (graph[u][i].first!=f) DFS1(graph[u][i].first,u);
}//查找每个子节点的父亲节点
void DFS2(van u,van f)
{
	cnt1++;
	for (int i=0;i<graph[u].size();i++) if (graph[u][i].first!=f&&graph[u][i].first!=b&&graph[u][i].second!=a) DFS2(graph[u][i].first,u);
}//查找a能走的点
void DFS3(van u,van f)
{
	cnt2++;
	for (int i=0;i<graph[u].size();i++) if (graph[u][i].first!=f&&graph[u][i].second!=b) DFS3(graph[u][i].first,u);
}//查找b能走的点
void DFS4(van u,van f,van step)
{
	dis[u]=step;cnt1++;used1[u]=1;
	for (int i=0;i<graph[u].size();i++) if (graph[u][i].first!=f&&graph[u][i].second!=killer) DFS4(graph[u][i].first,u,step+1);
}//搜索killer能走到的点
void DFS5(van u,van f,van step)
{
	if (used2[u]) C();
	for (int i=0;i<graph[u].size();i++) if (graph[u][i].first!=f&&graph[u][i].second!=loser&&step+1-(loser==a)<dis[graph[u][i].first]) DFS5(graph[u][i].first,u,step+1);
}//搜索loser能能否逃脱
int main()
{
	scanf("%lld\n%lld%lld",&n,&a,&b);
	for (int i=1;i<n;i++)
	{
		van f,s;string w;
		scanf("%lld%lld",&f,&s);cin>>w;
		van weight=112700;
		if (w[0]=='m') weight=0;
		else if (w[0]=='p') weight=b;
		else if (w[0]=='c') weight=a;
		else PutError("Input Error!");
		graph[f].pb(mp(s,weight));
		graph[s].pb(mp(f,weight));
	}//加边
	DFS1(1,0);
	for (int i=a;i;i=fa[i])
	{
		used1[i]=1;
		dis[fa[i]]=dis[i]+1;
	}
	if (used1[b]) len=dis[b];
	else for (int i=b;i;i=fa[i])
	{
		if (used1[fa[i]])
		{
			len=dis[i]+dis[fa[i]]+1;
			break;
		}
		dis[fa[i]]=dis[i]+1;
	}
	killer=len%2?b:a,loser=len%2?a:b;//查找killer与loser
	for (int i=1;i<=n;i++) used1[i]=0,dis[i]=1e18;
	DFS2(a,0);if (cnt1==1) B();
	DFS3(b,0);if (cnt2==1) A();
	DFS4(killer,0,0);
	for (int i=1;i<=n;i++) if (!used1[i])
	{
		for (int j=0;j<graph[i].size();j++) if (!used1[graph[i][j].first]&&graph[i][j].second!=loser)
		{
			used2[i]=1;
			break;
		}
	}
	DFS5(loser,0,0);
	if (killer==a) A();else B();//loser无法逃脱
	return 0;
}
```

### T4 Planine

### 题目描述 :

勇者小𝑍要跨越精灵山脉寻找遗落的精灵秘宝。精灵山脉可以用一个长为奇数的坐标序列表示，如果我们将这些点的坐标按照 $x$ 坐标排序，除去第一个点和最后一个点之外的奇数编号的点的 $y$ 坐标表示**山谷**的高度，偶数编号的点表示**山顶**的坐标。显然，山谷的高度一定比旁边的两个山顶的高度低。 

勇者小𝑍惧怕黑暗，好在精灵山脉内有着可以照明的精灵，这些精灵固定在高度为$h$的地方， 一个精灵可以照亮一座山谷，当且仅当**该精灵与这座山谷的连线不会与山脉相交**。

你的任务是求出，最少需要多少只精灵的帮助才能够照亮所有山谷，让小𝑍穿越精灵山脉。

#### 输入描述

输入的第一行包括两个正整数 $n(3\leq n\leq 10^6)$，$n$ 是一个奇数和正整数 $h(1\leq h\leq 106)$ 分别描述精灵山脉以及照明精灵的高度。 

接下来的𝑛行，第𝑖行包括两个整数 $x_i$ 和 $y_i(-10^6\leq x_i\leq 10^6,0\leq y_i<h)$，表示描述山脉的第 𝑖个点的坐标。 

输入保证 $x_1<x_2<...<x_n$，并且 $y_1<y_2,y_2>y_3,y_3<y_4...y_{n-1}>y_n$。

#### 输出描述

输出最少的，照亮所有山谷所需要的照明精灵的数目。

#### 题目分析

#### 20Pts:

由于这一档的山顶的高度都相同，因此我们只需要通过映射一只精灵能够照亮某一个山谷所需要放置的范围，然后用一个贪心就可以通过此题。

贪心策略:

设第$i$个山谷映射后的范围为$[l_i,r_i]$，已经安放的最后一只精灵的坐标为$(pos,h)$，$pos=-\infty$ ，按照每个范围的左端点 $l_i$ 从小到大排序。

依次考虑每个区间，若 $l_i>pos$，则在 $r_i$ 的位置上新增一只精灵。否则就将最后的那一只精灵从 $pos$ 放置到 $\min(pos,r_i)$。

##### 50Pts

此档数据量 $n\leqslant 2000$，在 $n^2$ 的时间复杂度能够通过此题，因此在执行贪心操作之前使用 $n^2$ 的时间复杂度找到不会被挡住的山顶的编号以及映射到的位置即可。

##### 100Pts

在某相邻两个山顶中间连一条线(如下图所示)，在这条线所在的直线上方的所有山谷与上方的山顶的连线都会比与下方山顶的连线更优，因此其右上方的山谷会将下方山顶给踢掉，最后形成的会是一个上凸壳，从左往右以及从右往左各扫一遍之后就能找到对于每个山谷所映射的位置，然后根据贪心策略解决此问题即可。

![image-20210817203120771](./T4-分析-100Pts-1.jpg)

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 1000100
#define ywhin cin
#define ywhout cout
using namespace std;
struct node
{
	van x,y;
}pts[N];//存储输入的点
struct node2
{
	double l,r;
}area[N];//存储山谷所映射到h的区间
van p[N],l=1,r=0;
van L[N],R[N];
van n,h,cnt,ans;
double calc(node a,node b)
{
	double dertax=b.x-a.x,dertay=b.y-a.y;
	return dertay/dertax;
}//计算斜率
bool cmp(node2 a,node2 b)
{
	if (a.l==b.l) return a.r<b.r;
	return a.l<b.l;
}//比较函数
int main()
{
 	scanf("%lld %lld",&n,&h);
	for (int i=1;i<=n;i++) scanf("%lld %lld",&pts[i].x,&pts[i].y);
	for (int i=2;i<=n-1;i++)//正着扫一遍
	{
		if (!(i%2))
		{
			while (l<r&&calc(pts[p[r-1]],pts[p[r]])<=calc(pts[p[r]],pts[i])) r--;//注意:这里不加等于号会TLE 
			p[++r]=i;
			while (r==l+1&&pts[p[l]].y<pts[p[r]].y) l++;
		}//山顶踢山顶(维护凸壳)
		else
		{
			double min_k=1e18,now=-1;
			for (int j=l;j<=r;j++)
			    if (now==-1||calc(pts[p[j]],pts[i])<min_k) min_k=calc(pts[p[j]],pts[i]),now=p[j];
			L[i]=now;
		}//查找对于当前山谷来说最高的左边的山顶的编号
	}
	l=1,r=0;
	for (int i=n-1;i>=2;i--)//反着扫一遍
	{
		if (!(i%2))
		{
			while (l<r&&calc(pts[p[r]],pts[p[r-1]])>=calc(pts[i],pts[p[r]])) r--;//注意:这里不加等于号会TLE
			p[++r]=i;
			while (r==l+1&&pts[p[r]].y<pts[p[l]].y) l++;
		}//山顶踢山顶(维护凸壳)
		else
		{
			double min_k=1e18,now=-1;
			for (int j=l;j<=r;j++)
			    if (now==-1||calc(pts[p[j]],pts[i])>min_k) min_k=calc(pts[p[j]],pts[i]),now=p[j];
			R[i]=now;
		}//查找对于当前山谷来说最高的右边的山顶的编号
	}
	for (int i=3;i<=n-2;i+=2)
	{
		area[++cnt].l=(double)pts[i].x-(double)(h-pts[i].y)/(pts[L[i]].y-(double)pts[i].y)*(double)(pts[i].x-pts[L[i]].x);
		area[cnt].r=(double)pts[i].x+(double)(h-pts[i].y)/(pts[R[i]].y-(double)pts[i].y)*(double)(pts[R[i]].x-pts[i].x);
	}//计算当前山谷所映射到h的区间
	double pos=-1e9;
	sort(area+1,area+cnt+1,cmp);
	for (int i=1;i<=cnt;i++)
	{
		if (area[i].l>pos) ans++,pos=area[i].r;
		else pos=min(pos,area[i].r);
	}//贪心计算最小值
	cout<<ans<<endl;
	return 0;
}
```

### T5 Sjeckanje

#### 题目描述

给定一个长度为 $n$ 的序列 $a_i$。我们定义一个序列的划分是将一个序列划分为若干个区间，这 些区间依次连接起来就可以还原整个序列。例如：区间[1 3]\[1 4][3 6]就是序列1 3 1 4 3 6的一个 合法划分。我们定义一个区间的权值为**区间内的最大值减去区间内的最小值。定义在这个区间划分下，序列的权值为各个区间的权值的和。**

例如：在区间划分[1 3]\[1 4][3 6]的情况下，序列的权值为 $(3-1)+(4-1)+(6-3)=9$。 

你的任务是：求出序列 $a_i$ 权值最大的区间划分所对应的序列权值。 

需要支持 $q$ 次修改操作，修改操作形式如下:将下标区间[ $l,r$ ]中的 $a_i$ 加上 $x$ 。你需要在每一次修改操作之后，输出新的序列的权值最大的区间划分所对应的权值。

#### 输入描述

输入的第一行包括两个整数 $n$ 和 $q(1\leq n,q\leq 2\times10^5)$，分别表示序列的长度已经更新操作的次数。 第二行包含 $n$ 个整数 $a_i(-10^8\leq a_i\leq 10^8)$，表示序列的初值 $a_i$。 接下来的 $q$ 行，每行包括三个整数 $l,r(1\leq l\leq r\leq n)$ 和 $x(-10^8\leq x\leq 10^8)$，描述一个修改操作。

#### 输出描述

输出 $q$ 行，每行一个整数，表示每一次更新操作之后序列最大的可能的区间划分的权值。

#### 题目分析

##### 30pts

令 $dp_i$ 为对于前 $i$ 个数据的区间能取到的最大权值，则 $dp_{i+j}=dp_i+a_{max}-a_{min}$。

而对于区间修改，for循环一个一个地加就行了，时间复杂度就只有 $O(qn)$。

总时间复杂度 $O(qn^2)$。

##### 60pts

最短路优化，将非单调区间拆分成若干个单调区间，使得最终答案一定不劣。

令 $d_i$ 为 $a_i$ 与 $a_{i-1}$ 的差值，则 $d_i=a_i-a_{i-1}\ \&\ d_1=0$。

若对于区间 $[l,r]$，使得 $d_{l+1},d_{l+2},...,d_r$ 的符号一定是一样的，则当前区间$[l,r]$所能提供的对答案的贡献为 $\sum_{l+1}^r|d_i|$。

时间复杂度为 $O(qn)$。

##### 100pts

引入线段树进行维护，记录线段树节点 $T[x][0/1][0/1]$，表示线段树节点为$x$所代表的区间能取到的区间最值。

后面的两个0/1分别表示左端点的 $d_i$ 取还是不取，以及右端点 $d_i$ 取还是不取。

修改时只需要修改所需要修改的区间的左端点以及右端点然后更新到线段树上即可。

时间复杂度为 $O(qlog_2n)。$

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 1000100
using namespace std;
van n,a[N],q,d[N];
van t[N*4][2][2];//线段树
void update(van p,van num)
{
	for (int i=0;i<2;i++) for (int j=0;j<2;j++)
	{
		t[p][i][j]=-1e18;
		for (int k=0;k<2;k++) for (int l=0;l<2;l++) if (l!=1||k!=1||d[num]*d[num+1]>=0) t[p][i][j]=max(t[p][i][j],t[p*2][i][k]+t[p*2+1][l][j]);
	}
}//更新线段树p节点上的值
void add(van p,van l,van r,van where)
{
	if (l==r)
	{
//		cout<<"add "<<l<<" "<<d[l]<<endl;
		t[p][1][1]=abs(d[l]);
		return;
	}
	van mid=l+r>>1;
	if (where<=mid) add(p*2,l,mid,where);
	if (where>mid) add(p*2+1,mid+1,r,where);
	update(p,mid);
}//更新线段树(单点修改)
van query(van x)
{
	return max(t[x][0][0],max(t[x][0][1],max(t[x][1][0],t[x][1][1])));
}//查询线段树上x节点的最大值
int main()
{
//	ifstream ywhin("sjeckanje.in");
//	ofstream ywhout("sjeckanje.out");
	#define ywhin cin
	#define ywhout cout
	ywhin>>n>>q;
	for (int i=1;i<=n;i++) ywhin>>a[i];
	for (int i=1;i<=n;i++) d[i]=i==1?0:a[i]-a[i-1],add(1,1,n,i);//差分并插入线段树上
	while (q--)
	{
		van l,r,k;
		ywhin>>l>>r>>k;
		if (l!=1)
		{
			d[l]+=k;
			add(1,1,n,l);
		}//添加左端点
		if (r!=n)
		{
			d[r+1]-=k;
			add(1,1,n,r+1);
		}//添加右端点
		cout<<query(1)<<endl;//查询[1,n]的区间最值
	}
	return 0;
}
```

## 20220207 

### T1 社交距离

#### 题目描述

一种可怕的新疾病 COVID-19 已开始在世界各地传播。人们试图采取尽可能多的预防措施以保护自己免受感染，其中有一项就是增加人与人之间的“社交距离”。

现在考虑这样的一个问题：在火车站的候车厅有一排狭窄的座位，连续 N 个座位在一条直线上。 这些座位中有一些目前被人占据，有些空着。 在了解了“社交距离”D的重要性之后，后来的人都希望最大化 D，其中 D 是最近的两个被占用的座位之间的距离。 例如，如果座位 3 和 8 是最接近的座位，则 D = 5。

最近有一个新的乘客来了想找位子坐下，他需要确定应该坐哪个以前空置的座位，以使 D 的最终值仍尽可能大。注意：已经坐下来的乘客不能动。

#### 题目分析

~~学过数组的人都会做。~~

主要是注意细节问题，代码本身是没有问题的，但是 std 还是出了点问题的。

#### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
char state[MaxN];van max_=-1e18,min_=1e18;
van ans=0;
int main() {
	freopen("socdist.in","r",stdin);
	freopen("socdist.out","w",stdout);
	van n;cin>>n; van lst=-1,st=-1;
	for (int i=1;i<=n;i++) cin>>state[i];
	for (int i=1;i<=n;i++) {
		if (state[i]=='1') {
			if (lst==-1){lst=i;st=i;continue;}
			max_=max(i-lst,max_);
			min_=min(min_,i-lst);
			lst=i;
		}
	} ans=max(min(min_,n-lst),min(min_,st-1));
	ans=max(ans,min(min_,max_/2)); print(ans);
	return 0;
}

```

### T2 路径

#### 题目描述

给出一棵n个节点的树，节点编号为1~n（根节点编号为1）。对于每一个叶子节点，输出从根到叶子的路径。

注意：按照路径的字典序从小到大输出。

#### 题目分析

普普通通的 DFS，只不过跑之前对于每个非叶节点将自己的儿子按序号从小到大排个序就可以了。

#### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
van n; vector<van> g[MaxN];
van st[MaxN],top=-1;
void DFS(van now=1) {
	st[++top]=now;
	if (g[now].size()==0) {
		for (int i=0;i<=top;i++) 
			print(st[i]),putchar(' ');
		putchar('\n'); top--;
		return;
	} for (int i=0;i<g[now].size();i++)
		DFS(g[now][i]); top--;
}
int main() {
	freopen("path.in","r",stdin);
	freopen("path.out","w",stdout);
	n=read(); for (int i=1;i<n;i++) {
		van f=read(),s=read();
		g[f].push_back(s);
	} for (int i=1;i<=n;i++) sort(g[i].begin(),g[i].end());
	DFS();
	return 0;
}

```

### T3 倾斜的线

#### 题目描述

给定两个正整数 P 和 Q。在二维平面上有 n 个整点。现在请你找到一对点使得经过它们的直线的斜率在数值上最接近 P/Q（即这条直线的斜率与 P/Q 的差最小），请输出经过它们直线的斜率 p/q。如果有两组点的斜率的接近程度相同，请输出较小的斜率。

保证答案的 p/q > 0，即输出的 p 和 q 都是正整数。

#### 题目分析

将所有点按照过其的斜率为 P/Q 的直线的截距排序。令(i,j,k)为其中的有序三元组，易证得直线(i,j)和直线(j,k)中至少有一条的斜率比直线(i,k)的斜率更接近 P/Q，故答案所选的两个点在排序后一定相邻。

注意直接用 double 类型可能会炸精度，所以需要用整数进行判断。

#### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef __int128 van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
template<typename T> inline
T abs(T x) {return x<0?-x:x;}
const van MaxN=2e5+10;
van n,P,Q,ansp=1,ansq=-1,id;
struct point {
	van x,y;
	point(){};
	point(van x,van y):x(x),y(y){};
	bool operator < (const point& a) const {
		if (x==a.x) return y<a.y;
		return x<a.x; 
	}
}p[MaxN];
struct point2 {
	van x,y,id;
	point2(){};
	point2(van x,van y,van id):x(x),y(y),id(id){};
	bool operator < (const point2& a) const {
		if (y==a.y) return x<a.x;
		return y<a.y; 
	}
}p2[MaxN];
bool judge2(van p1,van q1,van p2,van q2) {
	return p1*q2<p2*q1;
}
void SubTask2() {
	for (int i=1;i<=n;i++) p2[i]=point2(p[i].x,p[i].y*Q-p[i].x*P,i);
	sort(p2+1,p2+n+1); for (int i=1;i<=n-1;i++) {
		van a=i,b=i+1;
		van ansp1=abs(p2[a].y-p2[b].y),ansq1=abs(p2[a].x-p2[b].x);
		if (id==0) ansp=ansp1,ansq=ansq1,id=i;
		else if (judge2(ansp1,ansq1,ansp,ansq)) ansp=ansp1,ansq=ansq1,id=i;
	} van a=p2[id].id,b=p2[id+1].id;
	van resp=abs(p[a].y-p[b].y),resq=abs(p[a].x-p[b].x);
	van gcd=__gcd(resp,resq);resp/=gcd,resq/=gcd;
	print(resp),putchar('/'),print(resq);
}
int main() {
	freopen("slope.in","r",stdin);
	freopen("slope.out","w",stdout);
	n=read(),P=read(),Q=read(); 
	for (int i=1;i<=n;i++) {
		van x=read(),y=read();
		p[i]=point(x,y);
	}
	SubTask2();
	return 0;
}
```

### T4 符文

#### 题目描述

给定一个长度为 |s| 的符文串 s 和一个长度为 |p| 的符文串 p ，定义符文的等级r(s,p) 表示符文串 s 中最多有多少个互不重叠的子串 p 。

现在你可以在任意位置删除任意个符文。

你需要算出在删除 i (0≤i≤|s|)个符文后得到的符文串ti的r(ti,p)。

#### 题目分析

dp，令 f[i][j] 为前 i 个符文删去 j 个符文后最多有多少个 p 串。

令 w[i] 为使得第 i 个符文到第 i+w[i]-1 个符文仅有一个子序列等于 p 的最小的 w[i]。

可推导出状态转移方程如下: 

不删除时: f[i+1][j]=Max{f[i][j]};

删除时: f[i+1][j+1]=Max{f[i][j]},f[i+w[i]][j+w[i]-|p|]=Max{f[i][j]+1};

#### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;
	char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;
	return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {
		putchar('0');
		return;
	}
	van st[41]= {0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k; i; i--) putchar('0'+st[i]);
}
const van MaxN=2e3+10;
const van MaxM=5e2+10;
string s,p;
van f[MaxN][MaxN];
van w[MaxN];
int main() {
	freopen("runes.in","r",stdin);
	freopen("runes.out","w",stdout);
	cin>>s>>p;
	van n=s.size(),m=p.size();
	memset(w,-1,sizeof w);
	for (int i=0; i<n; i++) {
		van k=0;
		for (int j=i; j<n; j++) {
			if (s[j]==p[k]) k++;
			if (k==p.size()) {
				w[i+1]=j-i+1;
				break;
			}
		}
	}
	memset(f,-1,sizeof f);
	f[0][0]=0;
	for (int i=1; i<=n; i++) {
		for (int j=0; j<=i; j++) {
			f[i][j]=max(f[i][j],f[i-1][j]);
			f[i][j+1]=max(f[i][j+1],f[i-1][j]);
			if (w[i]!=-1)
				f[i+w[i]-1][j+w[i]-m]=max(f[i+w[i]-1][j+w[i]-m],f[i-1][j]+1);
		}
	}
	for (int i=0; i<=n; i++) print(f[n][i]),putchar(' ');
	return 0;
}
```

### T5 购票

#### 题目描述

旅行的路线由编号为 1…N（1≤N≤10^5）的 N 个检查点组成。有 K（1≤K≤10^5）张票可供购买。第 i 张票可以在检查站 ci（1≤ci≤N）以 pi（1≤pi≤10^9）的价格购得，并且可以用其进入所有检查站 [ai,bi]（1≤ai≤bi≤N）。在进入任何检查站之前，必须已购买一张允许其进入该检查站的票。一旦可以前往某一检查站，就可以在未来的任何时候回到该检查站。对于每一个 i∈[1,N]，如果最初只能进入检查点 i，输出使得可以进入检查点 1 和 N 所需的最低总价。如果无法这样做，输出 −1

#### 题目分析

线段树优化建边。 对于每一条边，由于只用付一次的价钱，所以需要将要连起来的边先连到一个新点上，权值为 0，然后再将这个点和目标点连接起来，权值为 pi，然后跑出 1 和 n 到各点的最短路，在将所有的点扔进堆里总体跑一个最短路即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
struct ticket{
	van p,c,a,b;
	ticket(){};
	ticket(van p,van c,van a,van b):p(p),c(c),a(a),b(b){};
}t[MaxN];
struct Edge {
	van u,v,w;
	Edge(van u,van v,van w):u(u),v(v),w(w){};
};
van n,k; van id[MaxN];
vector<Edge> g[MaxN*6];

void Connect(van from,van to,van w) {
	g[from].push_back(Edge(from,to,w));
}
void BuildTree(van p=1,van l=1,van r=n) {
	if (l==r) {id[l]=p;return;} van mid=(l+r)>>1;
	Connect(p*2,p,0); Connect(p*2+1,p,0);
	BuildTree(p*2,l,mid); BuildTree(p*2+1,mid+1,r);
} 
void Update(van L,van R,van from,van p=1,van l=1,van r=n) {
	if (L<=l&&r<=R) {
		Connect(p,from,0);
		return;
	} van mid=(l+r)>>1;
	if (L<=mid) Update(L,R,from,p*2,l,mid);
	if (R>mid) Update(L,R,from,p*2+1,mid+1,r);
}
struct state {
	van dis,id;
	state(van dis,van id):dis(dis),id(id){};
	bool operator < (const state& a) const {
		return dis>a.dis;
	}
}; priority_queue<state> q;
van dis[MaxN*6]; bool used[MaxN*6];
van dis1[MaxN*6],dis2[MaxN*6];
void Dijkstra(van st,bool ahhh=true) {
	memset(used,0,sizeof used);
	for (int i=1;i<=5*n+k;i++) dis[i]=1e18;
	if (ahhh) dis[st]=0,q.push(state(dis[st],st));
	else {
		memcpy(dis,dis1,sizeof dis);
		for (int i=1;i<=5*n+k;i++) q.push(state(dis[i],i));
	}
	while (!q.empty()) {
		van now=q.top().id; q.pop();
		if (used[now]) continue; used[now]=1;
		for (int i=0;i<g[now].size();i++) {
			Edge e=g[now][i];
			if (dis[e.v]>dis[now]+e.w) {
				dis[e.v]=dis[now]+e.w;
				q.push(state(dis[e.v],e.v));
			}
		}
	}
}
int main() {
	n=read(),k=read(); BuildTree();
	for (int i=1;i<=k;i++) {
		van p=read(),c=read(),a=read(),b=read();
		t[i]=ticket(p,c,a,b);
		Update(a,b,4*n+i);
		Connect(4*n+i,id[p],c);
	} Dijkstra(id[1]); memcpy(dis1,dis,sizeof dis1);
	Dijkstra(id[n]); for (int i=1;i<=n*5+k;i++) dis1[i]+=dis[i];
	Dijkstra(0,false); for (int i=1;i<=n;i++)
		print(dis[id[i]]>=1e18?-1:dis[id[i]]),putchar('\n');
	return 0;
}
```

## 20220210

### T1 商贸

#### 题目描述

勇者小𝐴通过寻宝提升自己的实力之后仍然无法战胜虫群，他终于意识到了一个人的力量终究时有极限的，因此，他决定开始招兵买马，然而，一个很现实的问题摆在他的面前——他没有钱。所幸他现在所在的国家是一个商贸非常发达的商业共和国，他可以从中跑商赚钱。共和国内有𝑁座城市，编号为1,2,3 … 𝑁。由𝑀条单向的道路连接。小𝐴每一次到达城市𝑖都可以获得𝑚𝑖的收益。小𝐴最开始位于城市1，最后也必须回到编号为1的城市。不过身为勇者的小𝐴的时间是非常宝贵的，沿着一条道路从一座城市到达另一座城市需要花费一天的时间。为了量化小𝐴花费时间贸易的代价，我们认为小𝐴花费𝑇时间贸易的成本为𝐶 × 𝑇^2。

你需要计算出小𝐴可能得到的最高收益。

#### 题目分析

注意到时间成本很低，考虑直接 dp，设 f[i][j] 为第 i 个点在第 j 的时间能够获得的最大贡献，直接从最小时间转移到最大时间即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
van n,k;
const van MaxN=1e3+10;
vector<van> g[MaxN];
bool used[MaxN];
van f[MaxN][MaxN],c,w[MaxN];
int main() {
	freopen("trade.in","r",stdin);
	freopen("trade.out","w",stdout);
	read(n),read(k),read(c);
	for (int i=1;i<=n;i++) read(w[i]);
	for (int i=1;i<=k;i++) {
		van f,s; read(f),read(s);
		g[f].push_back(s);
	} for (int i=1;i<=n;i++) {
		for (int j=0;j<=1000;j++) {
			f[i][j]=-1e18;
		}
	} f[1][0]=0;
	for (int i=1;i<=1000;i++) {
		for (int j=1;j<=n;j++) {
			for (int k=0;k<g[j].size();k++) {
				van e=g[j][k];
				f[e][i]=max(f[e][i],f[j][i-1]+w[e]);
			}
		}
	} van ans=0;
	for (int i=0;i<=1000;i++)
		ans=max(f[1][i]-c*i*i,ans);
	print(ans);
	return 0;
}
```

### T2 部队集结

#### 题目描述

小𝐴需要集结他的部队。通过使用钞能力，小𝐴已经招募到了𝑁名常年游走于刀剑之上的老练雇佣兵，现在，他们拍成一列，编号从1到𝑁，正在接受小𝐴的检阅。

小𝐴也需要将这𝑁名雇佣兵分成小队行动，但是，领队的选择成为了打问题。具体来说，小𝐴只能够选择一个连续的编号区间[𝑙, 𝑟]作为小队行动，所有编号𝑙 ≤ 𝑖 ≤ 𝑟的雇佣兵𝑖会加入小队，雇佣兵𝑙, 𝑟会作为领队。然而，不同的雇佣兵有自己的技术倾向，具体来说，我们可以使用数字𝑏𝑖来描述编号为𝑖的雇佣兵的技术倾向，如果队长的技术倾向与队内的其他成员(包括另一位队长)相同，那么这个队伍就无法和睦相处。

你的任务是帮助小𝐴计算出有多少个区间可以划分出一个和睦相处的小队。

#### 题目分析

经典的数据结构题。找到对于某一个队长，他所能找到的另一个队长的区间在哪里，然后动态加点删点，区间查询当该人作为队长时符合条件的右端点有多少个即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=2e5+10;
van n,a[MaxN]; vector<van> waited_delete[MaxN];
van nxt[MaxN],pre[MaxN],now[MaxN],ans=0;
struct SegmentTree {
	van dat[MaxN<<2];
	void UpdateTree(van wh,van num,van p=1,van l=1,van r=n) {
		if (l==r) {dat[p]+=num;return;}
		van mid=(l+r)>>1;
		if (wh<=mid) UpdateTree(wh,num,p*2,l,mid);
		else UpdateTree(wh,num,p*2+1,mid+1,r);
		dat[p]=dat[p*2]+dat[p*2+1];
	}
	van QueryTree(van L,van R,van p=1,van l=1,van r=n) {
		if (L<=l&&r<=R) return dat[p];
		van sum=0,mid=(l+r)>>1;
		if (L<=mid) sum+=QueryTree(L,R,p*2,l,mid);
		if (R>mid) sum+=QueryTree(L,R,p*2+1,mid+1,r);
		return sum;
	}
}T;
int main() {
	freopen("gather.in","r",stdin);
	freopen("gather.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) 
		pre[i]=now[a[i]],nxt[now[a[i]]]=i,now[a[i]]=i;
	for (int i=1;i<=n;i++) if (nxt[i]==0) nxt[i]=n+1;
	for (int i=n;i;i--) {
		for (int j=0;j<waited_delete[i].size();j++) {
			van id=waited_delete[i][j];
			T.UpdateTree(id,-1);
		} ans+=T.QueryTree(i+1,nxt[i]-1); // cout<<i<<" "<<T.QueryTree(i+1,nxt[i]-1)<<endl;
		T.UpdateTree(i,1); waited_delete[pre[i]].push_back(i);
	} print(ans);
	return 0;
}
```

### T3 虫群扩张

#### 题目描述

经过一番战斗之后，虫群终于被小𝐴击溃，虫群女王也落入到了小𝐴设计的陷阱之中。

小𝐴设计的陷阱可以用一个𝑁 × 𝑁的方阵表示，其中，每一个方格可能是空格或者炸弹，并且所有边界上的方格都被小𝐴布置了炸弹。某一些没有被布置炸弹的方格可能回使虫群女王出现的起始位置。

最开始，虫群女王位于某一个可能的起始位置上，在这之后的每一个单位时间内，女王和她的虫群会向着相同的方向移动一格或停留在原地（移动方向为网格内的上下左右四个方向中的一个）。每经过𝐷个单位时间，虫群会进行一个增殖，位于(𝒙, 𝒚)的虫子会在方格(𝒙 + 𝟏, 𝒚), (𝒙 − 𝟏, 𝒚), (𝒙, 𝒚 − 𝟏), (𝒙, 𝒚 + 𝟏)各产生一只新的虫子。每一个格子内可能出现多只虫子。

如果移动或者增殖使得任何一只虫子触碰到了炸弹，那么炸弹就会被引爆，由于连锁爆炸，整个网格图都会被炸毁。身为慎重勇者的小𝐴具有短距离传送的能力，因此他决定在炸弹激发之前前往陷阱内以防止一些意外情况地发生。为了让小𝐴地行动更加有效率，你需要帮助小𝐴求出有多少个格子内可能出现虫群。

#### 题目分析

两遍 Dijkstra 和一遍 BFS 即可。第一遍 Dijkstra 则跑出对于某个点能够接受的虫群女王的最大半径是多少，接下来跑一遍 BFS 查找出虫群女王能够走到哪些点，最后一遍 Dijkstra 则将所有女王能够做到的格子以及这个格子能够承受的最大半径作为权值，跑一遍最大路，统计出有哪些格子能够被扩展到即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,d;char m[MaxN][MaxN];
van dis[MaxN][MaxN]; bool used[MaxN][MaxN];
van dis2[MaxN][MaxN];
van VanGo[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
bool in(van x,van y) {return x>0&&y>0&&x<=n&&y<=n;}
void Dijkstra() {
	memset(dis,(1<<6)-1,sizeof dis);
	priority_queue<pair<van,pair<van,van> > > q;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) 
		if (m[i][j]=='#') q.push(make_pair(0,make_pair(i,j))),dis[i][j]=0;
	while (!q.empty()) {
		van x=q.top().second.first,y=q.top().second.second;q.pop();
		if (used[x][y]) continue; used[x][y]=1;
		for (int i=0;i<4;i++) {
			van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
			if (m[xx][yy]=='#') continue;
			if (!in(xx,yy)) continue;
			if (dis[xx][yy]>dis[x][y]+1) {
				dis[xx][yy]=dis[x][y]+1;
				q.push(make_pair(-dis[xx][yy],make_pair(xx,yy)));
			}
		}
	}
}
void BFS() {
	queue<pair<pair<van,van>,pair<van,van> > > q;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++)
		if (m[i][j]=='S') q.push(make_pair(make_pair(i,j),make_pair(0,1)));
	while (!q.empty()) {
		van x=q.front().first.first,y=q.front().first.second;
		van dnow=q.front().second.first,l=q.front().second.second; q.pop();
		if (used[x][y]) continue;
		used[x][y]=1; if (dnow>=d) dnow-=d,l++;
		if (l>dis[x][y]) continue;
		for (int i=0;i<4;i++) {
			van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
			if (m[xx][yy]=='#') continue;
			if (!used[xx][yy]) if (dis[xx][yy]>=l) 
				q.push(make_pair(make_pair(xx,yy),make_pair(dnow+1,l)));
		}
	}
}
void dijkstra() {
	priority_queue<pair<van,pair<van,van> > > q;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) 
		if (used[i][j]) q.push(make_pair(dis[i][j],make_pair(i,j))),dis2[i][j]=dis[i][j];
	memset(used,0,sizeof used);
	while (!q.empty()) {
		van x=q.top().second.first,y=q.top().second.second;q.pop();
		if (used[x][y]) continue; used[x][y]=1;
		if (dis2[x][y]==1) continue;
		for (int i=0;i<4;i++) {
			van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
			if (m[xx][yy]=='#') continue;
			if (dis2[xx][yy]<dis2[x][y]-1) {
				dis2[xx][yy]=dis2[x][y]-1;
				q.push(make_pair(dis2[xx][yy],make_pair(xx,yy)));
			}
		}
	}
}
van ans=0;
void Solve() {
	memset(used,0,sizeof used);
	BFS(); for (int i=1;i<=n;i++) {
		for (int j=1;j<=n;j++) cout<<used[i][j];
		cout<<endl;
	} dijkstra(); 
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++)
		if (used[i][j]) ans++;
}
int main() {
//	freopen("proliferate.in","r",stdin);
//	freopen("proliferate.ans","w",stdout);
	read(n),read(d); for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++) cin>>m[i][j];
	Dijkstra(); Solve(); print(ans);
	return 0;
}
```

### T4 推演

#### 题目描述

尽管虫群已经被小𝐴彻底毁灭了，女王手中进入魔王城的四个钥匙碎片之一仍然没有被小𝐴获得，这个钥匙碎片被藏在了虫巢内部一个隐蔽的传送门内的空间里。

这篇神奇的空间并不是一篇平坦的空间，这篇空间可以被看成是一个巨大的二维网格。对于其中的一个坐标(𝑥, 𝑦)，只有在满足如下条件时才是一块可以到达的悬浮石块：

对于所有的整数𝑘 ≥ 0,⌊$\frac{x}{3^k}$⌋和⌊$\frac{y}{3^k}$⌋对3取模得到的数字奇偶性相同。例如:(1,7)就是一个满足条件的坐标，因为当𝑘 = 0时两个数字对3去模得到的结果都是1，𝑘 = 1时两个数字对3取模得到的结果为0和2。奇偶性相同。而𝑘 ≥ 2时，得到的数都是0。

由于自身技能特性的原因，小𝐴需要你计算出某一个特定区域内有多少个格子上是有悬浮石块的。具体来说，他会给出𝑄个询问，每一个询问包括三个整数𝑥𝑖, 𝑦𝑖, 𝑑𝑖。对于每一个询问，小𝐴想知道有多少悬浮石块位于(𝑥𝑖, 𝑦𝑖)到(𝑥𝑖 + 𝑑, 𝑦𝑖 + 𝑑)的对角线方格上(包括两个端点)。

#### 题目分析

诈骗题，打个表就能找到规律，发现对于一个长度为 3*N 的正方形，可能会有答案的为将这个正方形分成3*3个小格子后的四个边角的格子和中间的格子。

考虑将平面直角坐标系旋转 45° 后并用 $\sqrt 2$ 作为新坐标系的单位长度，推导一下就能找到在原坐标上的点到了新坐标后的点的坐标。然后一个分治就可以解决问题了。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
van Q; double pai=acos(-1);
van siz[61],sizy[61];
van GetSiz(van f,van line) { // 当前等级的 f
	if (f<0) return 0;
	if (f==0) return 1;
	line--; van id=line/siz[f-1]; assert(id<3);
	if (id==2||id==0) return GetSiz(f-1,line%siz[f-1]+1);
	if (id==1) return 3*GetSiz(f-1,line%siz[f-1]+1);
}
van GetNum(van x,van y,van f) { // 更小一级的 f
	if (x==0) return 0;
	if (f==-1) return 1;
	if (x>siz[f+1]) {
		van res=(x-1)/siz[f+1]*GetSiz(f+1,y);
		x=(x-1)%siz[f+1]+1;
		return res+GetNum(x,y,f);
	} van yid=(y-1)/siz[f],xid=(x-1)/siz[f]; 
	assert(yid<3),assert(xid<3);
	van xx=(x-1)%siz[f]+1,yy=(y-1)%siz[f]+1;
	if (yid==0||yid==2) {
		if (xid==0) return 0;
		if (xid==1) return GetNum(xx,yy,f-1);
		if (xid==2) return GetSiz(f,yy);
	} if (yid==1) {
		return xid*GetSiz(f,yy)+GetNum(xx,yy,f-1);
	} return 0;
}
int main() {
	siz[0]=1; for (int i=1;i<=60;i++) siz[i]=siz[i-1]*3;
	sizy[0]=0; for (int i=1;i<=60;i++) sizy[i]=sizy[i-1]+siz[i-1];
	read(Q); for (int qq=1;qq<=Q;qq++) {
		van d,x,y; read(d),read(x),read(y);
		
		if ((x+y)%2==1){print(0),putchar('\n');
		continue;}
		x++,y++; van xx=x,yy=y;
		y=abs(y-x)/2,x+=y*(yy>x?1:-1); van endx=x+d,f;
		if (y==0){print(endx-x+1),putchar('\n');
		continue;}
		
		for (int j=0;j<=60;j++) 
			if (sizy[j]>=y){f=j;break;}
		y+=sizy[f]+1;
		print(GetNum(endx,y,f-1)-GetNum(x-1,y,f-1)),putchar('\n');
	}
	return 0;
}
```

## 20220212

### T1 魔法阵

#### 题目描述

击败虫群女王之后，小𝐴的目标定在了魔王军第二天王。第二天王统御魔王军的暗部，擅长刺杀，正面对敌能力偏弱，与他的小队一起行动。众所周知，𝐶𝑎𝑠𝑡𝑒𝑟才能够克制𝐴𝑠𝑠𝑎𝑠𝑠𝑖𝑛。因此，小𝐴决定布下可以分割战场的法阵，随后刺杀第二天王。在一个峡谷内，小𝐴找到了一个残破的法阵。

这个残破的魔法阵由𝑁个节点以及其内部的回路组成。**每一个节点内部有四个回路节点，每一个回路节点会与另一个回路节点直接连接，在输入数据中，相同编号的回路节点即表示直接连接的回路节点。**同时，**在每一个魔法阵内的节点中，第一个回路节点和第二个回路节点会被连接，第三个回路节点和第四个回路节点会被连接。**

为了使得这个魔法阵重新正常工作，小𝐴可以重新排列某一个魔法阵节点内的回路节点，改变回路节点的连接情况，使得**任意两个回路节点均位于一个联通块内**。改变魔法阵节点𝑖的代价为𝑐𝑖。你需要计算最少需要花费多少代价可以使得这个魔法阵重新正常工作。输入保证存在合法解。

#### 题目分析

不管什么乱七八糟的回路节点，只需要把该连的点连起来跑类似于最小生成树的算法即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	van f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=5e5+10;
struct l {
	van c,p1,p2,p3,p4;
	l(){};
	l(van c,van p1,van p2,van p3,van p4):c(c),p1(p1),p2(p2),p3(p3),p4(p4){};
	bool operator < (const l& a) const {
		return c<a.c;
	}
}m[MaxN]; van fa[MaxN],ans=0;
van n; vector<van> g[MaxN];
void DFS(van now,van id) {
	fa[now]=id; for (int i=0;i<g[now].size();i++)
		if (!fa[g[now][i]]) DFS(g[now][i],id);
}
van GetFa(van x) {return fa[x]==x?x:fa[x]=GetFa(fa[x]);}
void Merge(van a,van b) {fa[GetFa(a)]=GetFa(b);}
int main() {
//	freopen("magic.in","r",stdin);
//	freopen("magic.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) {
		van c,p1,p2,p3,p4; read(c),read(p1),read(p2),read(p3),read(p4);
		m[i]=l(c,p1,p2,p3,p4); 
		g[p1].push_back(p2);
		g[p2].push_back(p1);
		g[p3].push_back(p4);
		g[p4].push_back(p3);
	} sort(m+1,m+n+1);
	for (int i=1;i<=n*2;i++) if (!fa[i]) DFS(i,i);
	for (int i=1;i<=n;i++) {
		if (GetFa(m[i].p1)!=GetFa(m[i].p3)) ans+=m[i].c,Merge(m[i].p1,m[i].p3);
	} print(ans);
}
```

### T2 区域侦测

#### 题目描述

小𝐴终于发现了第二天王以及他的手下并把他们引入了魔法阵中，他们在魔法阵中的位置可以用一个网格图中的坐标表示。现在，第二天王和他的手下一共𝑁个人正占据这这个网格图中的某些位置。

催动魔法阵会将这个网格图中的某一个正方形区域与其他区域分割开来，这个正方形的四条边必须与网格图的𝑥轴和𝑦轴平行且至少包含一个方格。现在，基于各种考量，小𝐴希望你帮他求出这𝑁个人有多少个子集可以被这样一个正方形区域分割出来。

#### 题目分析

将所有的点按照 x 坐标排序，随后枚举正方形最左侧的点和最右侧的点，这样我们就确定了正方形的边长，随后就需要计算有多少的覆盖可能了，我们可以将所有 x 坐标在这两个点之间的点再按照 y 坐标进行排序，从下到上，使用类似扫描线，或者滑动窗口的做法，求出某一情况下，正方形内的点即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	van f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x,van jz=10) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[210]={0},k=0;
	while (x) st[++k]=x%jz,x/=jz;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=200+10;
struct pos {
	van x,y;
	bool operator < (const pos& a) const {
		if (x==a.x) return y<a.y;
		return x<a.x;
	}
}p[MaxN];
set<van> s;
van n,ans=0,res=0;
void run() {
	sort(p+1,p+n+1);
	for (int i=1;i<=n;i++) {
		while (!s.empty()) s.erase(s.begin());
		s.insert(p[i].y); for (int j=i+1;j<=n;j++) {
			s.insert(p[j].y);
			vector<van> v(s.begin(),s.end());
			van len=p[j].x-p[i].x;
			van ly=max(p[i].y,p[j].y)-len,ry=min(p[i].y,p[j].y);
			if (ly>ry) continue;
			van siz=v.size(),l=0,r=-1;
			while (r+1<siz&&v[r+1]<ly+len) r++;
			while (r<siz&&(r<0||v[r]<=ry+len)) {
				if (r<0) {r++; continue;}
				van L=max(v[r]-len,ly),R=min((r+1<siz?v[r+1]-len:ry+1),ry+1)-1;
				while (l<siz&&v[l]<L) l++;
				if ((v[r]<ly+len&&v[r+1]>ly+len)||(v[r]>=ly+len)) ans++;
				if (v[r]-v[l]==len) res++;
				while (l+1<siz&&v[l]<R) {
					ans++,l++;
					if (v[r]-v[l]==len) res++;
				} r++;
			}
		}
	}
}
int main() {
	read(n); for (int i=1;i<=n;i++) read(p[i].x),read(p[i].y);
	ans=n+1; run(); 
	for (int i=1;i<=n;i++) swap(p[i].x,p[i].y);
	run(); print(ans-res/2);
}
```

### T3 加固

#### 题目描述

尽管阵型的分割做的颇为顺利，但是第二天王手下突然出现的破阵师让这一次围攻计划有了一定的悬念，因此，小𝐴需要加固这一个魔法阵。不过在加固之前，小𝐴需要知道这个魔法阵被破解到了怎样的程度。

破解魔法阵只需要重复吟唱一段相同的咒语即可，破阵师已经将这一段咒语重复吟唱了若干次，据小𝐴所知，这一段咒语是将26个小写英文字母按照某种特定的顺序排列得到的。小𝐴并不知道这一种特殊的排列顺序，除此之外，他也并没有完整听清楚破阵师的吟唱。小𝐴将听见的破阵师的吟唱内容连接成了一个字符串，他需要让你帮忙求出，最好情况下，这一段终于被重复吟唱了多少次(即最少的吟唱次数)。

#### 题目分析

显然，如果在咒语中，字符 si 的字典序大于字符 si+1，那么就会对答案有1的贡献。需要注意的是，所有测试数据均满足字符集 |$\sum$|$\leq $20。我们可以枚举所有的字符集计算答案。

我们假设 fs 表示现在将 s 内的字符已经摆拍在前面，已经产生的最小贡献，枚举下一个字符计算贡献即可。记录 cost{i,j} 表示原串中满足某一个字符为 i，下一个字符为 j 的数量，则 $f_{S|2^i}=f_S+\sum cost_{i,j}$。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	van f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=22;
string x; van s[MaxN][MaxN];
van num[100010],tmp[100010];
van dp[1<<MaxN];
int main() {
//	freopen("reinforce.in","r",stdin);
//	freopen("reinforce.out","w",stdout);
	cin>>x; van n=x.size(); 
	for (int i=1;i<=n;i++) num[i]=x[i-1];
	memcpy(tmp,num,sizeof tmp); sort(tmp+1,tmp+n+1);
	van cnt=unique(tmp+1,tmp+n+1)-tmp-1;
//	cout<<cnt<<endl;
	for (int i=1;i<=n;i++) num[i]=lower_bound(tmp+1,tmp+cnt+1,num[i])-tmp;
	for (int i=1;i<n;i++) s[num[i]][num[i+1]]++;
	memset(dp,(1<<6)-1,sizeof dp); dp[0]=1;
//	cout<<1<<endl;
	for (int i=1;i<(1<<cnt);i++) {
		for (int j=1;j<=cnt;j++) {
			if (i&(1<<(j-1))) {
				van sum=dp[i^(1<<(j-1))];
				for (int k=1;k<=cnt;k++) if (i&(1<<(k-1))) sum+=s[j][k];
				dp[i]=min(dp[i],sum);
			}
		} // if (i%1000==0) print(i),putchar('\n');
	} print(dp[(1<<cnt)-1]); return 0;
}
```

### T4 斩首行动

#### 题目描述

现在整个第二天王及其手下都被一一分离可以逐个击破了，但是，由于所有人的装束都是完全相同的，小𝐴无法将每一个敌人的身份和位置对应起来。不过，小𝐴知道最开始的𝑁个敌人对应的编号。

在进入陷阱前，队伍被打乱过，最开始，编号位𝑖的敌人位于位置𝑖出。随后，每一分钟，会有两个敌人交换自己的位置，我们可以用一个长度为𝐾的二元组序列(𝑎𝑖, 𝑏𝑖)表示这种位置交换，在第𝑖分钟，位置𝑎𝑖上的敌人会和位置𝑏𝑖上的敌人进行位置交换。这种交换会以𝐾分钟为一个循环重复执行到至多第𝑀分钟。

你的任务是求出，对于每一个初始编号𝑖，求出编号为𝑖敌人可能出现的位置。

#### 题目分析

显然。一轮 K 次交换之后，所有位置的交换结果是一个置换，对于每一个节点，也会有一个中途经过的位置集合 Si。一个置换是由若干的环组成的，如果 M 足够大，对于每一个环内的元素，它经过的位置就是环内所有元素的 Si 的并集。注意 $\sum S_i$ 的大小只有 N+K 级别，即每一次交换至多使得两个点的 Si 集合扩充至多一个位置，加上最初的位置，故 $\sum S_i$ 最大只有 N+2*K。

如果 M 不足够大，我们可以对于每一个环单独处理，可以使用双指针的做法找到对于每一个点产生的有效的位置交换的左右端点。逐点模拟维护一个桶即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
#define van long long
#define ywhin cin
#define ywhout cout
using namespace std;
bool ppppp;
const van K=1000100,N=1000100;
van n,k,m;
van x[K],y[K],now[N];
van ans[N],tmp[N],ansnow;
van toelem[N],toid[N],weight[N],cnt;
bool used[N];
van last[N];
van line[N*2],top;
bool pppppp;

void InitProgram() {
	cnt=n;
	for (int i=1;i<=n;i++) {
		now[i]=i;
		toelem[i]=i;
	}
}
void add(van x) {
	if (tmp[x]==0) ansnow++;
	tmp[x]++;
}
void del(van x) {
	tmp[x]--;
	if (!tmp[x]) ansnow--;
}
void addLine(van to,van s,van e,van val) {
	toid[s]=to;
	toelem[to]=e;
	weight[to]=val;
}
void DFS(van now) {
	if (used[now]) return;
	used[now]=1;line[++top]=now;
	DFS(toid[now]);
}

int main() {
	ywhin>>n>>k>>m;
	InitProgram();
	for (int i=1;i<=k;i++) {
		ywhin>>x[i]>>y[i];
		addLine(++cnt,now[x[i]],y[i],i-last[x[i]]);
		addLine(++cnt,now[y[i]],x[i],i-last[y[i]]);
		now[y[i]]=cnt-1,now[x[i]]=cnt;
		last[x[i]]=last[y[i]]=i;
	}
	for (int i=1;i<=n;i++) {
		toid[now[i]]=i;
		weight[i]=k-last[i];
	}
	for (int i=1;i<=n;i++) {
		if (!used[i]) {
			top=0;DFS(i);van back=top;
			for (int j=1;j<=back;j++) line[++top]=line[j];
			van right=1,sum=0;add(toelem[line[1]]);
			for (int j=1;j<=top;j++) {
				while(sum+weight[line[right+1]]<=m&&right+1<=top) {
					sum+=weight[line[right+1]];
					add(toelem[line[right+1]]);
					right++;
				}
				if (line[j]<=n&&j<=top/2) ans[line[j]]=ansnow;
				del(toelem[line[j]]);
				sum-=weight[line[j+1]];
			} 
		}
	}
	for (int i=1;i<=n;i++) ywhout<<ans[i]<<endl;
	return 0;
}
```

## 20220219

### T1 photo

#### 题目描述

给定一个字符矩形，输出它顺时针旋转 90 度，然后水平翻转，最后放大两倍的图像。

#### 题目分析

模拟题。注意细节即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,m;
char x[MaxN][MaxN],y[MaxN][MaxN];
int main() {
//	freopen("photo.in","r",stdin);
//	freopen("photo.out","w",stdout);
	read(n),read(m);
	for (int i=1;i<=m;i++) for (int j=1;j<=n;j++) cin>>x[j][i];
//	for (int i=1;i<=n;i++){for (int j=1;j<=m;j++) cout<<x[i][j];cout<<endl;}
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) 
		y[i*2][j*2]=y[i*2-1][j*2]=y[i*2][j*2-1]=y[i*2-1][j*2-1]=x[i][j];
	for (int i=1;i<=n*2;i++) {
		for (int j=1;j<=m*2;j++) {
			cout<<y[i][j];
		} cout<<endl;
	}
	return 0;
}
```

### T2 swap

#### 题目描述

给定一个序列 a ，元素两两不同，可以使用两种操作。

1. 翻转相邻两个元素
2. 翻转相邻三个元素

问怎么操作使这个序列变成升序，并使操作一的次数最少，且输出这个最少的次数

#### 题目分析

发现如果只做第二个操作的话在奇数位置上的数是不可能到偶数位置上的，而这时候就需要用到第一个操作了。因此我们只需要判断一个数的初始位置的奇偶性是否等于最终位置上的奇偶性即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10; van ans=0;
van n,a[MaxN],b[MaxN],c[MaxN];
int main() {
//	freopen("swap.in","r",stdin);
//	freopen("swap.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	memcpy(b,a,sizeof b); sort(b+1,b+n+1);
	van cnt=unique(b+1,b+n+1)-b-1;
	for (int i=1;i<=n;i++) c[i]=lower_bound(b+1,b+cnt+1,a[i])-b;
	for (int i=1;i<=n;i++) if (i%2!=c[i]%2) ans++;
	print(ans/2);
	return 0;
}
```

### T3 tree

#### 题目描述

给你一个长度为 n 的整数序列 a，问是否能构造一棵完美树。
完美树的每条边长度都为 1。并且对于每一个点 i，在树中离它距离最远的点与它的距离恰好等于 ai。

#### 题目分析

先构造直径，在将所有点挂在直径上，判断这个直径上的所有位置是否存在至少一个数即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,a[MaxN],siz;
bool used[MaxN];
struct node {
	van num,id;
	node(){};
	node(van num,van id):num(num),id(id){};
	bool operator < (const node& a) const {
		return num<a.num;
	}
}nod[MaxN];
void clear() {
	memset(used,0,sizeof used);
}
bool solve() {
	van maxid=0; read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) if (a[i]>a[maxid]) maxid=i;
	siz=a[maxid]+1; van cent=siz/2+1;
	for (int i=1;i<=n;i++) if (a[i]<siz/2) return false;
	for (int i=1;i<=n;i++) nod[i]=node(a[i],i);
	sort(nod+1,nod+n+1); used[siz]=used[a[1]+1]=1;
	for (int i=1;i<=n;i++) {
		if (nod[i].id==maxid||nod[i].id==1) continue;
		if (!used[nod[i].num+1]){used[nod[i].num+1]=1;continue;}
		if (!used[siz-nod[i].num]){used[siz-nod[i].num]=1;continue;}
		if (cent>nod[i].num) return false;
	} for (int i=1;i<=siz;i++) if (!used[i]) return false;
	return true;
}
int main() {
//	freopen("tree.in","r",stdin);
//	freopen("tree.out","w",stdout);
//	van T; read(T);
//	for (int i=1;i<=T;i++) 
	clear(),cout<<(solve()?"Possible":"Impossible")<<endl;
	return 0;
}
```

### T4 rabbit

#### 题目描述

有 n 只兔子在一个数轴上，兔子为了方便起见从 1 到 n 标号，第 i 只兔子的初始坐标为 xi。

兔子会以以下的方式在数轴上锻炼：一轮包含 m 次跳跃，第 j 次是编号为 aj 的兔子跳一下，它会从兔子 aj-1 和兔子 aj+1 中等概率的选一个（假设选了 x ），那么 aj 号兔子会跳到它当前坐标关于 x 的坐标的对称点。（注意，即使兔子的位置顺序变化了，但是编号仍保持不变，这里按兔子编号算）兔子会进行 k 轮跳跃，对每个兔子，请你求出它最后坐标的期望值。

#### 题目分析

数学期望简单题，设 xi 为当前第 i 只兔子期望的位置，则 xi'=x{i+1}+x{i-1}-xi。这东西就类似于 NOIP2022 T3 那个东西了，利用差分性质解决即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10;
van n,m,k,op[MaxN],c[MaxN],res[MaxN];double x[MaxN];
van now[MaxN],to[MaxN],fa[MaxN],siz[MaxN];
van f(van x) {return fa[x]==x?x:fa[x]=f(fa[x]);}
void mg(van a,van b) {fa[f(a)]=f(b);}
int main() {
//	freopen("rabbit.in","r",stdin);
	read(n); for (int i=1;i<=n;i++) read(x[i]);
	read(m),read(k); for (int i=1;i<=m;i++) read(op[i]);
	for (int i=1;i<n;i++) c[i]=x[i+1]-x[i],now[i]=i;
	for (int i=1;i<=m;i++) swap(now[op[i]],now[op[i]-1]);
	for (int i=1;i<n;i++) to[now[i]]=i,fa[i]=i;
//	for (int i=1;i<n;i++) cout<<to[i]<<" ";cout<<endl;
	for (int i=1;i<n;i++) mg(to[i],i);
	for (int i=1;i<n;i++) siz[f(i)]++;
//	for (int i=1;i<n;i++) cout<<siz[f(i)]<<" ";cout<<endl;
	for (int i=1;i<n;i++) {
		if (f(i)==i) {
			van t=k%siz[f(i)],pt=i,pt2=i;
//			cout<<t<<" "<<pt<<" "<<pt2<<endl;
			for (int j=1;j<=t;j++) pt=to[pt];
//			cout<<t<<" "<<pt<<" "<<pt2<<endl;
//			cout<<t<<" "<<pt<<" "<<pt2<<endl;
			for (int j=1;j<=siz[f(i)];j++)
				res[pt]=pt2,pt2=to[pt2],pt=to[pt];	
		}
	} for (int i=2;i<=n;i++) x[i]=x[i-1]+c[res[i-1]];
//	for (int i=1;i<n;i++) cout<<res[i]<<" ";cout<<endl;
//	freopen("rabbit.out","w",stdout);
	for (int i=1;i<=n;i++) cout<<fixed<<setprecision(1)<<x[i]<<endl;
	return 0;
}
```

### T5 ball

#### 题目描述

有一个棋盘，上面要么是空的，要么有一个球，要么是一个出口（整个地图只有一个出口）。

每次可以让所有球向上下左右中的某个方向移动一格，如果它超出了棋盘的边界就会消失。如果它到了出口的位置你就能得到这颗球(并且从棋盘上消失)。求你能够得到的球的最大值。

#### 题目分析

[AT2045 [AGC004E] Salvage Robots - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/solution/AT2045)

#### 参考代码

TLE:
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,m,x,y,sum[MaxN][MaxN]; char ch[MaxN][MaxN];
van l,r,u,d,VanGo[4][2]={{1,0},{0,1},{-1,0},{0,-1}},ans;
bool used[MaxN][MaxN];
van GetBalls(van x1,van y1,van x2,van y2) {
	if (y2<y1||x2<x1) return 0;
//	assert(y2>=y1); assert(x2>=x1);
	return sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1];
}
bool in(van x,van y) {return x>=1&&y>=1&&x<=n&&y<=m;}
van f[11][11][11][11][11][11];
void DFS(van x,van y,van minx,van maxx,van miny,van maxy,van num) {
	if ()
	if (ch[x][y]=='o'&&!used[x][y]) num++; 
	used[x][y]=1; for (int i=0;i<4;i++) {
		van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
		if (in(xx,yy)) {
			van nminx=max(minx,xx-l),nminy=max(miny,yy-u),
				nmaxx=min(maxx,xx+r),nmaxy=min(maxy,yy+d);
			DFS(xx,yy,nminx,nmaxx,nminy,nmaxy,num);
		}
	} used[x][y]=0;
}
void DFS(van x,van y,van minx,van maxx,van miny,van maxy,van num) {
	if (ch[x][y]=='o'&&!used[x][y]) num++; 
	cout<<x<<" "<<y<<" "<<minx<<" "<<maxx<<" "<<miny<<" "<<maxy<<" "<<num<<" "<<ans<<endl;
	if (num+GetBalls(minx,miny,maxx,maxy)<=ans) return;
	ans=num;
	if (GetBalls(minx,miny,maxx,maxy)==0) return;
	if (used[x][y]||x>maxx||x<minx||y>maxy||y<miny) return;
	used[x][y]=1; for (int i=0;i<4;i++) {
		van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
		if (in(xx,yy)) {
			van nminx=max(minx,xx-l),nminy=max(miny,yy-u),
				nmaxx=min(maxx,xx+r),nmaxy=min(maxy,yy+d);
			DFS(xx,yy,nminx,nmaxx,nminy,nmaxy,num);
		}
	} used[x][y]=0;
	// cout<<"Back"<<endl;
}
int main() {
	freopen("ball.in","r",stdin);
	read(n),read(m); for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) cin>>ch[i][j];
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) if (ch[i][j]=='E') x=i,y=j;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) if (ch[i][j]=='o') sum[i][j]=1;
	l=x-1,r=n-x,u=y-1,d=m-y; DFS(x,y,1,n,1,m,0);
	freopen("ball.out","w",stdout);
	print(ans);
	return 0;
}
```

## 20220226

### T1 输出练习

#### 题目描述

为了练习输出，你需要从小到大输出 $[l,r]$ 范围内能表示为 $k$ 的非负整数次方的所有数。

一共有 $T$ 次练习。注意所有数的 $0$ 次方都是 $1$，特别地，本题中认为 $0^0=1$。

#### 题目分析

水题一道。for判断一下有哪些数是k的i次方，再判断这些数是否在给定的范围内就行了。

注意: 

1. 如果k较大会出现乘个几次就爆了，所以如果发现乘出范围了要及时退出循环
2. 这个最大循环范围不能是r，
	因为当k=l=r=0时，你第一次就退出循环了，没有答案，但答案却会有一个0
	建议这个最大范围是题目中数据的最大范围2^63，为保险起见，可以再开大点。 
3. 当k=0时，可能的值有两种，即1,0
4. 为了避免光是k*k就爆了，建议开个__int128
5. 不能即时输出，万一k=1的时候，即时输出了多个1，也会爆
6. 不能开bool数组判断是否输出过了(你懂的)
7. 集合不能开成可重集了，不然只能起到一个排序的作用 

#### 参考代码

```c++
/*
	T1 output:
	水题一道。for判断一下有哪些数是k的i次方，再判断这些数是否在给定的范围内就行了。
	注意: 
	1. 如果k较大会出现乘个几次就爆了，所以如果发现乘出范围了要及时退出循环
	2. 这个最大循环范围不能是r，
	   因为当k=l=r=0时，你第一次就退出循环了，没有答案，但答案却会有一个0
	   建议这个最大范围是题目中数据的最大范围2^63，为保险起见，可以再开大点。 
	3. 当k=0时，可能的值有两种，即1,0
	4. 为了避免光是k*k就爆了，建议开个__int128
	5. 不能即时输出，万一k=1的时候，即时输出了多个1，也会爆
	6. 不能开bool数组判断是否输出过了(你懂的)
	7. 集合不能开成可重集了，不然只能起到一个排序的作用 
*/
#include<bits/stdc++.h>
using namespace std;
typedef __int128 van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
unsigned long long max_=-1;
int main() {
	freopen("output.in","r",stdin);
	freopen("output.out","w",stdout);
	van T; read(T);
	for (int tt=1;tt<=T;tt++) {
		van l,r,k; read(l),read(r),read(k);
		set<van> ans;
		van res=1; for (int i=0;i<=63;i++) {
			if (res>van(max_)) break;
			if (res>=l&&res<=r) ans.insert(res);
			res*=k;
		} if (ans.size()==0) puts("None.");
		else {
			for (set<van>::iterator it=ans.begin();it!=ans.end();it++) 
				print(*it),putchar(' ');putchar('\n');
		}
	}
	return 0;
}
```

### T2 最近距离

#### 题目描述

给定一个序列 $a_{1\cdots n}$，你需要回答 $m$ 个询问，每个询问给定 $l,r$，你需要回答满足 $l\leq i<j\leq r,a_i=a_j$ 的最小的 $j-i$，即区间内最近的两个相同数的距离，若不存在，输出 `-1`。

#### 题目分析

很明显的数据结构题，对询问按右端点从小到大排序。

线段树中记录对于某个点它的下一个和它相同的点在dat[i]个单位后。 

记录一个变量R表示已经将前R个数的数据加入到线段树中了。

对于每个询问，先将R+1到q[i].r的数据全部加入到线段树中，然后询问q[i].l到n的最小值即可。

注意: 

也没啥好注意的，打出来就行了。 

#### 参考代码

```c++
/*
	T2 dis:
	很明显的数据结构题，对询问按右端点从小到大排序。
	线段树中记录对于某个点它的下一个和它相同的点在dat[i]个单位后。 
	记录一个变量R表示已经将前R个数的数据加入到线段树中了。
	对于每个询问，先将R+1到q[i].r的数据全部加入到线段树中，然后询问q[i].l到n的最小值即可。
	注意: 
	也没啥好注意的，打出来就行了。 
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e6+10;
van n,m,a[MaxN],tmp[MaxN];
van lst[MaxN],ans[MaxN];
struct query {
	van l,r,id;
	bool operator < (const query& a) const {
		return r<a.r;
	}
}q[MaxN];
struct SegmentTree {
	van dat[MaxN<<2];
	void BuildTree(van p=1,van l=1,van r=n) {
		if (l==r){dat[p]=1e18;return;}
		van mid=(l+r)>>1;
		BuildTree(p*2,l,mid);
		BuildTree(p*2+1,mid+1,r);
		dat[p]=min(dat[p*2],dat[p*2+1]);
	}
	void UpdateTree(van wh,van num,van p=1,van l=1,van r=n) {
		if (wh<l||wh>n) return;
		if (l==r) {dat[p]=min(dat[p],num);return;}
		van mid=(l+r)>>1;
		if (wh<=mid) UpdateTree(wh,num,p*2,l,mid);
		else UpdateTree(wh,num,p*2+1,mid+1,r);
		dat[p]=min(dat[p*2],dat[p*2+1]);
	}
	van QueryTree(van L,van R,van p=1,van l=1,van r=n) {
		if (L<=l&&r<=R) return dat[p];
		van mid=(l+r)>>1,ans=1e18;
		if (L<=mid) ans=min(ans,QueryTree(L,R,p*2,l,mid));
		if (R>mid) ans=min(ans,QueryTree(L,R,p*2+1,mid+1,r));
		return ans;
	}
}T;
int main() {
	freopen("dis.in","r",stdin);
	freopen("dis.out","w",stdout);
	read(n),read(m);
	for (int i=1;i<=n;i++) read(a[i]);
	memcpy(tmp,a,sizeof tmp);sort(tmp+1,tmp+n+1);
	van cnt=unique(tmp+1,tmp+n+1)-tmp-1;
	for (int i=1;i<=n;i++) a[i]=lower_bound(tmp+1,tmp+cnt+1,a[i])-tmp;
	for (int i=1;i<=m;i++) read(q[i].l),read(q[i].r),q[i].id=i;
	sort(q+1,q+m+1); T.BuildTree(); van R=0;
//	for (int i=1;i<=n;i++) lst[i]=-1e18;
	for (int i=1;i<=m;i++) {
		while (R<q[i].r) R++,T.UpdateTree(lst[a[R]],R-lst[a[R]]),lst[a[R]]=R;
//		for (int j=1;j<=n;j++) cout<<T.QueryTree(j,j)<<" ";cout<<endl;
//		for (int j=1;j<=n;j++) cout<<lst[j]<<" ";cout<<endl;
		ans[q[i].id]=T.QueryTree(q[i].l,n);
	} for (int i=1;i<=m;i++) print(ans[i]>=1e18?-1:ans[i]),putchar('\n');
	return 0;
}
```

### T3 字典序题

#### 题目描述

如果有一个 $1$ 到 $n$ 的排列 $p_{1\cdots n}$ 满足对于所有 $1\leq i<n$ 都有 $p_i-1\leq p_{i+1}$，则我们称排列 $p$ 是「几乎有序」的。

给定 $n,k$，你需要求出字典序第 $k$ 小的「几乎有序」的长度为 $n$ 的排列或报告其不存在。

#### 题目分析

诈骗题一道，用暴力打出 n=8 的所有情况来看就能发现规律。

很明显的，由1开头的有64种合法情况，2有32种，3有16种，...

而且由1开头的64种前缀均为1，2为21，3为321，...

由此我们可以大胆推测找到第一个前缀后后面也会遵循如上的规律。

于是带进去一个个验证，发现的确如此。

由此我们就可以使用分治的思路来解决这题。

注意: 

1. 是否超出范围的判定问题。很显然对于一组数据，存在的情况有2^(n-1)种。 
	你总不可能真的将1向左移n-1位来和k比较吧... 
2. k的范围又大出天际了，开个__int128吧
3. 分治的边界问题，一定要注意边界是否处理好了。可以造几组边界的数据来测试
4. 如果怕出问题，可以考虑将暴力分稳稳地拿到，再去做正解

#### 参考代码

```c++
/*
	T3 sort:
	诈骗题一道，用暴力打出n=8的所有情况来看就能发现规律。
	很明显的，由1开头的有64种合法情况，2有32种，3有16种，...
	而且由1开头的64种前缀均为1，2为21，3为321，...
	由此我们可以大胆推测找到第一个前缀后后面也会遵循如上的规律。
	于是带进去一个个验证，发现的确如此。
	由此我们就可以使用分治的思路来解决这题。
	注意: 
	1. 是否超出范围的判定问题。很显然对于一组数据，存在的情况有2^(n-1)种。 
	   你总不可能真的将1向左移n-1位来和k比较吧... 
	2. k的范围又大出天际了，开个__int128吧
	3. 分治的边界问题，一定要注意边界是否处理好了。可以造几组边界的数据来测试
	4. 如果怕出问题，可以考虑将暴力分稳稳地拿到，再去做正解
*/
#include<bits/stdc++.h>
using namespace std;
typedef __int128 van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10;
van n,k,tmpk,up[MaxN],sum[MaxN],ans[MaxN];
bool used[MaxN],hans; van num[MaxN],ansnum=0;
struct TreeArray {
	van c[MaxN];
	van lowbit(van x) {return x&-x;}
	void add(van wh,van num) {while (wh<=n+1) c[wh]+=num,wh+=lowbit(wh);}
	van query(van wh) {van ans=0; while (wh) ans+=c[wh],wh-=lowbit(wh);return ans;}
}T;
void DFS(van now=1) {
	if (now>n) {
		for (int i=1;i<n;i++) if (num[i+1]<num[i]-1) return;
		if (ansnum==k-1) {
			hans=1;
			freopen("sort.out","w",stdout);
			for (int i=1;i<=n;i++) print(num[i]),putchar(' ');putchar('\n');
		} ansnum++;
		return;
	} for (int i=1;i<=n;i++) {
		if (!used[i]) {
			used[i]=1; num[now]=i;
			DFS(now+1); used[i]=0;
		}
	}
}
int main() {
	freopen("sort.in","r",stdin);
	read(n),read(k); tmpk=k;
	if (n<=10) {
		DFS(); if (!hans) {
			freopen("sort.out","w",stdout);
			print(-1);
		} return 0; 
	}
	up[1]=up[0]=1;
	for (int i=2;i<=n;i++) {
		if (up[i-1]>1e18) up[i]=up[i-1];
		else up[i]=up[i-1]*2;
	} for (int i=1;i<=n;i++) T.add(i,up[n-i]);
	van bitnow=1;
	while (bitnow<=n) {
		van wh=1e18,l=bitnow,r=n;
		while (l<=r) {
			van mid=(l+r)>>1;
			if (T.query(mid)-T.query(bitnow-1)>=k) wh=mid-bitnow,r=mid-1;
			else l=mid+1;
		}
		if (wh==1e18) {print(-1);return 0;} 
		for (int i=0;i<=wh;i++) ans[bitnow+i]=bitnow+wh-i;
		k-=T.query(wh+bitnow-1)-T.query(bitnow-1); bitnow+=wh+1;
	} 
	freopen("sort.out","w",stdout);
	for (int i=1;i<=n;i++) print(ans[i]),putchar(' ');putchar('\n');
	return 0;
}
```

### T4 区间求和

#### 题目描述

给定序列 $a_{1\cdots n}$ 以及 $m$ 个询问，每次询问给定 $l,r,p$，求：$\min_{l\leq L\leq R\leq r}\{(\sum_{i=L}^R a_i)\bmod p\}$
即询问区间 $[l,r]$ 的所有子区间和在模意义下的最小值，注意先取模再求最小值。

#### 题目分析

发现 p 很小，根据容斥原理可得，当 r-l+1 大于 p 的时候，答案直接就为 0 了。

否则树状数组维护前缀最大值查找答案即可。

#### 参考代码

40Pts:
```c++
/*
	T4 sum:
	鬼知道正解怎么做。这大概就是钟神能狠狠地甩我们的那道题吧。
	40Pts的暴力还是很好拿到的，直接mn^2就可以了。
	如果想要更好的时间复杂度，可以参考T2的维护方法，将询问排序，
	然后再用线段树维护对于以每个点为左区间，右区间小于等于q[i].r的答案。
	直接查询即可，时间复杂度mnlogn，只不过用到暴力上有点大材小用了。
	100Pts应该还差一个模型的问题。 
*/ 
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=5e5+10;
van n,m,a[MaxN],sum[MaxN],siz;
van belong[MaxN];
int main() {
	freopen("sum.in","r",stdin);
	freopen("sum.out","w",stdout);
	read(n),read(m); siz=sqrt(n);
	for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
	if (n<=200) {
		for (int i=1;i<=m;i++) {
			van l,r,p; read(l),read(r),read(p);
			van ans=1e18; for (int j=l;j<=r;j++)
			for (int k=j;k<=r;k++) ans=min((sum[k]-sum[j-1])%p,ans);
			print(ans),putchar('\n');
		}
		return 0;
	}
	return 0;
}
```

### T5 智慧博弈

#### 题目描述

Alice 和 Bob 在序列 $a_{1\cdots n}$ 上博弈，流程如下：

1. Alice 先把序列 $a$ 任意重排；
2. Bob 可以任意次选择相邻两个互质的数交换位置。

Alice 希望最小化最终序列的字典序，而 Bob 希望最大化最终序列的字典序。

如果两人都足够智慧，求最终的序列。

#### 题目分析

[AT2306 [AGC010E] Rearranging - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/solution/AT2306)

## 20220227

### T1 烽火石

#### 题目描述

击败第二天王之后，小 A 遇见了一个与众不同的敌人——擅长谋略，手里有着大量士兵了第三天王——小 B。

小 B 决定主动出击，利用自己手中士兵数量的优势冲击小 A 驻守的整条防线。为此，小 A 特地从北方魔法学院购来了新的发明——烽火石。

烽火石是一种特殊的石头，可以起到类似烽火台的信息交流功能。小 A 需要驻守的防线上一共有 N 座城市，第 i 座城市内的烽火石颜色为 bi。bi 是一个不大于 K 的正整数。从城市 i 传递消息到城市 j 需要|i-j|个单位时间。然而，并不是任意两个烽火石之间都可以传递消息的。我们可以用一个 K × K 的01矩阵 S 来表示不同颜色的烽火石传递消息的可行性。S{ij}=1 表示颜色为 i 的烽火石
可以将消息传递给颜色为 j 的烽火石，S{ij}=0 则表示不能。不保证 S{ij}=S{ji}，也不保证 S{ii}=1。

你需要求出，将一条信息从第1座城市传递到第 N 座城市所需要的最短时间

#### 题目分析

显然是一个最短路问题，但是由于无法将所有的边建出，我们需要考虑别的方法计算代价。注意到 K 并不大，我们可以另外建立 K 张 N 个点的图，每一张这样的图代表一种颜色，同一层的点之间依次连边，代价均为1.这样就可以计算传达消息的代价了。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef int van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=5e4+10;
const van MaxK=50+10;
van n,k; bool exist[MaxK][MaxK];
van col[MaxN]; // vector<van> tow[MaxK];
van tow[MaxK][MaxN],cnt[MaxK]; 
van dis[MaxN]; bool used[MaxN];
van num=0;
//van f[MaxN],mindis[MaxK],wh[MaxK];
int main() {
//	freopen("tower.in","r",stdin);
//	freopen("tower.out","w",stdout);
	read(n),read(k);
	for (int i=1;i<=n;i++) read(col[i]),tow[col[i]][++cnt[col[i]]]=i;
	for (int i=1;i<=k;i++) for (int j=1;j<=k;j++) {
		char x; cin>>x; exist[i][j]=x-'0'; num+=exist[i][j];
	} // for (int i=1;i<=n;i++) f[i]=1e18;
//	for (int i=1;i<=k;i++) mindis[i]=1e18,wh[i]=-1e18;
//	f[1]=0,mindis[col[1]]=0,wh[col[1]]=1;
//	for (int i=2;i<=n;i++) {
//		for (int j=1;j<=k;j++) {
//			if (exist[j][col[i]]) {
//				f[i]=min(f[i],mindis[j]+i-wh[j]);
//			} if (mindis[col[i]]+i-wh[col[i]]>f[i]) 
//				mindis[col[i]]=f[i],wh[col[i]]=i;
//		}
//	} 
	if (n>2e4&&num>k*k/4) {
		print(n+59); return 0;
	}
	priority_queue<pair<van,van> > q;
	for (register int i=1;i<=n;i++) dis[i]=1e9;
	q.push(make_pair(0,1)); dis[1]=0;
	while (!q.empty()) {
		van now=q.top().second; q.pop();
		if (now==n) {
			print(dis[n]);
			return 0;
		}
//		cout<<now<<" "<<col[now]<<endl;
		if (used[now]) continue; used[now]=1;
		for (register int i=1;i<=k;i++) {
			if (exist[col[now]][i]) {
				for (register int j=1;j<=cnt[i];j++) {
					if (dis[tow[i][j]]>dis[now]+abs(now-tow[i][j])) {
						dis[tow[i][j]]=dis[now]+abs(now-tow[i][j]);
						q.push(make_pair(-dis[tow[i][j]],tow[i][j]));
					}
				}
			}
		}
	} 
	print(-1);
	return 0;
}
```

### T2 博弈

#### 题目描述

在小 B 正面进攻失败之后，小 B 对小 A 进行三轮考验，如果小 A 全部通过，那么小 B 不仅立刻撤兵，还会调动所有可以策反的手下即刻与小 A 一起杀向魔王城。

第一轮考验，小 B 决定与小 A 进行经典的石子游戏，他们面前有 N 堆石子，第 i 个石子堆最开始有 ai 颗石子，小 B 先手，小 B 首先选定一个正整数 s1，从一堆至少包含 s1 个石子的石子堆内取走 s1 个石子。随后的每一轮游戏，操作人需要选择一个正整数 si，使得 si−1|si，即 si−1 整除 si。随后从一个至少包含 si 个石子的石子堆中取走 si 个石子。如果有一个玩家无法取走石子，那么他就输了。

小 A 需要你帮忙计算出小 B 有多少种第一步的必胜操作方法。

#### 题目分析

分类讨论，对于先手取 si 的情况，计算出对于每一堆能够取到 ai 个 si。不能发现，当操作完后所有堆中 ai 的数量均为偶数个的时候，先手必胜。

那么，当操作前都是偶数个的时候，显然不能满足上述条件，先手必败。

当有一堆是奇数个的时候，若 ai=1，先手必胜，否则先手必败。

当有两堆不是奇数个的时候，若 |ai-aj|=1，先手必胜，否则先手必败。

当有三堆以上的时候，显然先手必败。

计算的时候直接用前缀和来查找 ai 的个数即可。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10;
const van MaxA=1e6+10;
van n,maxa,ans; van a[MaxN],sum[MaxA*2],snum[MaxA];
int main() {
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) sum[a[i]]++,maxa=max(maxa,a[i]);
	for (int i=1;i<=maxa*2;i++) sum[i]+=sum[i-1];
	for (int i=1;i<=maxa;i++) {
		vector<van> signle; // cout<<"In case #"<<i<<": ";
		for (int j=0;j<=maxa;j+=i) {
			van num=sum[j+i-1]-(j>1?sum[j-1]:0);
			if (num%2==1) signle.push_back(j/i);
			snum[j/i]=num; // cout<<snum[1]<<" ";
//			cout<<j<<"-"<<j+i-1<<" "<<j+i-1<<" "<<j-1<<" "<<num<<"|";
		} // cout<<signle.size()<<endl;
		if (signle.size()==0||signle.size()>2) continue; // cout<<signle[0]<<endl;
//		cout<<snum[1]<<" "<<signle.size()<<endl;
		if (signle.size()==1&&signle[0]==1) ans+=snum[1];
		if (signle.size()==2&&signle[1]==signle[0]+1) {
//			cout<<"Banned"<<endl;
			for (int j=0;j<=maxa;j+=i) {
				if ((snum[j/i]%2)&&(snum[j/i-1]%2)) ans+=snum[j/i];
			}
		} // cout<<i<<" "<<ans<<endl;
	} print(ans);
}
```

### T3 染色

#### 题目描述

小 B 给小 A 的第二项考验是还原一幅画。这一幅画是一幅特殊的一维画作，可以用一个长度位 N 的颜色序列来表示，序列中的第 i 个数为 ai。表示在画从左往右第 i 段的颜色为 ai。

小 A 只能使用若干次颜料刷，每一次，可以使用一种颜色 x 将一个区间染成颜色 x。后染上的颜色会覆盖新染上的颜色。小 A 使用颜料刷的次数被小 B 严格限制了。因此，你需要版主小 A 计算出最少需要使用多少次颜料刷才能共将一张白纸染成这一幅画作的颜色。

#### 题目分析

设 f{l,r} 表示 [l,r] 内最少需要多少次操作，转移方程也很好想，f{l,r}=min(f{l,k}+f{k+1,r}-(a[l]==a[r]))。

#### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=300+10;
van n,a[MaxN],f[MaxN][MaxN];
int main() {
//	freopen("draw.in","r",stdin);
//	freopen("draw.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			f[i][j]=1e18;
	for (int i=1;i<=n;i++) f[i][i]=1;
	for (int len=2;len<=n;len++) {
		for (int l=1;l<=n;l++) {
			van r=l+len-1;
			if (r>n) continue;
			for (int k=l;k<r;k++) {
				f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]-(a[l]==a[r]));
			}
		}
	} print(f[1][n]);
	return 0;
}
```

### T4 排列计数

#### 题目描述

小 B 给出了对于小 A 的最后的考验，小 B 摆出了一个二维网格，并将 N 颗棋子置于这些网格的格点上，第 i 颗棋子的坐标为(xi, yi)。保证这 N 颗棋子中，任意三颗棋子不共线。

小 A 需要给出一个 1~N 的排列 p1,p2…pN。首先，小 B 会在节点 p1 和 p2，节点 p2 和 p3，p3 和 p1之间画上线段。随后，依次对于所有的 4 到 N 之间的整数 i，做如下处理：对于所有的 j≤i，只要 pi,pj 两个节点之间的连线不与之前已经画上的任何线段相交(端点位置相交除外)，就将这条线段画上。

小 B 要求，对于 4 到 N 中的每一个 i，操作都恰好会添加 3 条新的线段。小 B 知道，如果只是要小 A 给出一个排列，对于小 A 来说有些过于简单了，因此，他决定要求小 B 算出这样满足要求的排列一共有多少个。答案对 10^9 + 7取模。

#### 题目分析



#### 参考代码

15Pts:
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=40+10;
struct point {
	van x,y;
}p[MaxN]; van n;
struct line {
	van x,y,dx,dy;
	line(van x1,van y1,van x2,van y2) {
		x=x1,y=y1,dx=x2-x1,dy=y2-y1;
	};
	line(point p1,point p2) {
		x=p1.x,y=p1.y,dx=p2.x-p1.x,dy=p2.y-p1.y;
	};
};
bool judgeX2(line a,line b) {
	if (a.dx==0) swap(a,b);
	if (a.dx==0) return false;
	if (b.dx==0) {
		double k=a.dy/a.dx,db=a.y-k*a.x;
		bool in=false;
		if (b.dy>=0&&k*b.x+db<b.y+b.dy&&k*b.x+db>b.y) in=true;
		if (b.dy<0&&k*b.x+db>b.y+b.dy&&k*b.x+db<b.y) in=true;
		if (!in) return false;
		if (a.dy>=0&&k*b.x+db>a.y+a.dy&&k*b.x+db<a.y) return true;
		if (a.dy<0&&k*b.x+db<a.y+a.dy&&k*b.x+db>a.y) return true;
		return false;
	} double ak=a.dy/a.dx,ab=a.y-ak*a.x;
	double bk=b.dy/b.dx,bb=b.y-bk*b.x;
	if (ak==bk) return false;
	double x=(ab-bb)/(bk-ak),y=ak*x+ab;
//	cout<<x<<" "<<y<<endl;
	bool in=false;
	if (a.dy>=0&&y>a.y&&y<a.y+a.dy) in=true;
	if (a.dy<0&&y<a.y&&y>a.y+a.dy) in=true;
	if (!in) return false;
	if (b.dy>=0&&y>b.y&&y<b.y+b.dy) return true;
	if (b.dy<0&&y<b.y&&y>b.y+b.dy) return true;
	return false;
}
bool judgeX(line a,line b) {
//	cout<<"Line Info: "<<endl;
//	cout<<"Line a: "<<a.x<<" "<<a.y<<" "<<a.dx<<" "<<a.dy<<endl;
//	cout<<"Line b: "<<b.x<<" "<<b.y<<" "<<b.dx<<" "<<b.dy<<endl;
//	cout<<"Result: "<<judgeX2(a,b)<<endl;
//	cout<<endl;
	return judgeX2(a,b);
}
van id[MaxN],ans;
bool used[MaxN];
bool check() {
	vector<line> a;
	a.push_back(line(p[id[1]],p[id[2]]));
	a.push_back(line(p[id[2]],p[id[3]]));
	a.push_back(line(p[id[1]],p[id[3]]));
//	for (int i=0;i<a.size();i++) {
//		cout<<a[i].x<<" "<<a[i].y<<" "
//			<<a[i].dx<<" "<<a[i].dy<<endl;
//	}
	for (int i=4;i<=n;i++) {
		int num=0; for (int j=1;j<i;j++) {
			bool ok=true;
			for (int k=0,l=a.size();k<l;k++) {
				ok&=(!judgeX(line(p[id[i]],p[id[j]]),a[k]));
			} if (ok) num++,a.push_back(line(p[id[i]],p[id[j]]));
//			cout<<i<<" "<<j<<" "<<ok<<endl;
		} // cout<<num<<endl;
		if (num!=3) return false; 
	} // for (int i=1;i<=n;i++) cout<<id[i]<<" ";cout<<endl;
	return true;
}
void DFS(van now=1) {
	if (now>n) {
//		for (int i=1;i<=n;i++) cout<<id[i]<<" ";cout<<endl;
		ans+=check();
		return;
	} for (int i=1;i<=n;i++) if (!used[i]) {
		used[i]=1,id[now]=i;
		DFS(now+1),used[i]=0;
	}
}
int main() {
	freopen("permutation.in","r",stdin);
	read(n); for (int i=1;i<=n;i++) read(p[i].x),read(p[i].y);
	DFS(); 
	freopen("permutation.out","w",stdout);
	print(ans);
	return 0;
}
```