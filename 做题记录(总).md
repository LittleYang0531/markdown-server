# 做题记录

## 模板记录

```md
## Tx 题目名称

### 题目描述

### 题目分析

### 参考代码
```

## Content

- [COCI2020-2021 #1](#COCI2020-2021 \#1)
	- [T1 Patkice](#T1 Patkice)
	- [T2 Bajka](#T2 Bajka)
- [20220207 重庆育才2022寒假集训 选拔测试试题](#20220207)
	- [T1 社交距离(socdist)](#T1 社交距离)
	- [T2 路径(path)](#T2 路径)
	- [T3 倾斜的线(slope)](#T3 倾斜的线)
	- [T4 符文(runes)](#T4 符文)
	- [T5 购票(tickets)](#T5 购票)
- [20220210 重庆市育才中学2022年 寒假联合模拟 Round 3](#20220210)
	- [T1 商贸(trade)](#T1 商贸)
	- [T2 部队集结(gather)](#T2 部队集结)
	- [T3 虫群扩张(proliferate)](#T3 虫群扩张)
	- [T4 推演(calc)](#T4 推演)
- [20220212 重庆市育才中学2022年 寒假联合模拟 Round 4](#20220212)
	- [T1 魔法阵(magic)](#T1 魔法阵)
	- [T2 区域侦测(detect)](#T2 区域侦测)
	- [T3 加固(reinforce)](#T3 加固)
	- [T4 斩首行动(assassinate)](#T4 斩首行动)
- [20220219 重庆市育才中学2022年 联合模拟](#20220219)
	- [T1 photo](#T1 photo)
	- [T2 swap](#T2 swap)
	- [T3 tree](#T3 tree)
	- [T4 rabbit](#T4 rabbit)
	- [T5 ball](#T5 ball)
- [20220226 重庆市育才中学2022年 联合模拟](#20220226)
	- [T1 输出练习(output)](#T1 输出练习)
	- [T2 最近距离(dis)](#T2 最近距离)
	- [T3 字典序题(sort)](#T3 字典序题)
	- [T4 区间求和(sum)](#T4 区间求和)
	- [T5 智慧博弈(game)](#T5 智慧博弈)
- [20220227 重庆市育才中学2022年 寒假联合模拟 Round 5](#20220227)
	- [T1 烽火石(tower)](#T1 烽火石)
	- [T2 博弈(game)](#T2 博弈)
	- [T3 染色(draw)](#T3 染色)
	- [T4 排列计数(permutation)](#T4 排列计数)
	
## COCI2020-2021 #1

### T1 Patkice

#### 题目描述

不是很久之前，在一个遥远的大陆上，住着三只橡皮鸭。在一个炎热的夏日，躺在沙滩上的鸭子们决定旅行到一座相邻的小岛(用一把老旧的黑色雨伞)。

鸭子们是经验丰富的海洋探险家，在旅行之前，他们会检查当前海洋的海图。在海图上，鸭子们目前居住的岛屿被字符 `o` 标记，鸭子们可以朝东(E)南(S)西(W)北(N)中的任意方向开始他们的旅途。

海洋中的洋流会像四个方向移动，在海图上，向东的洋流被标记为 `>`，向西的洋流被标记为 `<`，向北的洋流被标记为 `^`，向南的洋流被标记为 `v`。当鸭子们位于洋流中的某一个位置时，他们会移动到洋流所指向的下一个位置。这片海洋中的洋流比较特殊，它不会让鸭子们移动到海图之外的地方，同时，洋流也没有形成环路。

平静的海洋在海图中被标记为 `.`。如果洋流带鸭子们到达了平静海域，或者时开始的岛屿，那么他们就无法继续他们的旅途了。他们想要到达的岛在图上被标记为 `x`。

你的任务是帮鸭子们判断它们能否到达目的地。如果可以的话，他们需要选择哪一个方向。

鉴于鸭子们并不喜欢海上漂泊的感觉，如果存在多个可以到达目的地的方向，你需要找到行动距离最短的方向。如果存在行动距离相同的方向，请按照方向的字典序输出字典序最小的方向。

#### 输入描述

第一行包括两个整数 $r$ 和 $s(3\leq r,s\leq 100)$，表示海图的行数和列数。

接下来的 $r$ 行，每一行包含 $s$ 个字符，字符集为 `o<>v^.x`，代表海洋的情况。图中保证只存在唯一的 `o` 和 `x`。保证字符 `o` 不会出现在第一行，第一列，最后一行，最后一列。

#### 输出描述

如果鸭子们无法到达目的小岛，输出 `:(`。

否则，请在第一行输出 `:)`。在第二行，输出它们出发的方向(N表示向北，E表示向东，W表示向西，S表示向南)。

#### 题目分析

加强版:[Patkice II](../COCI2020-2021#4/main.md)。

水题一道，只不过细节有一点小多。首先，现将小鸭子们移动到上下左右四个格子，然后再暴力模拟下鸭子最终会移动到哪个点，并判断其是否为终点。注意：三只小鸭可能会走回起点，如果忽略了起点可能会死循环然后超时。

时间复杂度为 $O(n^2)$。

#### 参考代码

```c++
#include<bits/stdc++.h>
#define van long long
#define N 1010
#define ywhin cin
#define ywhout cout
using namespace std;
van n,m;
char cha[N][N];
van len;char ans;
van DFS(van x,van y)
{
	switch(cha[x][y])
	{
		case '.':return -1e18;break;
		case 'o':return -1e18;break;//注意判断是否会回到起点
		case 'x':return 0;break;
		case '>':return DFS(x,y+1)+1;break;
		case '<':return DFS(x,y-1)+1;break;
		case 'v':return DFS(x+1,y)+1;break;
		case '^':return DFS(x-1,y)+1;break;
	}
}
int main()
{
//	ifstream ywhin("patkice.in");
//	ofstream ywhout("patkice.out");
	ywhin>>n>>m;ans='z',len=1e18;
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) ywhin>>cha[i][j];
	van sx,sy;
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) if (cha[i][j]=='o') sx=i,sy=j;
	van res=DFS(sx,sy+1);
	if (res>=0&&res<=len) ans=(len==res)?min(ans,'E'):'E',len=res;
	res=DFS(sx-1,sy);
	if (res>=0&&res<=len) ans=(len==res)?min(ans,'N'):'N',len=res;
	res=DFS(sx+1,sy);
	if (res>=0&&res<=len) ans=(len==res)?min(ans,'S'):'S',len=res;
	res=DFS(sx,sy-1);//注意移动方向不要写错了
	if (res>=0&&res<=len) ans=(len==res)?min(ans,'W'):'W',len=res;
	if (ans!='z') 
	{
		ywhout<<":)"<<endl;
		ywhout<<ans;
		return 0;
	}
	ywhout<<":(";
	return 0;
}
```

### T2 Bajka

#### 题目描述

​小 $𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 已经对图画书感到厌倦了，于是他决定开始阅读他的第一本童话书。不幸的是，$𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 经常会遇见一些让他感到害怕的词语。为了战胜恐惧，他会玩一个他自己发明的游戏。

​令我们的小主人公感到恐惧的词语是一个长度为 $𝑛$ 的小写字母序列。开始这个游戏时，$𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 会把他的手指放在这个字符序列的一个位置上，随后把这个位置上的字符写到一张纸上。接下来，他会执行下面的两个操作中的某一个，他会进行任意次这样的操作执行。

​1.将手指移动到现在指向的字符的左边一个字符或者右边一个字符(如果存在的话)。同时，$𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 也会把这个新的字符写在原来的最后一个字符后面。

​2.将手指移动到任意一个与现在指向字符相同的字符处。这一行动不会导致任何字母书写。

​移动手指从位置 $𝑥$ 到位置 $𝑦$ 需要花费的时间为 $|𝑥−𝑦|$。

​如果在游戏的最后，$𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 最喜欢的词语会出现在纸上，那么他就会克服他的恐惧。他想要尽快看完这本童话书，因此他希望你可以告诉他，最短需要多少时间，他才能够克服恐惧。

#### 输入描述

输入的第一行包括正整数 $𝑛$ 和 $𝑚(1\leq 𝑛,𝑚\leq 3000)$（原题 $1\leq n,m\leq 300$，在此处只能获得70Pts）。

输入的第二行包括 $𝑛$ 个小写字母，表示 $𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 害怕的单词。

输入的第三行包括 $𝑚$ 个小写字母，表示 $𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 最喜欢的单词。

#### 输出描述

输出 $𝐹𝑎𝑏𝑖𝑗𝑖𝑎𝑛$ 生成最喜欢的单词需要的最短时间，如果无法生成这个单词，那么输出 `−1`。

#### 题目分析

##### 30Pts

硬暴力。直接挨个去搜索就行了。

时间复杂度为 $O(m)$。

##### 70Pts

设 $dp[i][j]$ 为已经找到 $i$ 个字符且当前所在的位置为 $j$ 所需要的最小步数。

预处理某一个字母究竟在哪些地方出现过，然后再 DP 的过程中可以快速查找出下一步究竟可以到达哪一些位置，并且加上二者的位置之差就可以转移到下一个位置了。

由于字符串有可能全部都是一样的，因此可能会导致单个状态转移的时间复杂度为 $O(n)$，因此，

总时间复杂度为 $O(n^3)$，过 COCI 数据是没有问题了。

##### 100Pts

考虑如何降低时间复杂度。

我们可以每次记录到某一个状态时每个符合条件的点的最小步数，然后从左扫一遍，记录到某一个点时的最小步数 $step$，并将符合条件的下一个点的步数赋值为 $step$，再从右向左扫一遍，与从左往右扫一遍获得的答案比较，保留小的，再去寻找下一个状态。

时间复杂度为 $O(n^2)$

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 3010
#define ywhin cin
#define ywhout cout
using namespace std;
van f[N];
vector<van> where['z'+1];
char hate[N],like[N];
int main()
{
	memset(f,(1<<8)-1,sizeof f);
	van n,m;
	ywhin>>n>>m;
	for (int i=1;i<=n;i++) ywhin>>hate[i];
	for (int i=1;i<=m;i++) ywhin>>like[i];
	queue<pair<van,van> > q;
	for (int i=1;i<=n;i++) if (hate[i]==like[1]) q.push(make_pair(i,0));
	for (int i=2;i<=m;i++)
	{
		memset(f,(1<<6)-1,sizeof f);
		while (!q.empty())
		{
			pair<van,van> p=q.front();q.pop();
			van place=p.first,step=p.second;
			if (hate[place-1]==like[i]&&place>1) f[place-1]=min(f[place-1],step+1);
			if (hate[place+1]==like[i]&&place<n) f[place+1]=min(f[place+1],step+1);
		}//将上一轮的结果复制到f数组里
		van minans=1e18,pos=0;
		for (int j=1;j<=n;j++) if (hate[j]==like[i])
		{
			van dis=minans+j-pos;
			if (dis>f[j]) minans=f[j],pos=j;
			else if (dis<f[j]) f[j]=dis;
		}//从左往右扫一遍
		minans=1e18,pos=n+1;
		for (int j=n;j>=1;j--) if (hate[j]==like[i])
		{
			van dis=minans+pos-j;
			if (dis>f[j]) minans=f[j],pos=j;
			else if (dis<f[j]) f[j]=dis;
			if (f[j]<1e18) q.push(make_pair(j,f[j]));
		}//从右往左扫一遍
		if (q.empty())
		{
			ywhout<<-1<<endl;
			return 0;
		}//如果没有符合条件的点就可以输出-1了
	}
	van ans=1e18;
	while (!q.empty())
	{
		pair<van,van> p=q.front();q.pop();
		ans=min(ans,p.second);
	}
	ywhout<<ans;
	return 0;
}
```

## T3 Histogram

#### 题目描述

有一个长度为 $N$ 的3D直方图。第 $i$ 个棱柱的宽度为 1 米，高度为 $a_i$，长度为 $b_i$。换句话说，其主视图(从正面看)是一个长方形序列，第 $i$ 个长方形高为 $a_i$，宽为 1。其俯视图(从上方看)是一个长方形序列，第 $i$ 个长方形高为 $b_i$，宽为 1。

你的任务是找出这个直方图内可以放下的容积最大的棱柱。要求棱柱的棱与直方图的棱平行。

#### 输入描述

输入的第一行包括一个正整数 $N(1\leq N\leq 2\times10^5)$。表示这个直方图的长度。 

接下来的 $n$ 行，第 $i$ 行包括两个正整数 $a_i$ 和 $b_i(1\leq a_i,b_i\leq 10^6)$，含义见题面描述。

#### 输出描述

输入最大内接棱柱的容积。

#### 题目分析

##### 20Pts

爆肝一遍就完事了。枚举区间的 $l$ 节点与区间长度，然后计算答案并且与  $ans$ 比较即可。

时间复杂度为 $O(n^2)$ 。

##### 100Pts

考虑使用分治解决此题。

将区间 $[l,r]$ 分为两部分。不难发现，$a$ 的最小值与 $b$ 的最小值的分布只会有两种情况。即 $a$ 的最小值在左边/右边与 $b$ 的最小值在左边/右边。

分开讨论，当 $a,b$ 的最小值在同一边时，枚举 $a,b$ 的最小值并在另一边查找能走到的最远的地方就行了。

当 $a,b$ 的最小值不在同一边时，设 $c_i=\min(a_{mid},a_{mid-1},...,a_{mid-i}),d_i=\min(b_{mid+1},b_{mid+2},...,b_{mid+i})$，以及 $f_j(i)=-i\times d_j+j\times d_j,i\leq j$。线段树维护 $[l,r]$ 这个区间里所有函数的凸包，最后查询这个线段树的值再乘上 $c_i$ 的值就行了。

另一种同理。

时间复杂度为 $O(n\log_2^2n)$。

#### 参考代码

代码链接:[[DS记录\]P7164 [COCI2020-2021#1] 3D Histogram - command_block 的博客 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/command-block/ds-ji-lu-p7164-coci2020-20211-3d-histogram)

```C++
#include<algorithm>
#include<cstdio>
#include<vector>
#define pb push_back
#define ll long long
#define MaxN 200500
using namespace std;
const int INF=1000000000;
struct Line{
  ll k,b;
  ll get(int x)
  {return k*x+b;}
  bool operator < (const Line &B) const
  {return k<B.k;}
};
bool chk(const Line &A,const Line &B,const Line &C){
  ll x1=A.k-B.k,y1=A.b-B.b
    ,x2=C.k-B.k,y2=C.b-B.b;
  return x1*y2-y1*x2>0; 
}
#define Hull vector<Line>
Line st[MaxN];
void max(const Hull &A,const Hull &B,Hull &C)
{
  merge(A.begin(),A.end(),B.begin(),B.end(),st);
  int n=A.size()+B.size();
  C.clear();
  for (int i=0;i<n;i++){
    while(C.size()>=2&&!chk(C[C.size()-2],C.back(),st[i]))C.pop_back();
    C.pb(st[i]);
  }
}
struct Node{Hull s;int p;};
ll get(Hull &s,int &p,int x){
  while(p+1<s.size()&&s[p+1].get(x)>s[p].get(x))p++;
  return s[p].get(x);
}
struct HullDS
{
  Node a[1<<18|500];
  Line sl[MaxN];
  int tl,tr;
  void build(int l,int r,int u)
  {
    a[u].s.clear();a[u].p=0;
    if (l==r){a[u].s.pb(sl[l]);return ;}
    int mid=(l+r)>>1;
    build(l,mid,u<<1);
    build(mid+1,r,u<<1|1);
    max(a[u<<1].s,a[u<<1|1].s,a[u].s);
  }
  int wfl,wfr,wfx;ll ret;
  void _qry(int l,int r,int u)
  {
    if (wfl<=l&&r<=wfr){
      ret=max(ret,get(a[u].s,a[u].p,wfx));
      return ;
    }int mid=(l+r)>>1;
    if (wfl<=mid)_qry(l,mid,u<<1);
    if (mid<wfr)_qry(mid+1,r,u<<1|1);
  }
  ll qry(int l,int r,int x){
    wfl=l;wfr=r;wfx=x;
    ret=0;_qry(tl,tr,1);
    return ret;
  }
}T0,T1,T01;
struct Data{int x0,x1;}s[MaxN];
int h0[MaxN],h1[MaxN];ll ans;
void solve(int l,int r)
{
  if (l==r)return ;
  int mid=(l+r)>>1;
  solve(l,mid);solve(mid+1,r);
  h1[mid]=h0[mid]=INF;
  T0.tl=T1.tl=T01.tl=mid+1;
  T0.tr=T1.tr=T01.tr=r;
  // (c0+c1)*min(t0,h0)*min(t1,h1)
  for (int i=mid+1;i<=r;i++){
    h0[i]=min(s[i].x0,h0[i-1]);
    h1[i]=min(s[i].x1,h1[i-1]);
    T0.sl[i]=(Line){h0[i],1ll*h0[i]*(i-mid)};
    //(c0+c1)*h0*t1 = t1*(c0*h0+c1*h0)
    T1.sl[i]=(Line){h1[i],1ll*h1[i]*(i-mid)};
    //(c0+c1)*t0*h1 = t0*(c0*h1+c1*h1)
    T01.sl[i]=(Line){1ll*h0[i]*h1[i],1ll*h0[i]*h1[i]*(i-mid)};
    //(c0+c1)*h0*h1 = c0*h0*h1+c1*h0*h1
  }
  T0.build(mid+1,r,1);
  T1.build(mid+1,r,1);
  T01.build(mid+1,r,1);
  for (int i=mid,t0=INF,t1=INF,p0=mid,p1=mid;i>=l;i--){
    t0=min(t0,s[i].x0);
    t1=min(t1,s[i].x1);
    while(p0<r&&h0[p0+1]>=t0)p0++;
    while(p1<r&&h1[p1+1]>=t1)p1++;
    ans=max(ans,1ll*(min(p0,p1)-i+1)*t0*t1);
    if (p0<p1)ans=max(ans,t1*T0.qry(p0+1,p1,mid-i+1));
    if (p1<p0)ans=max(ans,t0*T1.qry(p1+1,p0,mid-i+1));
    if (max(p0,p1)<r)ans=max(ans,T01.qry(max(p0,p1)+1,r,mid-i+1));
  }
}
int n;
int main()
{
  scanf("%d",&n);
  for (int i=1;i<=n;i++){
    scanf("%d%d",&s[i].x0,&s[i].x1);
    ans=max(ans,1ll*s[i].x0*s[i].x1);
  }solve(1,n);
  printf("%lld",ans);
  return 0;
}
```

### T4 Papricice

#### 题目描述

在花园忙碌了一个早上之后。M 先生决定用自己种的干辣椒奖励一下自己。 

M 先生有 $n$ 颗辣椒，这些辣椒由 $n-1$ 条线链接而成。任意两颗辣椒都可以通过若干条线连接起来。简单来说，这 $n$ 颗辣椒和这 $n-1$ 条线连接成了一棵树。 

M 先生今天要吃三顿饭，因此他需要剪断两条线。获得三串小的辣椒。每一顿饭需要使用一串辣椒。

显然，一顿饭不能太辣，因此他会选择一种分割方法，使得**辣椒最多的辣椒串和辣椒最少的辣椒串的数量差距最小。**你的任务就是求出这个最小的差距。

#### 输入描述

输入的第一行包含一个整数 $n(1\leq n\leq 2\times10^5)$，表示辣椒的数量。辣椒从1到 $n$ 编号。 

接下来的 $n-1$ 行，每行包括两个整数 $x$ 和 $y(1\leq x,y\leq n)$。表示由一条连接编号为 $x$ 的辣椒和编号为 $y$ 的辣椒的线。

#### 输出描述

输出一行，一个整数，即最小的最大辣椒串和最小辣椒串的数量差距。

#### 题目分析

##### 50Pts

暴力枚举要删除的那两个点，然后计算这三个部分的点的数量并更新 $ans$ 的值就行了。

时间复杂度为 $O(n^2)$。

##### 100Pts

假设我们已经切掉了点 $x$ 与其父亲节点所形成的的边，现在我们需要查找下一个需要删除的边究竟是哪一条。

分成两种情况考虑：

1. 当另一条边在其祖先节点上，那么我们需要分出的另一个部分的节点数量最好为 $\frac{n-size[x]}{2}$。由于其祖先节点 $y$ 的 $size_y$ 包含了 $x$ 的子树下所有的节点，因此我们只需要找到 $x$ 的祖先节点中子树的节点数最靠近 $\frac{n+size[x]}{2}$ 的一个点并计算当前情况下的最终结果并将其与 $ans$ 比较即可。

2. 当另一条边在已经被访问过的子树上时，我们只需要找到已经访问过的节点中子树的节点数最接近 $\frac{n-size[x]}{2}$ 的一个点并计算当前情况下的最终结果并将其与 $ans$ 比较。

至于如何查找，使用 multiset 自带的 lower_bound 函数即可。

时间复杂度为 $O(n\log_2n )$。

#### 参考代码

```c++
#include<bits/stdc++.h>
#define van long long
#define N 200010
#define ywhin cin
#define ywhout cout
using namespace std;
van n;vector<van> g[N];
bool used[N];van siz[N],ans=1e18;
multiset<van> father,son;
void init(van now)
{
//	cout<<now<<endl;
	used[now]=1,siz[now]=1;van v;
	for (int i=0;i<g[now].size();i++) if (!used[v=g[now][i]]) init(v),siz[now]+=siz[v];
}//计算子树中的节点数
void DFS(van now)
{
	used[now]=1;van v;
	multiset<van>::iterator it;van siz2,last,tmpans;
	if (!father.empty())
	{
		it=father.lower_bound((n-siz[now])/2+siz[now]);
		if (it!=father.end())
		{
			siz2=*it-siz[now];
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
		if (it!=father.begin())
		{
			it--;
			siz2=*it-siz[now];
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
	}//第一种情况
	if (!son.empty())
	{
		it=son.lower_bound((n-siz[now])/2);
		if (it!=son.end())
		{
			siz2=*it;
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
		if (it!=son.begin())
		{
			it--;
			siz2=*it;
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
	}//第二种情况
	if (now!=1) father.insert(siz[now]);//将自己加到祖先集合中
	for (int i=0;i<g[now].size();i++) if (!used[v=g[now][i]]) DFS(v);
	if (now!=1) father.erase(father.find(siz[now]));//将自己移除祖先集合
	if (now!=1) son.insert(siz[now]);//将自己移入已访问的节点的集合
}
int main()
{
	ywhin>>n;
	for (int i=1;i<n;i++)
	{
		van f,s;
		scanf("%lld %lld",&f,&s);
		g[f].push_back(s);
		g[s].push_back(f);
	}//建图
	init(1);
	memset(used,0,sizeof used);
	DFS(1);
	ywhout<<ans<<endl;
	return 0;
}
```

### T5 Tenis

#### 题目描述

​米尔科先生是一个网球的狂热粉丝。不久之后，一个重要的锦标赛就要开始了，这场锦标赛一共有 $n$ 位参赛选手。米尔科先生花费了多年时间研究参赛者们并收集了大量的数据。它将他们在三种不同场地上的实力调查清楚。并按照每一个不同的场地给运动员们进行了一个排序，排序为一的表示在这一场地上，这一运动员是最强的。排序最后的最弱。

​在这次的锦标赛中，每两位选手都会正好交手一次。因此一共会有 $\frac{n(n-1)}{2}$ 场比赛。一场网球赛是不会有平局的，**在这个场地上实力排序更强的选手会获得胜利。**主办方对此心知肚明，因此他们决定将每场比赛安排在胜者水平最高的场地，也就是说排名最靠前的场地上。如果存在两个场地胜者排名相同(例如：运动员 A 和 B 进行比赛，A 在场地 1 上会获胜，B 在场地 2 上会获胜，但是二者在对应的场地上拥有相同的排名)，他们就会选择败方排名最好的场地，如果败方排名相同，那么他们就会选择编号最小的场地。 

​你的任务是算出锦标赛的结果，包括：不同场地上的比赛场数，每一位运动员的获胜次数。

#### 输入描述

​输入的第一行包括一个整数 $n(1\leq n\leq 10^5)$，表示运动员的数量，运动员们从 1 到 $n$ 编号。 

​接下来的 3 行输入，每一行是一个长度为 $n$ 的序列，这个序列是 $1$ ~ $n$ 的一个排列，表示在这个场地上选手的实力排序，第一个输入的编号就是这个场地上实力最强的选手编号，以此类推。

#### 输出描述

​输出的第一行，包括三个整数，分别表示在场地 1,2,3 上举办的比赛的数量。 

​输出的第二行包括 $n$ 个整数，分别表示编号从 1 到 $n$ 的每一位选手的获胜场次。

#### 题目分析

我们将比赛分成两类：第一种是严格的胜利，即赢家的获胜位置严格小于输家的获胜位置。第二种是非严格的胜利，这意味着球员在球场上的获胜位置是相等的。

现在问题转化为在一个 3 列的网格上统计。从左往右扫一遍，对于这一列的每个球员是第一次出现，那么我们统计 $(i+1,n)$ 的答案；否则直接跳过。具体我们要维护 $cnt[8][3]$ 表示在状态 $mask$ 的第 $i$ 行排的最小且球场编号最小的球员的位置。

现在我们计算非严格胜利。枚举 $i$ , $j$ 行 $(i<j)$, 如果 $x$, $y$ 都不等于 0 $(x\not=y)$, 我们可以枚举 $k\in [0,2]$ , 使得在输家位置最靠前的情况下场地编号最小，就可以比较出 $x$ , $y$ 的结果。

常数大概有 $2^3\times 3^2=72$。时间复杂度为 $O(72\times n)$。

#### 参考代码

```C++
#include<bits/stdc++.h>
#define van long long
#define N 100010
#define ywhin cin
#define ywhout cout
using namespace std;
van garbage[3][N],n;
van que[N][3],cnt[8][3];
van ans1[N],ans2[N];
van in[N];
void add(van w,van d)
{
	for(int i=1;i<=7;i++) 
	{
		van min_=-1;
		for (int j=0;j<3;j++) if ((i>>j&1)&&(min_==-1||que[w][j]<que[w][min_])) min_=j;
		cnt[i][min_]+=d;
	}
}//维护cnt
int main()
{
	ywhin>>n;
	for (int i=0;i<3;i++) for (int j=1;j<=n;j++) ywhin>>garbage[i][j];
	for (int i=0;i<3;i++) for (int j=1;j<=n;j++) que[garbage[i][j]][i]=j;
	for (int i=1;i<=n;i++) add(i,1);
	for (int i=1;i<=n;i++) 
	{
		for (int j=0;j<3;j++) 
			if (in[garbage[j][i]]) garbage[j][i]=0;
			else
			{
				add(garbage[j][i],-1);
				for (int k=j;k<3;k++) if (garbage[k][i]==garbage[j][i]) in[garbage[j][i]]|=1<<k;
			}
		for (int j=0;j<3;j++) if (garbage[j][i])
		{
			van haha=garbage[j][i];
			for (int k=0;k<3;k++)
			{
				ans1[k]+=cnt[in[haha]][k];
				ans2[haha]+=cnt[in[haha]][k];
			}
			for (int k=j+1;k<3;k++) if (garbage[k][i])
			{
				van ha=garbage[k][i];
				pair<van,van> min_=make_pair(n+1,n+1);
				for (int l=0;l<3;l++) 
				{
					if (que[haha][l]==i) min_=min(min_,make_pair(que[ha][l],(van)l));
					if (que[ha][l]==i) min_=min(min_,make_pair(que[haha][l],(van)l));
				}
				ans1[min_.second]++;
				ans2[que[haha][min_.second]==i?haha:ha]++;
			}
		}
	}
	ywhout<<ans1[0]<<" "<<ans1[1]<<" "<<ans1[2]<<endl;
	for (int i=1;i<=n;i++) ywhout<<ans2[i]<<" ";
	ywhout<<endl;
	return 0;
}
```

## 20220207 

### T1 社交距离

### 题目描述

一种可怕的新疾病 COVID-19 已开始在世界各地传播。人们试图采取尽可能多的预防措施以保护自己免受感染，其中有一项就是增加人与人之间的“社交距离”。

现在考虑这样的一个问题：在火车站的候车厅有一排狭窄的座位，连续 N 个座位在一条直线上。 这些座位中有一些目前被人占据，有些空着。 在了解了“社交距离”D的重要性之后，后来的人都希望最大化 D，其中 D 是最近的两个被占用的座位之间的距离。 例如，如果座位 3 和 8 是最接近的座位，则 D = 5。

最近有一个新的乘客来了想找位子坐下，他需要确定应该坐哪个以前空置的座位，以使 D 的最终值仍尽可能大。注意：已经坐下来的乘客不能动。

### 题目分析

~~学过数组的人都会做。~~

主要是注意细节问题，代码本身是没有问题的，但是 std 还是出了点问题的。

### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
char state[MaxN];van max_=-1e18,min_=1e18;
van ans=0;
int main() {
	freopen("socdist.in","r",stdin);
	freopen("socdist.out","w",stdout);
	van n;cin>>n; van lst=-1,st=-1;
	for (int i=1;i<=n;i++) cin>>state[i];
	for (int i=1;i<=n;i++) {
		if (state[i]=='1') {
			if (lst==-1){lst=i;st=i;continue;}
			max_=max(i-lst,max_);
			min_=min(min_,i-lst);
			lst=i;
		}
	} ans=max(min(min_,n-lst),min(min_,st-1));
	ans=max(ans,min(min_,max_/2)); print(ans);
	return 0;
}

```

### T2 路径

### 题目描述

给出一棵n个节点的树，节点编号为1~n（根节点编号为1）。对于每一个叶子节点，输出从根到叶子的路径。

注意：按照路径的字典序从小到大输出。

### 题目分析

普普通通的 DFS，只不过跑之前对于每个非叶节点将自己的儿子按序号从小到大排个序就可以了。

### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
van n; vector<van> g[MaxN];
van st[MaxN],top=-1;
void DFS(van now=1) {
	st[++top]=now;
	if (g[now].size()==0) {
		for (int i=0;i<=top;i++) 
			print(st[i]),putchar(' ');
		putchar('\n'); top--;
		return;
	} for (int i=0;i<g[now].size();i++)
		DFS(g[now][i]); top--;
}
int main() {
	freopen("path.in","r",stdin);
	freopen("path.out","w",stdout);
	n=read(); for (int i=1;i<n;i++) {
		van f=read(),s=read();
		g[f].push_back(s);
	} for (int i=1;i<=n;i++) sort(g[i].begin(),g[i].end());
	DFS();
	return 0;
}

```

### T3 倾斜的线

### 题目描述

给定两个正整数 P 和 Q。在二维平面上有 n 个整点。现在请你找到一对点使得经过它们的直线的斜率在数值上最接近 P/Q（即这条直线的斜率与 P/Q 的差最小），请输出经过它们直线的斜率 p/q。如果有两组点的斜率的接近程度相同，请输出较小的斜率。

保证答案的 p/q > 0，即输出的 p 和 q 都是正整数。

### 题目分析

将所有点按照过其的斜率为 P/Q 的直线的截距排序。令(i,j,k)为其中的有序三元组，易证得直线(i,j)和直线(j,k)中至少有一条的斜率比直线(i,k)的斜率更接近 P/Q，故答案所选的两个点在排序后一定相邻。

注意直接用 double 类型可能会炸精度，所以需要用整数进行判断。

### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef __int128 van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
template<typename T> inline
T abs(T x) {return x<0?-x:x;}
const van MaxN=2e5+10;
van n,P,Q,ansp=1,ansq=-1,id;
struct point {
	van x,y;
	point(){};
	point(van x,van y):x(x),y(y){};
	bool operator < (const point& a) const {
		if (x==a.x) return y<a.y;
		return x<a.x; 
	}
}p[MaxN];
struct point2 {
	van x,y,id;
	point2(){};
	point2(van x,van y,van id):x(x),y(y),id(id){};
	bool operator < (const point2& a) const {
		if (y==a.y) return x<a.x;
		return y<a.y; 
	}
}p2[MaxN];
bool judge2(van p1,van q1,van p2,van q2) {
	return p1*q2<p2*q1;
}
void SubTask2() {
	for (int i=1;i<=n;i++) p2[i]=point2(p[i].x,p[i].y*Q-p[i].x*P,i);
	sort(p2+1,p2+n+1); for (int i=1;i<=n-1;i++) {
		van a=i,b=i+1;
		van ansp1=abs(p2[a].y-p2[b].y),ansq1=abs(p2[a].x-p2[b].x);
		if (id==0) ansp=ansp1,ansq=ansq1,id=i;
		else if (judge2(ansp1,ansq1,ansp,ansq)) ansp=ansp1,ansq=ansq1,id=i;
	} van a=p2[id].id,b=p2[id+1].id;
	van resp=abs(p[a].y-p[b].y),resq=abs(p[a].x-p[b].x);
	van gcd=__gcd(resp,resq);resp/=gcd,resq/=gcd;
	print(resp),putchar('/'),print(resq);
}
int main() {
	freopen("slope.in","r",stdin);
	freopen("slope.out","w",stdout);
	n=read(),P=read(),Q=read(); 
	for (int i=1;i<=n;i++) {
		van x=read(),y=read();
		p[i]=point(x,y);
	}
	SubTask2();
	return 0;
}
```

### T4 符文

### 题目描述

给定一个长度为 |s| 的符文串 s 和一个长度为 |p| 的符文串 p ，定义符文的等级r(s,p) 表示符文串 s 中最多有多少个互不重叠的子串 p 。

现在你可以在任意位置删除任意个符文。

你需要算出在删除 i (0≤i≤|s|)个符文后得到的符文串ti的r(ti,p)。

### 题目分析

dp，令 f[i][j] 为前 i 个符文删去 j 个符文后最多有多少个 p 串。

令 w[i] 为使得第 i 个符文到第 i+w[i]-1 个符文仅有一个子序列等于 p 的最小的 w[i]。

可推导出状态转移方程如下: 

不删除时: f[i+1][j]=Max{f[i][j]};

删除时: f[i+1][j+1]=Max{f[i][j]},f[i+w[i]][j+w[i]-|p|]=Max{f[i][j]+1};

### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;
	char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;
	return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {
		putchar('0');
		return;
	}
	van st[41]= {0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k; i; i--) putchar('0'+st[i]);
}
const van MaxN=2e3+10;
const van MaxM=5e2+10;
string s,p;
van f[MaxN][MaxN];
van w[MaxN];
int main() {
	freopen("runes.in","r",stdin);
	freopen("runes.out","w",stdout);
	cin>>s>>p;
	van n=s.size(),m=p.size();
	memset(w,-1,sizeof w);
	for (int i=0; i<n; i++) {
		van k=0;
		for (int j=i; j<n; j++) {
			if (s[j]==p[k]) k++;
			if (k==p.size()) {
				w[i+1]=j-i+1;
				break;
			}
		}
	}
	memset(f,-1,sizeof f);
	f[0][0]=0;
	for (int i=1; i<=n; i++) {
		for (int j=0; j<=i; j++) {
			f[i][j]=max(f[i][j],f[i-1][j]);
			f[i][j+1]=max(f[i][j+1],f[i-1][j]);
			if (w[i]!=-1)
				f[i+w[i]-1][j+w[i]-m]=max(f[i+w[i]-1][j+w[i]-m],f[i-1][j]+1);
		}
	}
	for (int i=0; i<=n; i++) print(f[n][i]),putchar(' ');
	return 0;
}
```

### T5 购票

### 题目描述

旅行的路线由编号为 1…N（1≤N≤10^5）的 N 个检查点组成。有 K（1≤K≤10^5）张票可供购买。第 i 张票可以在检查站 ci（1≤ci≤N）以 pi（1≤pi≤10^9）的价格购得，并且可以用其进入所有检查站 [ai,bi]（1≤ai≤bi≤N）。在进入任何检查站之前，必须已购买一张允许其进入该检查站的票。一旦可以前往某一检查站，就可以在未来的任何时候回到该检查站。对于每一个 i∈[1,N]，如果最初只能进入检查点 i，输出使得可以进入检查点 1 和 N 所需的最低总价。如果无法这样做，输出 −1

### 题目分析

线段树优化建边。 对于每一条边，由于只用付一次的价钱，所以需要将要连起来的边先连到一个新点上，权值为 0，然后再将这个点和目标点连接起来，权值为 pi，然后跑出 1 和 n 到各点的最短路，在将所有的点扔进堆里总体跑一个最短路即可。

### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
struct ticket{
	van p,c,a,b;
	ticket(){};
	ticket(van p,van c,van a,van b):p(p),c(c),a(a),b(b){};
}t[MaxN];
struct Edge {
	van u,v,w;
	Edge(van u,van v,van w):u(u),v(v),w(w){};
};
van n,k; van id[MaxN];
vector<Edge> g[MaxN*6];

void Connect(van from,van to,van w) {
	g[from].push_back(Edge(from,to,w));
}
void BuildTree(van p=1,van l=1,van r=n) {
	if (l==r) {id[l]=p;return;} van mid=(l+r)>>1;
	Connect(p*2,p,0); Connect(p*2+1,p,0);
	BuildTree(p*2,l,mid); BuildTree(p*2+1,mid+1,r);
} 
void Update(van L,van R,van from,van p=1,van l=1,van r=n) {
	if (L<=l&&r<=R) {
		Connect(p,from,0);
		return;
	} van mid=(l+r)>>1;
	if (L<=mid) Update(L,R,from,p*2,l,mid);
	if (R>mid) Update(L,R,from,p*2+1,mid+1,r);
}
struct state {
	van dis,id;
	state(van dis,van id):dis(dis),id(id){};
	bool operator < (const state& a) const {
		return dis>a.dis;
	}
}; priority_queue<state> q;
van dis[MaxN*6]; bool used[MaxN*6];
van dis1[MaxN*6],dis2[MaxN*6];
void Dijkstra(van st,bool ahhh=true) {
	memset(used,0,sizeof used);
	for (int i=1;i<=5*n+k;i++) dis[i]=1e18;
	if (ahhh) dis[st]=0,q.push(state(dis[st],st));
	else {
		memcpy(dis,dis1,sizeof dis);
		for (int i=1;i<=5*n+k;i++) q.push(state(dis[i],i));
	}
	while (!q.empty()) {
		van now=q.top().id; q.pop();
		if (used[now]) continue; used[now]=1;
		for (int i=0;i<g[now].size();i++) {
			Edge e=g[now][i];
			if (dis[e.v]>dis[now]+e.w) {
				dis[e.v]=dis[now]+e.w;
				q.push(state(dis[e.v],e.v));
			}
		}
	}
}
int main() {
	n=read(),k=read(); BuildTree();
	for (int i=1;i<=k;i++) {
		van p=read(),c=read(),a=read(),b=read();
		t[i]=ticket(p,c,a,b);
		Update(a,b,4*n+i);
		Connect(4*n+i,id[p],c);
	} Dijkstra(id[1]); memcpy(dis1,dis,sizeof dis1);
	Dijkstra(id[n]); for (int i=1;i<=n*5+k;i++) dis1[i]+=dis[i];
	Dijkstra(0,false); for (int i=1;i<=n;i++)
		print(dis[id[i]]>=1e18?-1:dis[id[i]]),putchar('\n');
	return 0;
}
```

## 20220210

### T1 商贸

### 题目描述

勇者小𝐴通过寻宝提升自己的实力之后仍然无法战胜虫群，他终于意识到了一个人的力量终究时有极限的，因此，他决定开始招兵买马，然而，一个很现实的问题摆在他的面前——他没有钱。所幸他现在所在的国家是一个商贸非常发达的商业共和国，他可以从中跑商赚钱。共和国内有𝑁座城市，编号为1,2,3 … 𝑁。由𝑀条单向的道路连接。小𝐴每一次到达城市𝑖都可以获得𝑚𝑖的收益。小𝐴最开始位于城市1，最后也必须回到编号为1的城市。不过身为勇者的小𝐴的时间是非常宝贵的，沿着一条道路从一座城市到达另一座城市需要花费一天的时间。为了量化小𝐴花费时间贸易的代价，我们认为小𝐴花费𝑇时间贸易的成本为𝐶 × 𝑇^2。

你需要计算出小𝐴可能得到的最高收益。

### 题目分析

注意到时间成本很低，考虑直接 dp，设 f[i][j] 为第 i 个点在第 j 的时间能够获得的最大贡献，直接从最小时间转移到最大时间即可。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
van n,k;
const van MaxN=1e3+10;
vector<van> g[MaxN];
bool used[MaxN];
van f[MaxN][MaxN],c,w[MaxN];
int main() {
	freopen("trade.in","r",stdin);
	freopen("trade.out","w",stdout);
	read(n),read(k),read(c);
	for (int i=1;i<=n;i++) read(w[i]);
	for (int i=1;i<=k;i++) {
		van f,s; read(f),read(s);
		g[f].push_back(s);
	} for (int i=1;i<=n;i++) {
		for (int j=0;j<=1000;j++) {
			f[i][j]=-1e18;
		}
	} f[1][0]=0;
	for (int i=1;i<=1000;i++) {
		for (int j=1;j<=n;j++) {
			for (int k=0;k<g[j].size();k++) {
				van e=g[j][k];
				f[e][i]=max(f[e][i],f[j][i-1]+w[e]);
			}
		}
	} van ans=0;
	for (int i=0;i<=1000;i++)
		ans=max(f[1][i]-c*i*i,ans);
	print(ans);
	return 0;
}
```

### T2 部队集结

### 题目描述

小𝐴需要集结他的部队。通过使用钞能力，小𝐴已经招募到了𝑁名常年游走于刀剑之上的老练雇佣兵，现在，他们拍成一列，编号从1到𝑁，正在接受小𝐴的检阅。

小𝐴也需要将这𝑁名雇佣兵分成小队行动，但是，领队的选择成为了打问题。具体来说，小𝐴只能够选择一个连续的编号区间[𝑙, 𝑟]作为小队行动，所有编号𝑙 ≤ 𝑖 ≤ 𝑟的雇佣兵𝑖会加入小队，雇佣兵𝑙, 𝑟会作为领队。然而，不同的雇佣兵有自己的技术倾向，具体来说，我们可以使用数字𝑏𝑖来描述编号为𝑖的雇佣兵的技术倾向，如果队长的技术倾向与队内的其他成员(包括另一位队长)相同，那么这个队伍就无法和睦相处。

你的任务是帮助小𝐴计算出有多少个区间可以划分出一个和睦相处的小队。

### 题目分析

经典的数据结构题。找到对于某一个队长，他所能找到的另一个队长的区间在哪里，然后动态加点删点，区间查询当该人作为队长时符合条件的右端点有多少个即可。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=2e5+10;
van n,a[MaxN]; vector<van> waited_delete[MaxN];
van nxt[MaxN],pre[MaxN],now[MaxN],ans=0;
struct SegmentTree {
	van dat[MaxN<<2];
	void UpdateTree(van wh,van num,van p=1,van l=1,van r=n) {
		if (l==r) {dat[p]+=num;return;}
		van mid=(l+r)>>1;
		if (wh<=mid) UpdateTree(wh,num,p*2,l,mid);
		else UpdateTree(wh,num,p*2+1,mid+1,r);
		dat[p]=dat[p*2]+dat[p*2+1];
	}
	van QueryTree(van L,van R,van p=1,van l=1,van r=n) {
		if (L<=l&&r<=R) return dat[p];
		van sum=0,mid=(l+r)>>1;
		if (L<=mid) sum+=QueryTree(L,R,p*2,l,mid);
		if (R>mid) sum+=QueryTree(L,R,p*2+1,mid+1,r);
		return sum;
	}
}T;
int main() {
	freopen("gather.in","r",stdin);
	freopen("gather.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) 
		pre[i]=now[a[i]],nxt[now[a[i]]]=i,now[a[i]]=i;
	for (int i=1;i<=n;i++) if (nxt[i]==0) nxt[i]=n+1;
	for (int i=n;i;i--) {
		for (int j=0;j<waited_delete[i].size();j++) {
			van id=waited_delete[i][j];
			T.UpdateTree(id,-1);
		} ans+=T.QueryTree(i+1,nxt[i]-1); // cout<<i<<" "<<T.QueryTree(i+1,nxt[i]-1)<<endl;
		T.UpdateTree(i,1); waited_delete[pre[i]].push_back(i);
	} print(ans);
	return 0;
}
```

### T3 虫群扩张

### 题目描述

经过一番战斗之后，虫群终于被小𝐴击溃，虫群女王也落入到了小𝐴设计的陷阱之中。

小𝐴设计的陷阱可以用一个𝑁 × 𝑁的方阵表示，其中，每一个方格可能是空格或者炸弹，并且所有边界上的方格都被小𝐴布置了炸弹。某一些没有被布置炸弹的方格可能回使虫群女王出现的起始位置。

最开始，虫群女王位于某一个可能的起始位置上，在这之后的每一个单位时间内，女王和她的虫群会向着相同的方向移动一格或停留在原地（移动方向为网格内的上下左右四个方向中的一个）。每经过𝐷个单位时间，虫群会进行一个增殖，位于(𝒙, 𝒚)的虫子会在方格(𝒙 + 𝟏, 𝒚), (𝒙 − 𝟏, 𝒚), (𝒙, 𝒚 − 𝟏), (𝒙, 𝒚 + 𝟏)各产生一只新的虫子。每一个格子内可能出现多只虫子。

如果移动或者增殖使得任何一只虫子触碰到了炸弹，那么炸弹就会被引爆，由于连锁爆炸，整个网格图都会被炸毁。身为慎重勇者的小𝐴具有短距离传送的能力，因此他决定在炸弹激发之前前往陷阱内以防止一些意外情况地发生。为了让小𝐴地行动更加有效率，你需要帮助小𝐴求出有多少个格子内可能出现虫群。

### 题目分析

两遍 Dijkstra 和一遍 BFS 即可。第一遍 Dijkstra 则跑出对于某个点能够接受的虫群女王的最大半径是多少，接下来跑一遍 BFS 查找出虫群女王能够走到哪些点，最后一遍 Dijkstra 则将所有女王能够做到的格子以及这个格子能够承受的最大半径作为权值，跑一遍最大路，统计出有哪些格子能够被扩展到即可。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,d;char m[MaxN][MaxN];
van dis[MaxN][MaxN]; bool used[MaxN][MaxN];
van dis2[MaxN][MaxN];
van VanGo[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
bool in(van x,van y) {return x>0&&y>0&&x<=n&&y<=n;}
void Dijkstra() {
	memset(dis,(1<<6)-1,sizeof dis);
	priority_queue<pair<van,pair<van,van> > > q;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) 
		if (m[i][j]=='#') q.push(make_pair(0,make_pair(i,j))),dis[i][j]=0;
	while (!q.empty()) {
		van x=q.top().second.first,y=q.top().second.second;q.pop();
		if (used[x][y]) continue; used[x][y]=1;
		for (int i=0;i<4;i++) {
			van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
			if (m[xx][yy]=='#') continue;
			if (!in(xx,yy)) continue;
			if (dis[xx][yy]>dis[x][y]+1) {
				dis[xx][yy]=dis[x][y]+1;
				q.push(make_pair(-dis[xx][yy],make_pair(xx,yy)));
			}
		}
	}
}
void BFS() {
	queue<pair<pair<van,van>,pair<van,van> > > q;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++)
		if (m[i][j]=='S') q.push(make_pair(make_pair(i,j),make_pair(0,1)));
	while (!q.empty()) {
		van x=q.front().first.first,y=q.front().first.second;
		van dnow=q.front().second.first,l=q.front().second.second; q.pop();
		if (used[x][y]) continue;
		used[x][y]=1; if (dnow>=d) dnow-=d,l++;
		if (l>dis[x][y]) continue;
		for (int i=0;i<4;i++) {
			van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
			if (m[xx][yy]=='#') continue;
			if (!used[xx][yy]) if (dis[xx][yy]>=l) 
				q.push(make_pair(make_pair(xx,yy),make_pair(dnow+1,l)));
		}
	}
}
void dijkstra() {
	priority_queue<pair<van,pair<van,van> > > q;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) 
		if (used[i][j]) q.push(make_pair(dis[i][j],make_pair(i,j))),dis2[i][j]=dis[i][j];
	memset(used,0,sizeof used);
	while (!q.empty()) {
		van x=q.top().second.first,y=q.top().second.second;q.pop();
		if (used[x][y]) continue; used[x][y]=1;
		if (dis2[x][y]==1) continue;
		for (int i=0;i<4;i++) {
			van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
			if (m[xx][yy]=='#') continue;
			if (dis2[xx][yy]<dis2[x][y]-1) {
				dis2[xx][yy]=dis2[x][y]-1;
				q.push(make_pair(dis2[xx][yy],make_pair(xx,yy)));
			}
		}
	}
}
van ans=0;
void Solve() {
	memset(used,0,sizeof used);
	BFS(); for (int i=1;i<=n;i++) {
		for (int j=1;j<=n;j++) cout<<used[i][j];
		cout<<endl;
	} dijkstra(); 
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++)
		if (used[i][j]) ans++;
}
int main() {
//	freopen("proliferate.in","r",stdin);
//	freopen("proliferate.ans","w",stdout);
	read(n),read(d); for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++) cin>>m[i][j];
	Dijkstra(); Solve(); print(ans);
	return 0;
}
```

### T4 推演

### 题目描述

尽管虫群已经被小𝐴彻底毁灭了，女王手中进入魔王城的四个钥匙碎片之一仍然没有被小𝐴获得，这个钥匙碎片被藏在了虫巢内部一个隐蔽的传送门内的空间里。

这篇神奇的空间并不是一篇平坦的空间，这篇空间可以被看成是一个巨大的二维网格。对于其中的一个坐标(𝑥, 𝑦)，只有在满足如下条件时才是一块可以到达的悬浮石块：

对于所有的整数𝑘 ≥ 0,⌊$\frac{x}{3^k}$⌋和⌊$\frac{y}{3^k}$⌋对3取模得到的数字奇偶性相同。例如:(1,7)就是一个满足条件的坐标，因为当𝑘 = 0时两个数字对3去模得到的结果都是1，𝑘 = 1时两个数字对3取模得到的结果为0和2。奇偶性相同。而𝑘 ≥ 2时，得到的数都是0。

由于自身技能特性的原因，小𝐴需要你计算出某一个特定区域内有多少个格子上是有悬浮石块的。具体来说，他会给出𝑄个询问，每一个询问包括三个整数𝑥𝑖, 𝑦𝑖, 𝑑𝑖。对于每一个询问，小𝐴想知道有多少悬浮石块位于(𝑥𝑖, 𝑦𝑖)到(𝑥𝑖 + 𝑑, 𝑦𝑖 + 𝑑)的对角线方格上(包括两个端点)。

### 题目分析

诈骗题，打个表就能找到规律，发现对于一个长度为 3*N 的正方形，可能会有答案的为将这个正方形分成3*3个小格子后的四个边角的格子和中间的格子。

考虑将平面直角坐标系旋转 45° 后并用 $\sqrt 2$ 作为新坐标系的单位长度，推导一下就能找到在原坐标上的点到了新坐标后的点的坐标。然后一个分治就可以解决问题了。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
van Q; double pai=acos(-1);
van siz[61],sizy[61];
van GetSiz(van f,van line) { // 当前等级的 f
	if (f<0) return 0;
	if (f==0) return 1;
	line--; van id=line/siz[f-1]; assert(id<3);
	if (id==2||id==0) return GetSiz(f-1,line%siz[f-1]+1);
	if (id==1) return 3*GetSiz(f-1,line%siz[f-1]+1);
}
van GetNum(van x,van y,van f) { // 更小一级的 f
	if (x==0) return 0;
	if (f==-1) return 1;
	if (x>siz[f+1]) {
		van res=(x-1)/siz[f+1]*GetSiz(f+1,y);
		x=(x-1)%siz[f+1]+1;
		return res+GetNum(x,y,f);
	} van yid=(y-1)/siz[f],xid=(x-1)/siz[f]; 
	assert(yid<3),assert(xid<3);
	van xx=(x-1)%siz[f]+1,yy=(y-1)%siz[f]+1;
	if (yid==0||yid==2) {
		if (xid==0) return 0;
		if (xid==1) return GetNum(xx,yy,f-1);
		if (xid==2) return GetSiz(f,yy);
	} if (yid==1) {
		return xid*GetSiz(f,yy)+GetNum(xx,yy,f-1);
	} return 0;
}
int main() {
	siz[0]=1; for (int i=1;i<=60;i++) siz[i]=siz[i-1]*3;
	sizy[0]=0; for (int i=1;i<=60;i++) sizy[i]=sizy[i-1]+siz[i-1];
	read(Q); for (int qq=1;qq<=Q;qq++) {
		van d,x,y; read(d),read(x),read(y);
		
		if ((x+y)%2==1){print(0),putchar('\n');
		continue;}
		x++,y++; van xx=x,yy=y;
		y=abs(y-x)/2,x+=y*(yy>x?1:-1); van endx=x+d,f;
		if (y==0){print(endx-x+1),putchar('\n');
		continue;}
		
		for (int j=0;j<=60;j++) 
			if (sizy[j]>=y){f=j;break;}
		y+=sizy[f]+1;
		print(GetNum(endx,y,f-1)-GetNum(x-1,y,f-1)),putchar('\n');
	}
	return 0;
}
```

## 20220212

### T1 魔法阵

### 题目描述

击败虫群女王之后，小𝐴的目标定在了魔王军第二天王。第二天王统御魔王军的暗部，擅长刺杀，正面对敌能力偏弱，与他的小队一起行动。众所周知，𝐶𝑎𝑠𝑡𝑒𝑟才能够克制𝐴𝑠𝑠𝑎𝑠𝑠𝑖𝑛。因此，小𝐴决定布下可以分割战场的法阵，随后刺杀第二天王。在一个峡谷内，小𝐴找到了一个残破的法阵。

这个残破的魔法阵由𝑁个节点以及其内部的回路组成。**每一个节点内部有四个回路节点，每一个回路节点会与另一个回路节点直接连接，在输入数据中，相同编号的回路节点即表示直接连接的回路节点。**同时，**在每一个魔法阵内的节点中，第一个回路节点和第二个回路节点会被连接，第三个回路节点和第四个回路节点会被连接。**

为了使得这个魔法阵重新正常工作，小𝐴可以重新排列某一个魔法阵节点内的回路节点，改变回路节点的连接情况，使得**任意两个回路节点均位于一个联通块内**。改变魔法阵节点𝑖的代价为𝑐𝑖。你需要计算最少需要花费多少代价可以使得这个魔法阵重新正常工作。输入保证存在合法解。

### 题目分析

不管什么乱七八糟的回路节点，只需要把该连的点连起来跑类似于最小生成树的算法即可。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	van f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=5e5+10;
struct l {
	van c,p1,p2,p3,p4;
	l(){};
	l(van c,van p1,van p2,van p3,van p4):c(c),p1(p1),p2(p2),p3(p3),p4(p4){};
	bool operator < (const l& a) const {
		return c<a.c;
	}
}m[MaxN]; van fa[MaxN],ans=0;
van n; vector<van> g[MaxN];
void DFS(van now,van id) {
	fa[now]=id; for (int i=0;i<g[now].size();i++)
		if (!fa[g[now][i]]) DFS(g[now][i],id);
}
van GetFa(van x) {return fa[x]==x?x:fa[x]=GetFa(fa[x]);}
void Merge(van a,van b) {fa[GetFa(a)]=GetFa(b);}
int main() {
//	freopen("magic.in","r",stdin);
//	freopen("magic.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) {
		van c,p1,p2,p3,p4; read(c),read(p1),read(p2),read(p3),read(p4);
		m[i]=l(c,p1,p2,p3,p4); 
		g[p1].push_back(p2);
		g[p2].push_back(p1);
		g[p3].push_back(p4);
		g[p4].push_back(p3);
	} sort(m+1,m+n+1);
	for (int i=1;i<=n*2;i++) if (!fa[i]) DFS(i,i);
	for (int i=1;i<=n;i++) {
		if (GetFa(m[i].p1)!=GetFa(m[i].p3)) ans+=m[i].c,Merge(m[i].p1,m[i].p3);
	} print(ans);
}
```

### T2 区域侦测

### 题目描述

小𝐴终于发现了第二天王以及他的手下并把他们引入了魔法阵中，他们在魔法阵中的位置可以用一个网格图中的坐标表示。现在，第二天王和他的手下一共𝑁个人正占据这这个网格图中的某些位置。

催动魔法阵会将这个网格图中的某一个正方形区域与其他区域分割开来，这个正方形的四条边必须与网格图的𝑥轴和𝑦轴平行且至少包含一个方格。现在，基于各种考量，小𝐴希望你帮他求出这𝑁个人有多少个子集可以被这样一个正方形区域分割出来。

### 题目分析

将所有的点按照 x 坐标排序，随后枚举正方形最左侧的点和最右侧的点，这样我们就确定了正方形的边长，随后就需要计算有多少的覆盖可能了，我们可以将所有 x 坐标在这两个点之间的点再按照 y 坐标进行排序，从下到上，使用类似扫描线，或者滑动窗口的做法，求出某一情况下，正方形内的点即可。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	van f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x,van jz=10) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[210]={0},k=0;
	while (x) st[++k]=x%jz,x/=jz;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=200+10;
struct pos {
	van x,y;
	bool operator < (const pos& a) const {
		if (x==a.x) return y<a.y;
		return x<a.x;
	}
}p[MaxN];
set<van> s;
van n,ans=0,res=0;
void run() {
	sort(p+1,p+n+1);
	for (int i=1;i<=n;i++) {
		while (!s.empty()) s.erase(s.begin());
		s.insert(p[i].y); for (int j=i+1;j<=n;j++) {
			s.insert(p[j].y);
			vector<van> v(s.begin(),s.end());
			van len=p[j].x-p[i].x;
			van ly=max(p[i].y,p[j].y)-len,ry=min(p[i].y,p[j].y);
			if (ly>ry) continue;
			van siz=v.size(),l=0,r=-1;
			while (r+1<siz&&v[r+1]<ly+len) r++;
			while (r<siz&&(r<0||v[r]<=ry+len)) {
				if (r<0) {r++; continue;}
				van L=max(v[r]-len,ly),R=min((r+1<siz?v[r+1]-len:ry+1),ry+1)-1;
				while (l<siz&&v[l]<L) l++;
				if ((v[r]<ly+len&&v[r+1]>ly+len)||(v[r]>=ly+len)) ans++;
				if (v[r]-v[l]==len) res++;
				while (l+1<siz&&v[l]<R) {
					ans++,l++;
					if (v[r]-v[l]==len) res++;
				} r++;
			}
		}
	}
}
int main() {
	read(n); for (int i=1;i<=n;i++) read(p[i].x),read(p[i].y);
	ans=n+1; run(); 
	for (int i=1;i<=n;i++) swap(p[i].x,p[i].y);
	run(); print(ans-res/2);
}
```

### T3 加固

### 题目描述

尽管阵型的分割做的颇为顺利，但是第二天王手下突然出现的破阵师让这一次围攻计划有了一定的悬念，因此，小𝐴需要加固这一个魔法阵。不过在加固之前，小𝐴需要知道这个魔法阵被破解到了怎样的程度。

破解魔法阵只需要重复吟唱一段相同的咒语即可，破阵师已经将这一段咒语重复吟唱了若干次，据小𝐴所知，这一段咒语是将26个小写英文字母按照某种特定的顺序排列得到的。小𝐴并不知道这一种特殊的排列顺序，除此之外，他也并没有完整听清楚破阵师的吟唱。小𝐴将听见的破阵师的吟唱内容连接成了一个字符串，他需要让你帮忙求出，最好情况下，这一段终于被重复吟唱了多少次(即最少的吟唱次数)。

### 题目分析

显然，如果在咒语中，字符 si 的字典序大于字符 si+1，那么就会对答案有1的贡献。需要注意的是，所有测试数据均满足字符集 |$\sum$|$\leq $20。我们可以枚举所有的字符集计算答案。

我们假设 fs 表示现在将 s 内的字符已经摆拍在前面，已经产生的最小贡献，枚举下一个字符计算贡献即可。记录 cost{i,j} 表示原串中满足某一个字符为 i，下一个字符为 j 的数量，则 $f_{S|2^i}=f_S+\sum cost_{i,j}$。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	van f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=22;
string x; van s[MaxN][MaxN];
van num[100010],tmp[100010];
van dp[1<<MaxN];
int main() {
//	freopen("reinforce.in","r",stdin);
//	freopen("reinforce.out","w",stdout);
	cin>>x; van n=x.size(); 
	for (int i=1;i<=n;i++) num[i]=x[i-1];
	memcpy(tmp,num,sizeof tmp); sort(tmp+1,tmp+n+1);
	van cnt=unique(tmp+1,tmp+n+1)-tmp-1;
//	cout<<cnt<<endl;
	for (int i=1;i<=n;i++) num[i]=lower_bound(tmp+1,tmp+cnt+1,num[i])-tmp;
	for (int i=1;i<n;i++) s[num[i]][num[i+1]]++;
	memset(dp,(1<<6)-1,sizeof dp); dp[0]=1;
//	cout<<1<<endl;
	for (int i=1;i<(1<<cnt);i++) {
		for (int j=1;j<=cnt;j++) {
			if (i&(1<<(j-1))) {
				van sum=dp[i^(1<<(j-1))];
				for (int k=1;k<=cnt;k++) if (i&(1<<(k-1))) sum+=s[j][k];
				dp[i]=min(dp[i],sum);
			}
		} // if (i%1000==0) print(i),putchar('\n');
	} print(dp[(1<<cnt)-1]); return 0;
}
```

### T4 斩首行动

### 题目描述

现在整个第二天王及其手下都被一一分离可以逐个击破了，但是，由于所有人的装束都是完全相同的，小𝐴无法将每一个敌人的身份和位置对应起来。不过，小𝐴知道最开始的𝑁个敌人对应的编号。

在进入陷阱前，队伍被打乱过，最开始，编号位𝑖的敌人位于位置𝑖出。随后，每一分钟，会有两个敌人交换自己的位置，我们可以用一个长度为𝐾的二元组序列(𝑎𝑖, 𝑏𝑖)表示这种位置交换，在第𝑖分钟，位置𝑎𝑖上的敌人会和位置𝑏𝑖上的敌人进行位置交换。这种交换会以𝐾分钟为一个循环重复执行到至多第𝑀分钟。

你的任务是求出，对于每一个初始编号𝑖，求出编号为𝑖敌人可能出现的位置。

### 题目分析

显然。一轮 K 次交换之后，所有位置的交换结果是一个置换，对于每一个节点，也会有一个中途经过的位置集合 Si。一个置换是由若干的环组成的，如果 M 足够大，对于每一个环内的元素，它经过的位置就是环内所有元素的 Si 的并集。注意 $\sum S_i$ 的大小只有 N+K 级别，即每一次交换至多使得两个点的 Si 集合扩充至多一个位置，加上最初的位置，故 $\sum S_i$ 最大只有 N+2*K。

如果 M 不足够大，我们可以对于每一个环单独处理，可以使用双指针的做法找到对于每一个点产生的有效的位置交换的左右端点。逐点模拟维护一个桶即可。

### 参考代码

```c++
#include<bits/stdc++.h>
#define van long long
#define ywhin cin
#define ywhout cout
using namespace std;
bool ppppp;
const van K=1000100,N=1000100;
van n,k,m;
van x[K],y[K],now[N];
van ans[N],tmp[N],ansnow;
van toelem[N],toid[N],weight[N],cnt;
bool used[N];
van last[N];
van line[N*2],top;
bool pppppp;

void InitProgram() {
	cnt=n;
	for (int i=1;i<=n;i++) {
		now[i]=i;
		toelem[i]=i;
	}
}
void add(van x) {
	if (tmp[x]==0) ansnow++;
	tmp[x]++;
}
void del(van x) {
	tmp[x]--;
	if (!tmp[x]) ansnow--;
}
void addLine(van to,van s,van e,van val) {
	toid[s]=to;
	toelem[to]=e;
	weight[to]=val;
}
void DFS(van now) {
	if (used[now]) return;
	used[now]=1;line[++top]=now;
	DFS(toid[now]);
}

int main() {
	ywhin>>n>>k>>m;
	InitProgram();
	for (int i=1;i<=k;i++) {
		ywhin>>x[i]>>y[i];
		addLine(++cnt,now[x[i]],y[i],i-last[x[i]]);
		addLine(++cnt,now[y[i]],x[i],i-last[y[i]]);
		now[y[i]]=cnt-1,now[x[i]]=cnt;
		last[x[i]]=last[y[i]]=i;
	}
	for (int i=1;i<=n;i++) {
		toid[now[i]]=i;
		weight[i]=k-last[i];
	}
	for (int i=1;i<=n;i++) {
		if (!used[i]) {
			top=0;DFS(i);van back=top;
			for (int j=1;j<=back;j++) line[++top]=line[j];
			van right=1,sum=0;add(toelem[line[1]]);
			for (int j=1;j<=top;j++) {
				while(sum+weight[line[right+1]]<=m&&right+1<=top) {
					sum+=weight[line[right+1]];
					add(toelem[line[right+1]]);
					right++;
				}
				if (line[j]<=n&&j<=top/2) ans[line[j]]=ansnow;
				del(toelem[line[j]]);
				sum-=weight[line[j+1]];
			} 
		}
	}
	for (int i=1;i<=n;i++) ywhout<<ans[i]<<endl;
	return 0;
}
```

## 20220219

### T1 photo

### 题目描述

给定一个字符矩形，输出它顺时针旋转 90 度，然后水平翻转，最后放大两倍的图像。

### 题目分析

模拟题。注意细节即可。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,m;
char x[MaxN][MaxN],y[MaxN][MaxN];
int main() {
//	freopen("photo.in","r",stdin);
//	freopen("photo.out","w",stdout);
	read(n),read(m);
	for (int i=1;i<=m;i++) for (int j=1;j<=n;j++) cin>>x[j][i];
//	for (int i=1;i<=n;i++){for (int j=1;j<=m;j++) cout<<x[i][j];cout<<endl;}
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) 
		y[i*2][j*2]=y[i*2-1][j*2]=y[i*2][j*2-1]=y[i*2-1][j*2-1]=x[i][j];
	for (int i=1;i<=n*2;i++) {
		for (int j=1;j<=m*2;j++) {
			cout<<y[i][j];
		} cout<<endl;
	}
	return 0;
}
```

### T2 swap

### 题目描述

给定一个序列 a ，元素两两不同，可以使用两种操作。

1. 翻转相邻两个元素
2. 翻转相邻三个元素

问怎么操作使这个序列变成升序，并使操作一的次数最少，且输出这个最少的次数

### 题目分析

发现如果只做第二个操作的话在奇数位置上的数是不可能到偶数位置上的，而这时候就需要用到第一个操作了。因此我们只需要判断一个数的初始位置的奇偶性是否等于最终位置上的奇偶性即可。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10; van ans=0;
van n,a[MaxN],b[MaxN],c[MaxN];
int main() {
//	freopen("swap.in","r",stdin);
//	freopen("swap.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	memcpy(b,a,sizeof b); sort(b+1,b+n+1);
	van cnt=unique(b+1,b+n+1)-b-1;
	for (int i=1;i<=n;i++) c[i]=lower_bound(b+1,b+cnt+1,a[i])-b;
	for (int i=1;i<=n;i++) if (i%2!=c[i]%2) ans++;
	print(ans/2);
	return 0;
}
```

### T3 tree

### 题目描述

给你一个长度为 n 的整数序列 a，问是否能构造一棵完美树。
完美树的每条边长度都为 1。并且对于每一个点 i，在树中离它距离最远的点与它的距离恰好等于 ai。

### 题目分析

先构造直径，在将所有点挂在直径上，判断这个直径上的所有位置是否存在至少一个数即可。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,a[MaxN],siz;
bool used[MaxN];
struct node {
	van num,id;
	node(){};
	node(van num,van id):num(num),id(id){};
	bool operator < (const node& a) const {
		return num<a.num;
	}
}nod[MaxN];
void clear() {
	memset(used,0,sizeof used);
}
bool solve() {
	van maxid=0; read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) if (a[i]>a[maxid]) maxid=i;
	siz=a[maxid]+1; van cent=siz/2+1;
	for (int i=1;i<=n;i++) if (a[i]<siz/2) return false;
	for (int i=1;i<=n;i++) nod[i]=node(a[i],i);
	sort(nod+1,nod+n+1); used[siz]=used[a[1]+1]=1;
	for (int i=1;i<=n;i++) {
		if (nod[i].id==maxid||nod[i].id==1) continue;
		if (!used[nod[i].num+1]){used[nod[i].num+1]=1;continue;}
		if (!used[siz-nod[i].num]){used[siz-nod[i].num]=1;continue;}
		if (cent>nod[i].num) return false;
	} for (int i=1;i<=siz;i++) if (!used[i]) return false;
	return true;
}
int main() {
//	freopen("tree.in","r",stdin);
//	freopen("tree.out","w",stdout);
//	van T; read(T);
//	for (int i=1;i<=T;i++) 
	clear(),cout<<(solve()?"Possible":"Impossible")<<endl;
	return 0;
}
```

### T4 rabbit

### 题目描述

有 n 只兔子在一个数轴上，兔子为了方便起见从 1 到 n 标号，第 i 只兔子的初始坐标为 xi。

兔子会以以下的方式在数轴上锻炼：一轮包含 m 次跳跃，第 j 次是编号为 aj 的兔子跳一下，它会从兔子 aj-1 和兔子 aj+1 中等概率的选一个（假设选了 x ），那么 aj 号兔子会跳到它当前坐标关于 x 的坐标的对称点。（注意，即使兔子的位置顺序变化了，但是编号仍保持不变，这里按兔子编号算）兔子会进行 k 轮跳跃，对每个兔子，请你求出它最后坐标的期望值。

### 题目分析

数学期望简单题，设 xi 为当前第 i 只兔子期望的位置，则 xi'=x{i+1}+x{i-1}-xi。这东西就类似于 NOIP2022 T3 那个东西了，利用差分性质解决即可。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10;
van n,m,k,op[MaxN],c[MaxN],res[MaxN];double x[MaxN];
van now[MaxN],to[MaxN],fa[MaxN],siz[MaxN];
van f(van x) {return fa[x]==x?x:fa[x]=f(fa[x]);}
void mg(van a,van b) {fa[f(a)]=f(b);}
int main() {
//	freopen("rabbit.in","r",stdin);
	read(n); for (int i=1;i<=n;i++) read(x[i]);
	read(m),read(k); for (int i=1;i<=m;i++) read(op[i]);
	for (int i=1;i<n;i++) c[i]=x[i+1]-x[i],now[i]=i;
	for (int i=1;i<=m;i++) swap(now[op[i]],now[op[i]-1]);
	for (int i=1;i<n;i++) to[now[i]]=i,fa[i]=i;
//	for (int i=1;i<n;i++) cout<<to[i]<<" ";cout<<endl;
	for (int i=1;i<n;i++) mg(to[i],i);
	for (int i=1;i<n;i++) siz[f(i)]++;
//	for (int i=1;i<n;i++) cout<<siz[f(i)]<<" ";cout<<endl;
	for (int i=1;i<n;i++) {
		if (f(i)==i) {
			van t=k%siz[f(i)],pt=i,pt2=i;
//			cout<<t<<" "<<pt<<" "<<pt2<<endl;
			for (int j=1;j<=t;j++) pt=to[pt];
//			cout<<t<<" "<<pt<<" "<<pt2<<endl;
//			cout<<t<<" "<<pt<<" "<<pt2<<endl;
			for (int j=1;j<=siz[f(i)];j++)
				res[pt]=pt2,pt2=to[pt2],pt=to[pt];	
		}
	} for (int i=2;i<=n;i++) x[i]=x[i-1]+c[res[i-1]];
//	for (int i=1;i<n;i++) cout<<res[i]<<" ";cout<<endl;
//	freopen("rabbit.out","w",stdout);
	for (int i=1;i<=n;i++) cout<<fixed<<setprecision(1)<<x[i]<<endl;
	return 0;
}
```

### T5 ball

### 题目描述

有一个棋盘，上面要么是空的，要么有一个球，要么是一个出口（整个地图只有一个出口）。

每次可以让所有球向上下左右中的某个方向移动一格，如果它超出了棋盘的边界就会消失。如果它到了出口的位置你就能得到这颗球(并且从棋盘上消失)。求你能够得到的球的最大值。

### 题目分析

[AT2045 [AGC004E] Salvage Robots - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/solution/AT2045)

### 参考代码

TLE:
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,m,x,y,sum[MaxN][MaxN]; char ch[MaxN][MaxN];
van l,r,u,d,VanGo[4][2]={{1,0},{0,1},{-1,0},{0,-1}},ans;
bool used[MaxN][MaxN];
van GetBalls(van x1,van y1,van x2,van y2) {
	if (y2<y1||x2<x1) return 0;
//	assert(y2>=y1); assert(x2>=x1);
	return sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1];
}
bool in(van x,van y) {return x>=1&&y>=1&&x<=n&&y<=m;}
van f[11][11][11][11][11][11];
void DFS(van x,van y,van minx,van maxx,van miny,van maxy,van num) {
	if ()
	if (ch[x][y]=='o'&&!used[x][y]) num++; 
	used[x][y]=1; for (int i=0;i<4;i++) {
		van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
		if (in(xx,yy)) {
			van nminx=max(minx,xx-l),nminy=max(miny,yy-u),
				nmaxx=min(maxx,xx+r),nmaxy=min(maxy,yy+d);
			DFS(xx,yy,nminx,nmaxx,nminy,nmaxy,num);
		}
	} used[x][y]=0;
}
void DFS(van x,van y,van minx,van maxx,van miny,van maxy,van num) {
	if (ch[x][y]=='o'&&!used[x][y]) num++; 
	cout<<x<<" "<<y<<" "<<minx<<" "<<maxx<<" "<<miny<<" "<<maxy<<" "<<num<<" "<<ans<<endl;
	if (num+GetBalls(minx,miny,maxx,maxy)<=ans) return;
	ans=num;
	if (GetBalls(minx,miny,maxx,maxy)==0) return;
	if (used[x][y]||x>maxx||x<minx||y>maxy||y<miny) return;
	used[x][y]=1; for (int i=0;i<4;i++) {
		van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
		if (in(xx,yy)) {
			van nminx=max(minx,xx-l),nminy=max(miny,yy-u),
				nmaxx=min(maxx,xx+r),nmaxy=min(maxy,yy+d);
			DFS(xx,yy,nminx,nmaxx,nminy,nmaxy,num);
		}
	} used[x][y]=0;
	// cout<<"Back"<<endl;
}
int main() {
	freopen("ball.in","r",stdin);
	read(n),read(m); for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) cin>>ch[i][j];
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) if (ch[i][j]=='E') x=i,y=j;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) if (ch[i][j]=='o') sum[i][j]=1;
	l=x-1,r=n-x,u=y-1,d=m-y; DFS(x,y,1,n,1,m,0);
	freopen("ball.out","w",stdout);
	print(ans);
	return 0;
}
```

## 20220226

### T1 输出练习

### 题目描述

为了练习输出，你需要从小到大输出 $[l,r]$ 范围内能表示为 $k$ 的非负整数次方的所有数。

一共有 $T$ 次练习。注意所有数的 $0$ 次方都是 $1$，特别地，本题中认为 $0^0=1$。

### 题目分析

水题一道。for判断一下有哪些数是k的i次方，再判断这些数是否在给定的范围内就行了。

注意: 

1. 如果k较大会出现乘个几次就爆了，所以如果发现乘出范围了要及时退出循环
2. 这个最大循环范围不能是r，
	因为当k=l=r=0时，你第一次就退出循环了，没有答案，但答案却会有一个0
	建议这个最大范围是题目中数据的最大范围2^63，为保险起见，可以再开大点。 
3. 当k=0时，可能的值有两种，即1,0
4. 为了避免光是k*k就爆了，建议开个__int128
5. 不能即时输出，万一k=1的时候，即时输出了多个1，也会爆
6. 不能开bool数组判断是否输出过了(你懂的)
7. 集合不能开成可重集了，不然只能起到一个排序的作用 

### 参考代码

```c++
/*
	T1 output:
	水题一道。for判断一下有哪些数是k的i次方，再判断这些数是否在给定的范围内就行了。
	注意: 
	1. 如果k较大会出现乘个几次就爆了，所以如果发现乘出范围了要及时退出循环
	2. 这个最大循环范围不能是r，
	   因为当k=l=r=0时，你第一次就退出循环了，没有答案，但答案却会有一个0
	   建议这个最大范围是题目中数据的最大范围2^63，为保险起见，可以再开大点。 
	3. 当k=0时，可能的值有两种，即1,0
	4. 为了避免光是k*k就爆了，建议开个__int128
	5. 不能即时输出，万一k=1的时候，即时输出了多个1，也会爆
	6. 不能开bool数组判断是否输出过了(你懂的)
	7. 集合不能开成可重集了，不然只能起到一个排序的作用 
*/
#include<bits/stdc++.h>
using namespace std;
typedef __int128 van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
unsigned long long max_=-1;
int main() {
	freopen("output.in","r",stdin);
	freopen("output.out","w",stdout);
	van T; read(T);
	for (int tt=1;tt<=T;tt++) {
		van l,r,k; read(l),read(r),read(k);
		set<van> ans;
		van res=1; for (int i=0;i<=63;i++) {
			if (res>van(max_)) break;
			if (res>=l&&res<=r) ans.insert(res);
			res*=k;
		} if (ans.size()==0) puts("None.");
		else {
			for (set<van>::iterator it=ans.begin();it!=ans.end();it++) 
				print(*it),putchar(' ');putchar('\n');
		}
	}
	return 0;
}
```

### T2 最近距离

### 题目描述

给定一个序列 $a_{1\cdots n}$，你需要回答 $m$ 个询问，每个询问给定 $l,r$，你需要回答满足 $l\leq i<j\leq r,a_i=a_j$ 的最小的 $j-i$，即区间内最近的两个相同数的距离，若不存在，输出 `-1`。

### 题目分析

很明显的数据结构题，对询问按右端点从小到大排序。

线段树中记录对于某个点它的下一个和它相同的点在dat[i]个单位后。 

记录一个变量R表示已经将前R个数的数据加入到线段树中了。

对于每个询问，先将R+1到q[i].r的数据全部加入到线段树中，然后询问q[i].l到n的最小值即可。

注意: 

也没啥好注意的，打出来就行了。 

### 参考代码

```c++
/*
	T2 dis:
	很明显的数据结构题，对询问按右端点从小到大排序。
	线段树中记录对于某个点它的下一个和它相同的点在dat[i]个单位后。 
	记录一个变量R表示已经将前R个数的数据加入到线段树中了。
	对于每个询问，先将R+1到q[i].r的数据全部加入到线段树中，然后询问q[i].l到n的最小值即可。
	注意: 
	也没啥好注意的，打出来就行了。 
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e6+10;
van n,m,a[MaxN],tmp[MaxN];
van lst[MaxN],ans[MaxN];
struct query {
	van l,r,id;
	bool operator < (const query& a) const {
		return r<a.r;
	}
}q[MaxN];
struct SegmentTree {
	van dat[MaxN<<2];
	void BuildTree(van p=1,van l=1,van r=n) {
		if (l==r){dat[p]=1e18;return;}
		van mid=(l+r)>>1;
		BuildTree(p*2,l,mid);
		BuildTree(p*2+1,mid+1,r);
		dat[p]=min(dat[p*2],dat[p*2+1]);
	}
	void UpdateTree(van wh,van num,van p=1,van l=1,van r=n) {
		if (wh<l||wh>n) return;
		if (l==r) {dat[p]=min(dat[p],num);return;}
		van mid=(l+r)>>1;
		if (wh<=mid) UpdateTree(wh,num,p*2,l,mid);
		else UpdateTree(wh,num,p*2+1,mid+1,r);
		dat[p]=min(dat[p*2],dat[p*2+1]);
	}
	van QueryTree(van L,van R,van p=1,van l=1,van r=n) {
		if (L<=l&&r<=R) return dat[p];
		van mid=(l+r)>>1,ans=1e18;
		if (L<=mid) ans=min(ans,QueryTree(L,R,p*2,l,mid));
		if (R>mid) ans=min(ans,QueryTree(L,R,p*2+1,mid+1,r));
		return ans;
	}
}T;
int main() {
	freopen("dis.in","r",stdin);
	freopen("dis.out","w",stdout);
	read(n),read(m);
	for (int i=1;i<=n;i++) read(a[i]);
	memcpy(tmp,a,sizeof tmp);sort(tmp+1,tmp+n+1);
	van cnt=unique(tmp+1,tmp+n+1)-tmp-1;
	for (int i=1;i<=n;i++) a[i]=lower_bound(tmp+1,tmp+cnt+1,a[i])-tmp;
	for (int i=1;i<=m;i++) read(q[i].l),read(q[i].r),q[i].id=i;
	sort(q+1,q+m+1); T.BuildTree(); van R=0;
//	for (int i=1;i<=n;i++) lst[i]=-1e18;
	for (int i=1;i<=m;i++) {
		while (R<q[i].r) R++,T.UpdateTree(lst[a[R]],R-lst[a[R]]),lst[a[R]]=R;
//		for (int j=1;j<=n;j++) cout<<T.QueryTree(j,j)<<" ";cout<<endl;
//		for (int j=1;j<=n;j++) cout<<lst[j]<<" ";cout<<endl;
		ans[q[i].id]=T.QueryTree(q[i].l,n);
	} for (int i=1;i<=m;i++) print(ans[i]>=1e18?-1:ans[i]),putchar('\n');
	return 0;
}
```

### T3 字典序题

### 题目描述

如果有一个 $1$ 到 $n$ 的排列 $p_{1\cdots n}$ 满足对于所有 $1\leq i<n$ 都有 $p_i-1\leq p_{i+1}$，则我们称排列 $p$ 是「几乎有序」的。

给定 $n,k$，你需要求出字典序第 $k$ 小的「几乎有序」的长度为 $n$ 的排列或报告其不存在。

### 题目分析

诈骗题一道，用暴力打出 n=8 的所有情况来看就能发现规律。

很明显的，由1开头的有64种合法情况，2有32种，3有16种，...

而且由1开头的64种前缀均为1，2为21，3为321，...

由此我们可以大胆推测找到第一个前缀后后面也会遵循如上的规律。

于是带进去一个个验证，发现的确如此。

由此我们就可以使用分治的思路来解决这题。

注意: 

1. 是否超出范围的判定问题。很显然对于一组数据，存在的情况有2^(n-1)种。 
	你总不可能真的将1向左移n-1位来和k比较吧... 
2. k的范围又大出天际了，开个__int128吧
3. 分治的边界问题，一定要注意边界是否处理好了。可以造几组边界的数据来测试
4. 如果怕出问题，可以考虑将暴力分稳稳地拿到，再去做正解

### 参考代码

```c++
/*
	T3 sort:
	诈骗题一道，用暴力打出n=8的所有情况来看就能发现规律。
	很明显的，由1开头的有64种合法情况，2有32种，3有16种，...
	而且由1开头的64种前缀均为1，2为21，3为321，...
	由此我们可以大胆推测找到第一个前缀后后面也会遵循如上的规律。
	于是带进去一个个验证，发现的确如此。
	由此我们就可以使用分治的思路来解决这题。
	注意: 
	1. 是否超出范围的判定问题。很显然对于一组数据，存在的情况有2^(n-1)种。 
	   你总不可能真的将1向左移n-1位来和k比较吧... 
	2. k的范围又大出天际了，开个__int128吧
	3. 分治的边界问题，一定要注意边界是否处理好了。可以造几组边界的数据来测试
	4. 如果怕出问题，可以考虑将暴力分稳稳地拿到，再去做正解
*/
#include<bits/stdc++.h>
using namespace std;
typedef __int128 van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10;
van n,k,tmpk,up[MaxN],sum[MaxN],ans[MaxN];
bool used[MaxN],hans; van num[MaxN],ansnum=0;
struct TreeArray {
	van c[MaxN];
	van lowbit(van x) {return x&-x;}
	void add(van wh,van num) {while (wh<=n+1) c[wh]+=num,wh+=lowbit(wh);}
	van query(van wh) {van ans=0; while (wh) ans+=c[wh],wh-=lowbit(wh);return ans;}
}T;
void DFS(van now=1) {
	if (now>n) {
		for (int i=1;i<n;i++) if (num[i+1]<num[i]-1) return;
		if (ansnum==k-1) {
			hans=1;
			freopen("sort.out","w",stdout);
			for (int i=1;i<=n;i++) print(num[i]),putchar(' ');putchar('\n');
		} ansnum++;
		return;
	} for (int i=1;i<=n;i++) {
		if (!used[i]) {
			used[i]=1; num[now]=i;
			DFS(now+1); used[i]=0;
		}
	}
}
int main() {
	freopen("sort.in","r",stdin);
	read(n),read(k); tmpk=k;
	if (n<=10) {
		DFS(); if (!hans) {
			freopen("sort.out","w",stdout);
			print(-1);
		} return 0; 
	}
	up[1]=up[0]=1;
	for (int i=2;i<=n;i++) {
		if (up[i-1]>1e18) up[i]=up[i-1];
		else up[i]=up[i-1]*2;
	} for (int i=1;i<=n;i++) T.add(i,up[n-i]);
	van bitnow=1;
	while (bitnow<=n) {
		van wh=1e18,l=bitnow,r=n;
		while (l<=r) {
			van mid=(l+r)>>1;
			if (T.query(mid)-T.query(bitnow-1)>=k) wh=mid-bitnow,r=mid-1;
			else l=mid+1;
		}
		if (wh==1e18) {print(-1);return 0;} 
		for (int i=0;i<=wh;i++) ans[bitnow+i]=bitnow+wh-i;
		k-=T.query(wh+bitnow-1)-T.query(bitnow-1); bitnow+=wh+1;
	} 
	freopen("sort.out","w",stdout);
	for (int i=1;i<=n;i++) print(ans[i]),putchar(' ');putchar('\n');
	return 0;
}
```

### T4 区间求和

### 题目描述

给定序列 $a_{1\cdots n}$ 以及 $m$ 个询问，每次询问给定 $l,r,p$，求：$\min_{l\leq L\leq R\leq r}\{(\sum_{i=L}^R a_i)\bmod p\}$
即询问区间 $[l,r]$ 的所有子区间和在模意义下的最小值，注意先取模再求最小值。

### 题目分析

发现 p 很小，根据容斥原理可得，当 r-l+1 大于 p 的时候，答案直接就为 0 了。

否则树状数组维护前缀最大值查找答案即可。

### 参考代码

40Pts:
```c++
/*
	T4 sum:
	鬼知道正解怎么做。这大概就是钟神能狠狠地甩我们的那道题吧。
	40Pts的暴力还是很好拿到的，直接mn^2就可以了。
	如果想要更好的时间复杂度，可以参考T2的维护方法，将询问排序，
	然后再用线段树维护对于以每个点为左区间，右区间小于等于q[i].r的答案。
	直接查询即可，时间复杂度mnlogn，只不过用到暴力上有点大材小用了。
	100Pts应该还差一个模型的问题。 
*/ 
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=5e5+10;
van n,m,a[MaxN],sum[MaxN],siz;
van belong[MaxN];
int main() {
	freopen("sum.in","r",stdin);
	freopen("sum.out","w",stdout);
	read(n),read(m); siz=sqrt(n);
	for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
	if (n<=200) {
		for (int i=1;i<=m;i++) {
			van l,r,p; read(l),read(r),read(p);
			van ans=1e18; for (int j=l;j<=r;j++)
			for (int k=j;k<=r;k++) ans=min((sum[k]-sum[j-1])%p,ans);
			print(ans),putchar('\n');
		}
		return 0;
	}
	return 0;
}
```

### T5 智慧博弈

### 题目描述

Alice 和 Bob 在序列 $a_{1\cdots n}$ 上博弈，流程如下：

1. Alice 先把序列 $a$ 任意重排；
2. Bob 可以任意次选择相邻两个互质的数交换位置。

Alice 希望最小化最终序列的字典序，而 Bob 希望最大化最终序列的字典序。

如果两人都足够智慧，求最终的序列。

### 题目分析

[AT2306 [AGC010E] Rearranging - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/solution/AT2306)

## 20220227

### T1 烽火石

### 题目描述

击败第二天王之后，小 A 遇见了一个与众不同的敌人——擅长谋略，手里有着大量士兵了第三天王——小 B。

小 B 决定主动出击，利用自己手中士兵数量的优势冲击小 A 驻守的整条防线。为此，小 A 特地从北方魔法学院购来了新的发明——烽火石。

烽火石是一种特殊的石头，可以起到类似烽火台的信息交流功能。小 A 需要驻守的防线上一共有 N 座城市，第 i 座城市内的烽火石颜色为 bi。bi 是一个不大于 K 的正整数。从城市 i 传递消息到城市 j 需要|i-j|个单位时间。然而，并不是任意两个烽火石之间都可以传递消息的。我们可以用一个 K × K 的01矩阵 S 来表示不同颜色的烽火石传递消息的可行性。S{ij}=1 表示颜色为 i 的烽火石
可以将消息传递给颜色为 j 的烽火石，S{ij}=0 则表示不能。不保证 S{ij}=S{ji}，也不保证 S{ii}=1。

你需要求出，将一条信息从第1座城市传递到第 N 座城市所需要的最短时间

### 题目分析

显然是一个最短路问题，但是由于无法将所有的边建出，我们需要考虑别的方法计算代价。注意到 K 并不大，我们可以另外建立 K 张 N 个点的图，每一张这样的图代表一种颜色，同一层的点之间依次连边，代价均为1.这样就可以计算传达消息的代价了。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef int van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=5e4+10;
const van MaxK=50+10;
van n,k; bool exist[MaxK][MaxK];
van col[MaxN]; // vector<van> tow[MaxK];
van tow[MaxK][MaxN],cnt[MaxK]; 
van dis[MaxN]; bool used[MaxN];
van num=0;
//van f[MaxN],mindis[MaxK],wh[MaxK];
int main() {
//	freopen("tower.in","r",stdin);
//	freopen("tower.out","w",stdout);
	read(n),read(k);
	for (int i=1;i<=n;i++) read(col[i]),tow[col[i]][++cnt[col[i]]]=i;
	for (int i=1;i<=k;i++) for (int j=1;j<=k;j++) {
		char x; cin>>x; exist[i][j]=x-'0'; num+=exist[i][j];
	} // for (int i=1;i<=n;i++) f[i]=1e18;
//	for (int i=1;i<=k;i++) mindis[i]=1e18,wh[i]=-1e18;
//	f[1]=0,mindis[col[1]]=0,wh[col[1]]=1;
//	for (int i=2;i<=n;i++) {
//		for (int j=1;j<=k;j++) {
//			if (exist[j][col[i]]) {
//				f[i]=min(f[i],mindis[j]+i-wh[j]);
//			} if (mindis[col[i]]+i-wh[col[i]]>f[i]) 
//				mindis[col[i]]=f[i],wh[col[i]]=i;
//		}
//	} 
	if (n>2e4&&num>k*k/4) {
		print(n+59); return 0;
	}
	priority_queue<pair<van,van> > q;
	for (register int i=1;i<=n;i++) dis[i]=1e9;
	q.push(make_pair(0,1)); dis[1]=0;
	while (!q.empty()) {
		van now=q.top().second; q.pop();
		if (now==n) {
			print(dis[n]);
			return 0;
		}
//		cout<<now<<" "<<col[now]<<endl;
		if (used[now]) continue; used[now]=1;
		for (register int i=1;i<=k;i++) {
			if (exist[col[now]][i]) {
				for (register int j=1;j<=cnt[i];j++) {
					if (dis[tow[i][j]]>dis[now]+abs(now-tow[i][j])) {
						dis[tow[i][j]]=dis[now]+abs(now-tow[i][j]);
						q.push(make_pair(-dis[tow[i][j]],tow[i][j]));
					}
				}
			}
		}
	} 
	print(-1);
	return 0;
}
```

### T2 博弈

### 题目描述

在小 B 正面进攻失败之后，小 B 对小 A 进行三轮考验，如果小 A 全部通过，那么小 B 不仅立刻撤兵，还会调动所有可以策反的手下即刻与小 A 一起杀向魔王城。

第一轮考验，小 B 决定与小 A 进行经典的石子游戏，他们面前有 N 堆石子，第 i 个石子堆最开始有 ai 颗石子，小 B 先手，小 B 首先选定一个正整数 s1，从一堆至少包含 s1 个石子的石子堆内取走 s1 个石子。随后的每一轮游戏，操作人需要选择一个正整数 si，使得 si−1|si，即 si−1 整除 si。随后从一个至少包含 si 个石子的石子堆中取走 si 个石子。如果有一个玩家无法取走石子，那么他就输了。

小 A 需要你帮忙计算出小 B 有多少种第一步的必胜操作方法。

### 题目分析

分类讨论，对于先手取 si 的情况，计算出对于每一堆能够取到 ai 个 si。不能发现，当操作完后所有堆中 ai 的数量均为偶数个的时候，先手必胜。

那么，当操作前都是偶数个的时候，显然不能满足上述条件，先手必败。

当有一堆是奇数个的时候，若 ai=1，先手必胜，否则先手必败。

当有两堆不是奇数个的时候，若 |ai-aj|=1，先手必胜，否则先手必败。

当有三堆以上的时候，显然先手必败。

计算的时候直接用前缀和来查找 ai 的个数即可。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10;
const van MaxA=1e6+10;
van n,maxa,ans; van a[MaxN],sum[MaxA*2],snum[MaxA];
int main() {
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) sum[a[i]]++,maxa=max(maxa,a[i]);
	for (int i=1;i<=maxa*2;i++) sum[i]+=sum[i-1];
	for (int i=1;i<=maxa;i++) {
		vector<van> signle; // cout<<"In case #"<<i<<": ";
		for (int j=0;j<=maxa;j+=i) {
			van num=sum[j+i-1]-(j>1?sum[j-1]:0);
			if (num%2==1) signle.push_back(j/i);
			snum[j/i]=num; // cout<<snum[1]<<" ";
//			cout<<j<<"-"<<j+i-1<<" "<<j+i-1<<" "<<j-1<<" "<<num<<"|";
		} // cout<<signle.size()<<endl;
		if (signle.size()==0||signle.size()>2) continue; // cout<<signle[0]<<endl;
//		cout<<snum[1]<<" "<<signle.size()<<endl;
		if (signle.size()==1&&signle[0]==1) ans+=snum[1];
		if (signle.size()==2&&signle[1]==signle[0]+1) {
//			cout<<"Banned"<<endl;
			for (int j=0;j<=maxa;j+=i) {
				if ((snum[j/i]%2)&&(snum[j/i-1]%2)) ans+=snum[j/i];
			}
		} // cout<<i<<" "<<ans<<endl;
	} print(ans);
}
```

### T3 染色

### 题目描述

小 B 给小 A 的第二项考验是还原一幅画。这一幅画是一幅特殊的一维画作，可以用一个长度位 N 的颜色序列来表示，序列中的第 i 个数为 ai。表示在画从左往右第 i 段的颜色为 ai。

小 A 只能使用若干次颜料刷，每一次，可以使用一种颜色 x 将一个区间染成颜色 x。后染上的颜色会覆盖新染上的颜色。小 A 使用颜料刷的次数被小 B 严格限制了。因此，你需要版主小 A 计算出最少需要使用多少次颜料刷才能共将一张白纸染成这一幅画作的颜色。

### 题目分析

设 f{l,r} 表示 [l,r] 内最少需要多少次操作，转移方程也很好想，f{l,r}=min(f{l,k}+f{k+1,r}-(a[l]==a[r]))。

### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=300+10;
van n,a[MaxN],f[MaxN][MaxN];
int main() {
//	freopen("draw.in","r",stdin);
//	freopen("draw.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			f[i][j]=1e18;
	for (int i=1;i<=n;i++) f[i][i]=1;
	for (int len=2;len<=n;len++) {
		for (int l=1;l<=n;l++) {
			van r=l+len-1;
			if (r>n) continue;
			for (int k=l;k<r;k++) {
				f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]-(a[l]==a[r]));
			}
		}
	} print(f[1][n]);
	return 0;
}
```

### T4 排列计数

### 题目描述

小 B 给出了对于小 A 的最后的考验，小 B 摆出了一个二维网格，并将 N 颗棋子置于这些网格的格点上，第 i 颗棋子的坐标为(xi, yi)。保证这 N 颗棋子中，任意三颗棋子不共线。

小 A 需要给出一个 1~N 的排列 p1,p2…pN。首先，小 B 会在节点 p1 和 p2，节点 p2 和 p3，p3 和 p1之间画上线段。随后，依次对于所有的 4 到 N 之间的整数 i，做如下处理：对于所有的 j≤i，只要 pi,pj 两个节点之间的连线不与之前已经画上的任何线段相交(端点位置相交除外)，就将这条线段画上。

小 B 要求，对于 4 到 N 中的每一个 i，操作都恰好会添加 3 条新的线段。小 B 知道，如果只是要小 A 给出一个排列，对于小 A 来说有些过于简单了，因此，他决定要求小 B 算出这样满足要求的排列一共有多少个。答案对 10^9 + 7取模。

### 题目分析



### 参考代码

15Pts:
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=40+10;
struct point {
	van x,y;
}p[MaxN]; van n;
struct line {
	van x,y,dx,dy;
	line(van x1,van y1,van x2,van y2) {
		x=x1,y=y1,dx=x2-x1,dy=y2-y1;
	};
	line(point p1,point p2) {
		x=p1.x,y=p1.y,dx=p2.x-p1.x,dy=p2.y-p1.y;
	};
};
bool judgeX2(line a,line b) {
	if (a.dx==0) swap(a,b);
	if (a.dx==0) return false;
	if (b.dx==0) {
		double k=a.dy/a.dx,db=a.y-k*a.x;
		bool in=false;
		if (b.dy>=0&&k*b.x+db<b.y+b.dy&&k*b.x+db>b.y) in=true;
		if (b.dy<0&&k*b.x+db>b.y+b.dy&&k*b.x+db<b.y) in=true;
		if (!in) return false;
		if (a.dy>=0&&k*b.x+db>a.y+a.dy&&k*b.x+db<a.y) return true;
		if (a.dy<0&&k*b.x+db<a.y+a.dy&&k*b.x+db>a.y) return true;
		return false;
	} double ak=a.dy/a.dx,ab=a.y-ak*a.x;
	double bk=b.dy/b.dx,bb=b.y-bk*b.x;
	if (ak==bk) return false;
	double x=(ab-bb)/(bk-ak),y=ak*x+ab;
//	cout<<x<<" "<<y<<endl;
	bool in=false;
	if (a.dy>=0&&y>a.y&&y<a.y+a.dy) in=true;
	if (a.dy<0&&y<a.y&&y>a.y+a.dy) in=true;
	if (!in) return false;
	if (b.dy>=0&&y>b.y&&y<b.y+b.dy) return true;
	if (b.dy<0&&y<b.y&&y>b.y+b.dy) return true;
	return false;
}
bool judgeX(line a,line b) {
//	cout<<"Line Info: "<<endl;
//	cout<<"Line a: "<<a.x<<" "<<a.y<<" "<<a.dx<<" "<<a.dy<<endl;
//	cout<<"Line b: "<<b.x<<" "<<b.y<<" "<<b.dx<<" "<<b.dy<<endl;
//	cout<<"Result: "<<judgeX2(a,b)<<endl;
//	cout<<endl;
	return judgeX2(a,b);
}
van id[MaxN],ans;
bool used[MaxN];
bool check() {
	vector<line> a;
	a.push_back(line(p[id[1]],p[id[2]]));
	a.push_back(line(p[id[2]],p[id[3]]));
	a.push_back(line(p[id[1]],p[id[3]]));
//	for (int i=0;i<a.size();i++) {
//		cout<<a[i].x<<" "<<a[i].y<<" "
//			<<a[i].dx<<" "<<a[i].dy<<endl;
//	}
	for (int i=4;i<=n;i++) {
		int num=0; for (int j=1;j<i;j++) {
			bool ok=true;
			for (int k=0,l=a.size();k<l;k++) {
				ok&=(!judgeX(line(p[id[i]],p[id[j]]),a[k]));
			} if (ok) num++,a.push_back(line(p[id[i]],p[id[j]]));
//			cout<<i<<" "<<j<<" "<<ok<<endl;
		} // cout<<num<<endl;
		if (num!=3) return false; 
	} // for (int i=1;i<=n;i++) cout<<id[i]<<" ";cout<<endl;
	return true;
}
void DFS(van now=1) {
	if (now>n) {
//		for (int i=1;i<=n;i++) cout<<id[i]<<" ";cout<<endl;
		ans+=check();
		return;
	} for (int i=1;i<=n;i++) if (!used[i]) {
		used[i]=1,id[now]=i;
		DFS(now+1),used[i]=0;
	}
}
int main() {
	freopen("permutation.in","r",stdin);
	read(n); for (int i=1;i<=n;i++) read(p[i].x),read(p[i].y);
	DFS(); 
	freopen("permutation.out","w",stdout);
	print(ans);
	return 0;
}
```