# 做题记录

## 模板记录

```md
## Tx 题目名称

### 题目描述

### 输入描述

### 输出描述

### 题目分析

### 参考代码
```

## Content

- [20220207 重庆育才2022寒假集训 选拔测试试题](#20220207)
	- [T1 社交距离(socdist)](#T1 社交距离)
	- [T2 路径(path)](#T2 路径)
	- [T3 倾斜的线(slope)](#T3 倾斜的线)
	- [T4 符文(runes)](#T4 符文)
	- [T5 购票(tickets)](#T5 购票)
- [20220210 重庆市育才中学2022年 寒假联合模拟 Round 3](#20220210)
	- [T1 商贸(trade)](#T1 商贸)
	- [T2 部队集结(gather)](#T2 部队集结)
	- [T3 虫群扩张(proliferate)](#T3 虫群扩张)
	- [T4 推演(calc)](#T4 推演)
- [20220212 重庆市育才中学2022年 寒假联合模拟 Round 4](#20220212)
	- [T1 魔法阵(magic)](#T1 魔法阵)
	- [T2 区域侦测(detect)](#T2 区域侦测)
	- [T3 加固(reinforce)](#T3 加固)
	- [T4 斩首行动(assassinate)](#T4 斩首行动)
- [20220219 重庆市育才中学2022年 联合模拟](#20220219)
	- [T1 photo](#T1 photo)
	- [T2 swap](#T2 swap)
	- [T3 tree](#T3 tree)
	- [T4 rabbit](#T4 rabbit)
	- [T5 ball](#T5 ball)
- [20220226 重庆市育才中学2022年 联合模拟](#20220226)
	- [T1 输出练习(output)](#T1 输出练习)
	- [T2 最近距离(dis)](#T2 最近距离)
	- [T3 字典序题(sort)](#T3 字典序题)
	- [T4 区间求和(sum)](#T4 区间求和)
	- [T5 智慧博弈(game)](#T5 智慧博弈)
- [20220227 重庆市育才中学2022年 寒假联合模拟 Round 5](#20220227)
	- [T1 烽火石(tower)](#T1 烽火石)
	- [T2 博弈(game)](#T2 博弈)
	- [T3 染色(draw)](#T3 染色)
	- [T4 排列计数(permutation)](#T4 排列计数)
	
## 20220207 

### T1 社交距离

### 题目描述

一种可怕的新疾病 COVID-19 已开始在世界各地传播。人们试图采取尽可能多的预防措施以保护自己免受感染，其中有一项就是增加人与人之间的“社交距离”。

现在考虑这样的一个问题：在火车站的候车厅有一排狭窄的座位，连续 N 个座位在一条直线上。 这些座位中有一些目前被人占据，有些空着。 在了解了“社交距离”D的重要性之后，后来的人都希望最大化 D，其中 D 是最近的两个被占用的座位之间的距离。 例如，如果座位 3 和 8 是最接近的座位，则 D = 5。

最近有一个新的乘客来了想找位子坐下，他需要确定应该坐哪个以前空置的座位，以使 D 的最终值仍尽可能大。注意：已经坐下来的乘客不能动。

### 输入描述

输入的第一行包含一个整数 N，表示一排上连续座位的个数。

第二行包含长度 N，分别为 0 和 1 的字符串，描述了 N 个座位中的占用情况，0 表示空座位，1 表示已被占用。

### 输出描述

为了问题简单化，该字符串至少有一个 0，因此至少有座位让新来的乘客落座，也至少有一个 1。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
char state[MaxN];van max_=-1e18,min_=1e18;
van ans=0;
int main() {
	freopen("socdist.in","r",stdin);
	freopen("socdist.out","w",stdout);
	van n;cin>>n; van lst=-1,st=-1;
	for (int i=1;i<=n;i++) cin>>state[i];
	for (int i=1;i<=n;i++) {
		if (state[i]=='1') {
			if (lst==-1){lst=i;st=i;continue;}
			max_=max(i-lst,max_);
			min_=min(min_,i-lst);
			lst=i;
		}
	} ans=max(min(min_,n-lst),min(min_,st-1));
	ans=max(ans,min(min_,max_/2)); print(ans);
	return 0;
}

```

### T2 路径

### 题目描述

给出一棵n个节点的树，节点编号为1~n（根节点编号为1）。对于每一个叶子节点，输出从根到叶子的路径。

注意：按照路径的字典序从小到大输出。

### 输入描述

第一行：1个数n，表示树的节点数量。

后面n-1行：每行2个数x y，表示节点x是节点y的父节点。

### 输出描述

输出行数等于叶子节点的数量，每行对应从根到叶子节点的路径。路径中的数字为经过节点的编号。按照路径的字典序从小到大输出。

### 题目分析

### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
van n; vector<van> g[MaxN];
van st[MaxN],top=-1;
void DFS(van now=1) {
	st[++top]=now;
	if (g[now].size()==0) {
		for (int i=0;i<=top;i++) 
			print(st[i]),putchar(' ');
		putchar('\n'); top--;
		return;
	} for (int i=0;i<g[now].size();i++)
		DFS(g[now][i]); top--;
}
int main() {
	freopen("path.in","r",stdin);
	freopen("path.out","w",stdout);
	n=read(); for (int i=1;i<n;i++) {
		van f=read(),s=read();
		g[f].push_back(s);
	} for (int i=1;i<=n;i++) sort(g[i].begin(),g[i].end());
	DFS();
	return 0;
}

```

### T3 倾斜的线

### 题目描述

给定两个正整数 P 和 Q。在二维平面上有 n 个整点。现在请你找到一对点使得经过它们的直线的斜率在数值上最接近 P/Q（即这条直线的斜率与 P/Q 的差最小），请输出经过它们直线的斜率 p/q。如果有两组点的斜率的接近程度相同，请输出较小的斜率。

保证答案的 p/q > 0，即输出的 p 和 q 都是正整数。

### 输入描述

第一行三个正整数 n P Q。

接下来 n 行每行两个正整数 x y 表示一个点的坐标。保证不存在 x 坐标相同或者 y坐标相同的点（即斜率不会为无穷大与 0）

### 输出描述

输出仅一行，格式为 p/q，表示最接近的斜率，其中 p 和 q 都是正整数

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef __int128 van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
template<typename T> inline
T abs(T x) {return x<0?-x:x;}
const van MaxN=2e5+10;
van n,P,Q,ansp=1,ansq=-1,id;
struct point {
	van x,y;
	point(){};
	point(van x,van y):x(x),y(y){};
	bool operator < (const point& a) const {
		if (x==a.x) return y<a.y;
		return x<a.x; 
	}
}p[MaxN];
struct point2 {
	van x,y,id;
	point2(){};
	point2(van x,van y,van id):x(x),y(y),id(id){};
	bool operator < (const point2& a) const {
		if (y==a.y) return x<a.x;
		return y<a.y; 
	}
}p2[MaxN];
bool judge2(van p1,van q1,van p2,van q2) {
	return p1*q2<p2*q1;
}
void SubTask2() {
	for (int i=1;i<=n;i++) p2[i]=point2(p[i].x,p[i].y*Q-p[i].x*P,i);
	sort(p2+1,p2+n+1); for (int i=1;i<=n-1;i++) {
		van a=i,b=i+1;
		van ansp1=abs(p2[a].y-p2[b].y),ansq1=abs(p2[a].x-p2[b].x);
		if (id==0) ansp=ansp1,ansq=ansq1,id=i;
		else if (judge2(ansp1,ansq1,ansp,ansq)) ansp=ansp1,ansq=ansq1,id=i;
	} van a=p2[id].id,b=p2[id+1].id;
	van resp=abs(p[a].y-p[b].y),resq=abs(p[a].x-p[b].x);
	van gcd=__gcd(resp,resq);resp/=gcd,resq/=gcd;
	print(resp),putchar('/'),print(resq);
}
int main() {
	freopen("slope.in","r",stdin);
	freopen("slope.out","w",stdout);
	n=read(),P=read(),Q=read(); 
	for (int i=1;i<=n;i++) {
		van x=read(),y=read();
		p[i]=point(x,y);
	}
	SubTask2();
	return 0;
}
```

### T4 符文

### 题目描述

给定一个长度为 |s| 的符文串 s 和一个长度为 |p| 的符文串 p ，定义符文的等级r(s,p) 表示符文串 s 中最多有多少个互不重叠的子串 p 。

现在你可以在任意位置删除任意个符文。

你需要算出在删除 i (0≤i≤|s|)个符文后得到的符文串ti的r(ti,p)。

### 输入描述

第一行是符文串s。

第二行是符文串p。

### 输出描述

输出(|s|+1)个数，第i个数表示删除i-1个符文后得到的符文串ti-1的r(ti-1,p)。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;
	char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;
	return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {
		putchar('0');
		return;
	}
	van st[41]= {0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k; i; i--) putchar('0'+st[i]);
}
const van MaxN=2e3+10;
const van MaxM=5e2+10;
string s,p;
van f[MaxN][MaxN];
van w[MaxN];
int main() {
	freopen("runes.in","r",stdin);
	freopen("runes.out","w",stdout);
	cin>>s>>p;
	van n=s.size(),m=p.size();
	memset(w,-1,sizeof w);
	for (int i=0; i<n; i++) {
		van k=0;
		for (int j=i; j<n; j++) {
			if (s[j]==p[k]) k++;
			if (k==p.size()) {
				w[i+1]=j-i+1;
				break;
			}
		}
	}
	memset(f,-1,sizeof f);
	f[0][0]=0;
	for (int i=1; i<=n; i++) {
		for (int j=0; j<=i; j++) {
			f[i][j]=max(f[i][j],f[i-1][j]);
			f[i][j+1]=max(f[i][j+1],f[i-1][j]);
			if (w[i]!=-1)
				f[i+w[i]-1][j+w[i]-m]=max(f[i+w[i]-1][j+w[i]-m],f[i-1][j]+1);
		}
	}
	for (int i=0; i<=n; i++) print(f[n][i]),putchar(' ');
	return 0;
}
```

### T5 购票

### 题目描述

旅行的路线由编号为 1…N（1≤N≤10^5）的 N 个检查点组成。有 K（1≤K≤10^5）张票可供购买。第 i 张票可以在检查站 ci（1≤ci≤N）以 pi（1≤pi≤10^9）的价格购得，并且可以用其进入所有检查站 [ai,bi]（1≤ai≤bi≤N）。在进入任何检查站之前，必须已购买一张允许其进入该检查站的票。一旦可以前往某一检查站，就可以在未来的任何时候回到该检查站。对于每一个 i∈[1,N]，如果最初只能进入检查点 i，输出使得可以进入检查点 1 和 N 所需的最低总价。如果无法这样做，输出 −1

### 输入描述

输入的第一行包含 N 和 K。

以下 K行，对于每一个 1≤i≤K，第 i 行包含四个整数 ci，pi，ai 和 bi

### 输出描述

输出 N行，每行输出一个检查点的答案。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
struct ticket{
	van p,c,a,b;
	ticket(){};
	ticket(van p,van c,van a,van b):p(p),c(c),a(a),b(b){};
}t[MaxN];
struct Edge {
	van u,v,w;
	Edge(van u,van v,van w):u(u),v(v),w(w){};
};
van n,k; van id[MaxN];
vector<Edge> g[MaxN*6];

void Connect(van from,van to,van w) {
	g[from].push_back(Edge(from,to,w));
}
void BuildTree(van p=1,van l=1,van r=n) {
	if (l==r) {id[l]=p;return;} van mid=(l+r)>>1;
	Connect(p*2,p,0); Connect(p*2+1,p,0);
	BuildTree(p*2,l,mid); BuildTree(p*2+1,mid+1,r);
} 
void Update(van L,van R,van from,van p=1,van l=1,van r=n) {
	if (L<=l&&r<=R) {
		Connect(p,from,0);
		return;
	} van mid=(l+r)>>1;
	if (L<=mid) Update(L,R,from,p*2,l,mid);
	if (R>mid) Update(L,R,from,p*2+1,mid+1,r);
}
struct state {
	van dis,id;
	state(van dis,van id):dis(dis),id(id){};
	bool operator < (const state& a) const {
		return dis>a.dis;
	}
}; priority_queue<state> q;
van dis[MaxN*6]; bool used[MaxN*6];
van dis1[MaxN*6],dis2[MaxN*6];
void Dijkstra(van st,bool ahhh=true) {
	memset(used,0,sizeof used);
	for (int i=1;i<=5*n+k;i++) dis[i]=1e18;
	if (ahhh) dis[st]=0,q.push(state(dis[st],st));
	else {
		memcpy(dis,dis1,sizeof dis);
		for (int i=1;i<=5*n+k;i++) q.push(state(dis[i],i));
	}
	while (!q.empty()) {
		van now=q.top().id; q.pop();
		if (used[now]) continue; used[now]=1;
		for (int i=0;i<g[now].size();i++) {
			Edge e=g[now][i];
			if (dis[e.v]>dis[now]+e.w) {
				dis[e.v]=dis[now]+e.w;
				q.push(state(dis[e.v],e.v));
			}
		}
	}
}
int main() {
	n=read(),k=read(); BuildTree();
	for (int i=1;i<=k;i++) {
		van p=read(),c=read(),a=read(),b=read();
		t[i]=ticket(p,c,a,b);
		Update(a,b,4*n+i);
		Connect(4*n+i,id[p],c);
	} Dijkstra(id[1]); memcpy(dis1,dis,sizeof dis1);
	Dijkstra(id[n]); for (int i=1;i<=n*5+k;i++) dis1[i]+=dis[i];
	Dijkstra(0,false); for (int i=1;i<=n;i++)
		print(dis[id[i]]>=1e18?-1:dis[id[i]]),putchar('\n');
	return 0;
}
```

## 20220210

### T1 商贸

### 题目描述

勇者小𝐴通过寻宝提升自己的实力之后仍然无法战胜虫群，他终于意识到了一个人的力量终究时有极限的，因此，他决定开始招兵买马，然而，一个很现实的问题摆在他的面前——他没有钱。所幸他现在所在的国家是一个商贸非常发达的商业共和国，他可以从中跑商赚钱。共和国内有𝑁座城市，编号为1,2,3 … 𝑁。由𝑀条单向的道路连接。小𝐴每一次到达城市𝑖都可以获得𝑚𝑖的收益。小𝐴最开始位于城市1，最后也必须回到编号为1的城市。不过身为勇者的小𝐴的时间是非常宝贵的，沿着一条道路从一座城市到达另一座城市需要花费一天的时间。为了量化小𝐴花费时间贸易的代价，我们认为小𝐴花费𝑇时间贸易的成本为𝐶 × 𝑇^2。

你需要计算出小𝐴可能得到的最高收益。

### 输入描述

第一行输入三个正整数𝑁, 𝑀, 𝐶(2 ≤ 𝑁 ≤ 1000,1 ≤ 𝑀 ≤ 2000,1 ≤ 𝐶 ≤ 1000)，含义见题面。输入的第二行包括𝑁个整数，第𝑖个整数即为𝑚𝑖(0 ≤ 𝑚𝑖 ≤ 1000)。为了避免争议，我们保证𝑚1 = 0。

接下来的𝑀行，每行包含两个用空格隔开的正整数𝑎, 𝑏(𝑎 ≠ 𝑏)，表示一条从城市𝑎到城市𝑏的单向通道。

### 输出描述

输出一行，表示小𝐴通过贸易可以获得的最大收益。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
van n,k;
const van MaxN=1e3+10;
vector<van> g[MaxN];
bool used[MaxN];
van f[MaxN][MaxN],c,w[MaxN];
int main() {
	freopen("trade.in","r",stdin);
	freopen("trade.out","w",stdout);
	read(n),read(k),read(c);
	for (int i=1;i<=n;i++) read(w[i]);
	for (int i=1;i<=k;i++) {
		van f,s; read(f),read(s);
		g[f].push_back(s);
	} for (int i=1;i<=n;i++) {
		for (int j=0;j<=1000;j++) {
			f[i][j]=-1e18;
		}
	} f[1][0]=0;
	for (int i=1;i<=1000;i++) {
		for (int j=1;j<=n;j++) {
			for (int k=0;k<g[j].size();k++) {
				van e=g[j][k];
				f[e][i]=max(f[e][i],f[j][i-1]+w[e]);
			}
		}
	} van ans=0;
	for (int i=0;i<=1000;i++)
		ans=max(f[1][i]-c*i*i,ans);
	print(ans);
	return 0;
}
```

### T2 部队集结

### 题目描述

小𝐴需要集结他的部队。通过使用钞能力，小𝐴已经招募到了𝑁名常年游走于刀剑之上的老练雇佣兵，现在，他们拍成一列，编号从1到𝑁，正在接受小𝐴的检阅。

小𝐴也需要将这𝑁名雇佣兵分成小队行动，但是，领队的选择成为了打问题。具体来说，小𝐴只能够选择一个连续的编号区间[𝑙, 𝑟]作为小队行动，所有编号𝑙 ≤ 𝑖 ≤ 𝑟的雇佣兵𝑖会加入小队，雇佣兵𝑙, 𝑟会作为领队。然而，不同的雇佣兵有自己的技术倾向，具体来说，我们可以使用数字𝑏𝑖来描述编号为𝑖的雇佣兵的技术倾向，如果队长的技术倾向与队内的其他成员(包括另一位队长)相同，那么这个队伍就无法和睦相处。

你的任务是帮助小𝐴计算出有多少个区间可以划分出一个和睦相处的小队。

### 输入描述

输入的第一行包括一个整数𝑁(1 ≤ 𝑁 ≤ 2 × 10^5)。含义见题面。
第二行包含𝑁个整数𝑏1, 𝑏2, 𝑏3 … 𝑏𝑁(1 ≤ 𝑏𝑖 ≤ 𝑁)。含义见题面。

### 输出描述

输出一行一个正整数表示可以划分出和睦相处小队的区间的数目。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=2e5+10;
van n,a[MaxN]; vector<van> waited_delete[MaxN];
van nxt[MaxN],pre[MaxN],now[MaxN],ans=0;
struct SegmentTree {
	van dat[MaxN<<2];
	void UpdateTree(van wh,van num,van p=1,van l=1,van r=n) {
		if (l==r) {dat[p]+=num;return;}
		van mid=(l+r)>>1;
		if (wh<=mid) UpdateTree(wh,num,p*2,l,mid);
		else UpdateTree(wh,num,p*2+1,mid+1,r);
		dat[p]=dat[p*2]+dat[p*2+1];
	}
	van QueryTree(van L,van R,van p=1,van l=1,van r=n) {
		if (L<=l&&r<=R) return dat[p];
		van sum=0,mid=(l+r)>>1;
		if (L<=mid) sum+=QueryTree(L,R,p*2,l,mid);
		if (R>mid) sum+=QueryTree(L,R,p*2+1,mid+1,r);
		return sum;
	}
}T;
int main() {
	freopen("gather.in","r",stdin);
	freopen("gather.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) 
		pre[i]=now[a[i]],nxt[now[a[i]]]=i,now[a[i]]=i;
	for (int i=1;i<=n;i++) if (nxt[i]==0) nxt[i]=n+1;
	for (int i=n;i;i--) {
		for (int j=0;j<waited_delete[i].size();j++) {
			van id=waited_delete[i][j];
			T.UpdateTree(id,-1);
		} ans+=T.QueryTree(i+1,nxt[i]-1); // cout<<i<<" "<<T.QueryTree(i+1,nxt[i]-1)<<endl;
		T.UpdateTree(i,1); waited_delete[pre[i]].push_back(i);
	} print(ans);
	return 0;
}
```

### T3 虫群扩张

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T4 推演

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

## 20220212

### T1 魔法阵

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T2 区域侦测

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T3 加固

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T4 斩首行动

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

## 20220219

### T1 photo

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T2 swap

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T3 tree

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T4 rabbit

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T5 ball

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

## 20220226

### T1 输出练习

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T2 最近距离

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T3 字典序题

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T4 区间求和

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T5 智慧博弈

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

## 20220227

### T1 烽火石

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T2 博弈

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T3 染色

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T4 排列计数

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码