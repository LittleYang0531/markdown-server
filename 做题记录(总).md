# 做题记录

## 模板记录

```md
## Tx 题目名称

### 题目描述

### 输入描述

### 输出描述

### 题目分析

### 参考代码
```

## Content

- [20220207 重庆育才2022寒假集训 选拔测试试题](#20220207)
	- [T1 社交距离(socdist)](#T1 社交距离)
	- [T2 路径(path)](#T2 路径)
	- [T3 倾斜的线(slope)](#T3 倾斜的线)
	- [T4 符文(runes)](#T4 符文)
	- [T5 购票(tickets)](#T5 购票)
- [20220210 重庆市育才中学2022年 寒假联合模拟 Round 3](#20220210)
	- [T1 商贸(trade)](#T1 商贸)
	- [T2 部队集结(gather)](#T2 部队集结)
	- [T3 虫群扩张(proliferate)](#T3 虫群扩张)
	- [T4 推演(calc)](#T4 推演)
- [20220212 重庆市育才中学2022年 寒假联合模拟 Round 4](#20220212)
	- [T1 魔法阵(magic)](#T1 魔法阵)
	- [T2 区域侦测(detect)](#T2 区域侦测)
	- [T3 加固(reinforce)](#T3 加固)
	- [T4 斩首行动(assassinate)](#T4 斩首行动)
- [20220219 重庆市育才中学2022年 联合模拟](#20220219)
	- [T1 photo](#T1 photo)
	- [T2 swap](#T2 swap)
	- [T3 tree](#T3 tree)
	- [T4 rabbit](#T4 rabbit)
	- [T5 ball](#T5 ball)
- [20220226 重庆市育才中学2022年 联合模拟](#20220226)
	- [T1 输出练习(output)](#T1 输出练习)
	- [T2 最近距离(dis)](#T2 最近距离)
	- [T3 字典序题(sort)](#T3 字典序题)
	- [T4 区间求和(sum)](#T4 区间求和)
	- [T5 智慧博弈(game)](#T5 智慧博弈)
- [20220227 重庆市育才中学2022年 寒假联合模拟 Round 5](#20220227)
	- [T1 烽火石(tower)](#T1 烽火石)
	- [T2 博弈(game)](#T2 博弈)
	- [T3 染色(draw)](#T3 染色)
	- [T4 排列计数(permutation)](#T4 排列计数)
	
## 20220207 

### T1 社交距离

### 题目描述

一种可怕的新疾病 COVID-19 已开始在世界各地传播。人们试图采取尽可能多的预防措施以保护自己免受感染，其中有一项就是增加人与人之间的“社交距离”。

现在考虑这样的一个问题：在火车站的候车厅有一排狭窄的座位，连续 N 个座位在一条直线上。 这些座位中有一些目前被人占据，有些空着。 在了解了“社交距离”D的重要性之后，后来的人都希望最大化 D，其中 D 是最近的两个被占用的座位之间的距离。 例如，如果座位 3 和 8 是最接近的座位，则 D = 5。

最近有一个新的乘客来了想找位子坐下，他需要确定应该坐哪个以前空置的座位，以使 D 的最终值仍尽可能大。注意：已经坐下来的乘客不能动。

### 输入描述

输入的第一行包含一个整数 N，表示一排上连续座位的个数。

第二行包含长度 N，分别为 0 和 1 的字符串，描述了 N 个座位中的占用情况，0 表示空座位，1 表示已被占用。

### 输出描述

为了问题简单化，该字符串至少有一个 0，因此至少有座位让新来的乘客落座，也至少有一个 1。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
char state[MaxN];van max_=-1e18,min_=1e18;
van ans=0;
int main() {
	freopen("socdist.in","r",stdin);
	freopen("socdist.out","w",stdout);
	van n;cin>>n; van lst=-1,st=-1;
	for (int i=1;i<=n;i++) cin>>state[i];
	for (int i=1;i<=n;i++) {
		if (state[i]=='1') {
			if (lst==-1){lst=i;st=i;continue;}
			max_=max(i-lst,max_);
			min_=min(min_,i-lst);
			lst=i;
		}
	} ans=max(min(min_,n-lst),min(min_,st-1));
	ans=max(ans,min(min_,max_/2)); print(ans);
	return 0;
}

```

### T2 路径

### 题目描述

给出一棵n个节点的树，节点编号为1~n（根节点编号为1）。对于每一个叶子节点，输出从根到叶子的路径。

注意：按照路径的字典序从小到大输出。

### 输入描述

第一行：1个数n，表示树的节点数量。

后面n-1行：每行2个数x y，表示节点x是节点y的父节点。

### 输出描述

输出行数等于叶子节点的数量，每行对应从根到叶子节点的路径。路径中的数字为经过节点的编号。按照路径的字典序从小到大输出。

### 题目分析

### 参考代码

### T3 倾斜的线

### T4 符文

### T5 购票

## 20220210

### T1 商贸

### T2 部队集结

### T3 虫群扩张

### T4 推演

## 20220212

### T1 魔法阵

### T2 区域侦测

### T3 加固

### T4 斩首行动

## 20220219

### T1 photo

### T2 swap

### T3 tree

### T4 rabbit

### T5 ball

## 20220226

### T1 输出练习

### T2 最近距离

### T3 字典序题

### T4 区间求和

### T5 智慧博弈

## 20220227

### T1 烽火石

### T2 博弈

### T3 染色

### T4 排列计数