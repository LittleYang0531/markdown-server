# 做题记录

## 模板记录

```md
## Tx 题目名称

### 题目描述

### 输入描述

### 输出描述

### 题目分析

### 参考代码
```

## Content

- [20220207 重庆育才2022寒假集训 选拔测试试题](#20220207)
	- [T1 社交距离(socdist)](#T1 社交距离)
	- [T2 路径(path)](#T2 路径)
	- [T3 倾斜的线(slope)](#T3 倾斜的线)
	- [T4 符文(runes)](#T4 符文)
	- [T5 购票(tickets)](#T5 购票)
- [20220210 重庆市育才中学2022年 寒假联合模拟 Round 3](#20220210)
	- [T1 商贸(trade)](#T1 商贸)
	- [T2 部队集结(gather)](#T2 部队集结)
	- [T3 虫群扩张(proliferate)](#T3 虫群扩张)
	- [T4 推演(calc)](#T4 推演)
- [20220212 重庆市育才中学2022年 寒假联合模拟 Round 4](#20220212)
	- [T1 魔法阵(magic)](#T1 魔法阵)
	- [T2 区域侦测(detect)](#T2 区域侦测)
	- [T3 加固(reinforce)](#T3 加固)
	- [T4 斩首行动(assassinate)](#T4 斩首行动)
- [20220219 重庆市育才中学2022年 联合模拟](#20220219)
	- [T1 photo](#T1 photo)
	- [T2 swap](#T2 swap)
	- [T3 tree](#T3 tree)
	- [T4 rabbit](#T4 rabbit)
	- [T5 ball](#T5 ball)
- [20220226 重庆市育才中学2022年 联合模拟](#20220226)
	- [T1 输出练习(output)](#T1 输出练习)
	- [T2 最近距离(dis)](#T2 最近距离)
	- [T3 字典序题(sort)](#T3 字典序题)
	- [T4 区间求和(sum)](#T4 区间求和)
	- [T5 智慧博弈(game)](#T5 智慧博弈)
- [20220227 重庆市育才中学2022年 寒假联合模拟 Round 5](#20220227)
	- [T1 烽火石(tower)](#T1 烽火石)
	- [T2 博弈(game)](#T2 博弈)
	- [T3 染色(draw)](#T3 染色)
	- [T4 排列计数(permutation)](#T4 排列计数)
	
## 20220207 

### T1 社交距离

### 题目描述

一种可怕的新疾病 COVID-19 已开始在世界各地传播。人们试图采取尽可能多的预防措施以保护自己免受感染，其中有一项就是增加人与人之间的“社交距离”。

现在考虑这样的一个问题：在火车站的候车厅有一排狭窄的座位，连续 N 个座位在一条直线上。 这些座位中有一些目前被人占据，有些空着。 在了解了“社交距离”D的重要性之后，后来的人都希望最大化 D，其中 D 是最近的两个被占用的座位之间的距离。 例如，如果座位 3 和 8 是最接近的座位，则 D = 5。

最近有一个新的乘客来了想找位子坐下，他需要确定应该坐哪个以前空置的座位，以使 D 的最终值仍尽可能大。注意：已经坐下来的乘客不能动。

### 输入描述

输入的第一行包含一个整数 N，表示一排上连续座位的个数。

第二行包含长度 N，分别为 0 和 1 的字符串，描述了 N 个座位中的占用情况，0 表示空座位，1 表示已被占用。

### 输出描述

为了问题简单化，该字符串至少有一个 0，因此至少有座位让新来的乘客落座，也至少有一个 1。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
char state[MaxN];van max_=-1e18,min_=1e18;
van ans=0;
int main() {
	freopen("socdist.in","r",stdin);
	freopen("socdist.out","w",stdout);
	van n;cin>>n; van lst=-1,st=-1;
	for (int i=1;i<=n;i++) cin>>state[i];
	for (int i=1;i<=n;i++) {
		if (state[i]=='1') {
			if (lst==-1){lst=i;st=i;continue;}
			max_=max(i-lst,max_);
			min_=min(min_,i-lst);
			lst=i;
		}
	} ans=max(min(min_,n-lst),min(min_,st-1));
	ans=max(ans,min(min_,max_/2)); print(ans);
	return 0;
}

```

### T2 路径

### 题目描述

给出一棵n个节点的树，节点编号为1~n（根节点编号为1）。对于每一个叶子节点，输出从根到叶子的路径。

注意：按照路径的字典序从小到大输出。

### 输入描述

第一行：1个数n，表示树的节点数量。

后面n-1行：每行2个数x y，表示节点x是节点y的父节点。

### 输出描述

输出行数等于叶子节点的数量，每行对应从根到叶子节点的路径。路径中的数字为经过节点的编号。按照路径的字典序从小到大输出。

### 题目分析

### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
van n; vector<van> g[MaxN];
van st[MaxN],top=-1;
void DFS(van now=1) {
	st[++top]=now;
	if (g[now].size()==0) {
		for (int i=0;i<=top;i++) 
			print(st[i]),putchar(' ');
		putchar('\n'); top--;
		return;
	} for (int i=0;i<g[now].size();i++)
		DFS(g[now][i]); top--;
}
int main() {
	freopen("path.in","r",stdin);
	freopen("path.out","w",stdout);
	n=read(); for (int i=1;i<n;i++) {
		van f=read(),s=read();
		g[f].push_back(s);
	} for (int i=1;i<=n;i++) sort(g[i].begin(),g[i].end());
	DFS();
	return 0;
}

```

### T3 倾斜的线

### 题目描述

给定两个正整数 P 和 Q。在二维平面上有 n 个整点。现在请你找到一对点使得经过它们的直线的斜率在数值上最接近 P/Q（即这条直线的斜率与 P/Q 的差最小），请输出经过它们直线的斜率 p/q。如果有两组点的斜率的接近程度相同，请输出较小的斜率。

保证答案的 p/q > 0，即输出的 p 和 q 都是正整数。

### 输入描述

第一行三个正整数 n P Q。

接下来 n 行每行两个正整数 x y 表示一个点的坐标。保证不存在 x 坐标相同或者 y坐标相同的点（即斜率不会为无穷大与 0）

### 输出描述

输出仅一行，格式为 p/q，表示最接近的斜率，其中 p 和 q 都是正整数

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef __int128 van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
template<typename T> inline
T abs(T x) {return x<0?-x:x;}
const van MaxN=2e5+10;
van n,P,Q,ansp=1,ansq=-1,id;
struct point {
	van x,y;
	point(){};
	point(van x,van y):x(x),y(y){};
	bool operator < (const point& a) const {
		if (x==a.x) return y<a.y;
		return x<a.x; 
	}
}p[MaxN];
struct point2 {
	van x,y,id;
	point2(){};
	point2(van x,van y,van id):x(x),y(y),id(id){};
	bool operator < (const point2& a) const {
		if (y==a.y) return x<a.x;
		return y<a.y; 
	}
}p2[MaxN];
bool judge2(van p1,van q1,van p2,van q2) {
	return p1*q2<p2*q1;
}
void SubTask2() {
	for (int i=1;i<=n;i++) p2[i]=point2(p[i].x,p[i].y*Q-p[i].x*P,i);
	sort(p2+1,p2+n+1); for (int i=1;i<=n-1;i++) {
		van a=i,b=i+1;
		van ansp1=abs(p2[a].y-p2[b].y),ansq1=abs(p2[a].x-p2[b].x);
		if (id==0) ansp=ansp1,ansq=ansq1,id=i;
		else if (judge2(ansp1,ansq1,ansp,ansq)) ansp=ansp1,ansq=ansq1,id=i;
	} van a=p2[id].id,b=p2[id+1].id;
	van resp=abs(p[a].y-p[b].y),resq=abs(p[a].x-p[b].x);
	van gcd=__gcd(resp,resq);resp/=gcd,resq/=gcd;
	print(resp),putchar('/'),print(resq);
}
int main() {
	freopen("slope.in","r",stdin);
	freopen("slope.out","w",stdout);
	n=read(),P=read(),Q=read(); 
	for (int i=1;i<=n;i++) {
		van x=read(),y=read();
		p[i]=point(x,y);
	}
	SubTask2();
	return 0;
}
```

### T4 符文

### 题目描述

给定一个长度为 |s| 的符文串 s 和一个长度为 |p| 的符文串 p ，定义符文的等级r(s,p) 表示符文串 s 中最多有多少个互不重叠的子串 p 。

现在你可以在任意位置删除任意个符文。

你需要算出在删除 i (0≤i≤|s|)个符文后得到的符文串ti的r(ti,p)。

### 输入描述

第一行是符文串s。

第二行是符文串p。

### 输出描述

输出(|s|+1)个数，第i个数表示删除i-1个符文后得到的符文串ti-1的r(ti-1,p)。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;
	char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;
	return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {
		putchar('0');
		return;
	}
	van st[41]= {0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k; i; i--) putchar('0'+st[i]);
}
const van MaxN=2e3+10;
const van MaxM=5e2+10;
string s,p;
van f[MaxN][MaxN];
van w[MaxN];
int main() {
	freopen("runes.in","r",stdin);
	freopen("runes.out","w",stdout);
	cin>>s>>p;
	van n=s.size(),m=p.size();
	memset(w,-1,sizeof w);
	for (int i=0; i<n; i++) {
		van k=0;
		for (int j=i; j<n; j++) {
			if (s[j]==p[k]) k++;
			if (k==p.size()) {
				w[i+1]=j-i+1;
				break;
			}
		}
	}
	memset(f,-1,sizeof f);
	f[0][0]=0;
	for (int i=1; i<=n; i++) {
		for (int j=0; j<=i; j++) {
			f[i][j]=max(f[i][j],f[i-1][j]);
			f[i][j+1]=max(f[i][j+1],f[i-1][j]);
			if (w[i]!=-1)
				f[i+w[i]-1][j+w[i]-m]=max(f[i+w[i]-1][j+w[i]-m],f[i-1][j]+1);
		}
	}
	for (int i=0; i<=n; i++) print(f[n][i]),putchar(' ');
	return 0;
}
```

### T5 购票

### 题目描述

旅行的路线由编号为 1…N（1≤N≤10^5）的 N 个检查点组成。有 K（1≤K≤10^5）张票可供购买。第 i 张票可以在检查站 ci（1≤ci≤N）以 pi（1≤pi≤10^9）的价格购得，并且可以用其进入所有检查站 [ai,bi]（1≤ai≤bi≤N）。在进入任何检查站之前，必须已购买一张允许其进入该检查站的票。一旦可以前往某一检查站，就可以在未来的任何时候回到该检查站。对于每一个 i∈[1,N]，如果最初只能进入检查点 i，输出使得可以进入检查点 1 和 N 所需的最低总价。如果无法这样做，输出 −1

### 输入描述
### 输出描述
### 题目分析
### 参考代码

## 20220210

### T1 商贸

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T2 部队集结

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T3 虫群扩张

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T4 推演

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

## 20220212

### T1 魔法阵

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T2 区域侦测

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T3 加固

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T4 斩首行动

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

## 20220219

### T1 photo

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T2 swap

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T3 tree

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T4 rabbit

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T5 ball

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

## 20220226

### T1 输出练习

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T2 最近距离

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T3 字典序题

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T4 区间求和

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T5 智慧博弈

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

## 20220227

### T1 烽火石

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T2 博弈

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T3 染色

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

### T4 排列计数

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码