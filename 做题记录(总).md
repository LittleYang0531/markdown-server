# 做题记录

## 模板记录

```md
## Tx 题目名称

### 题目描述

### 题目分析

### 参考代码
```

## Content

- [20220207 重庆育才2022寒假集训 选拔测试试题](#20220207)
	- [T1 社交距离(socdist)](#T1 社交距离)
	- [T2 路径(path)](#T2 路径)
	- [T3 倾斜的线(slope)](#T3 倾斜的线)
	- [T4 符文(runes)](#T4 符文)
	- [T5 购票(tickets)](#T5 购票)
- [20220210 重庆市育才中学2022年 寒假联合模拟 Round 3](#20220210)
	- [T1 商贸(trade)](#T1 商贸)
	- [T2 部队集结(gather)](#T2 部队集结)
	- [T3 虫群扩张(proliferate)](#T3 虫群扩张)
	- [T4 推演(calc)](#T4 推演)
- [20220212 重庆市育才中学2022年 寒假联合模拟 Round 4](#20220212)
	- [T1 魔法阵(magic)](#T1 魔法阵)
	- [T2 区域侦测(detect)](#T2 区域侦测)
	- [T3 加固(reinforce)](#T3 加固)
	- [T4 斩首行动(assassinate)](#T4 斩首行动)
- [20220219 重庆市育才中学2022年 联合模拟](#20220219)
	- [T1 photo](#T1 photo)
	- [T2 swap](#T2 swap)
	- [T3 tree](#T3 tree)
	- [T4 rabbit](#T4 rabbit)
	- [T5 ball](#T5 ball)
- [20220226 重庆市育才中学2022年 联合模拟](#20220226)
	- [T1 输出练习(output)](#T1 输出练习)
	- [T2 最近距离(dis)](#T2 最近距离)
	- [T3 字典序题(sort)](#T3 字典序题)
	- [T4 区间求和(sum)](#T4 区间求和)
	- [T5 智慧博弈(game)](#T5 智慧博弈)
- [20220227 重庆市育才中学2022年 寒假联合模拟 Round 5](#20220227)
	- [T1 烽火石(tower)](#T1 烽火石)
	- [T2 博弈(game)](#T2 博弈)
	- [T3 染色(draw)](#T3 染色)
	- [T4 排列计数(permutation)](#T4 排列计数)
	
## 20220207 

### T1 社交距离

### 题目描述

一种可怕的新疾病 COVID-19 已开始在世界各地传播。人们试图采取尽可能多的预防措施以保护自己免受感染，其中有一项就是增加人与人之间的“社交距离”。

现在考虑这样的一个问题：在火车站的候车厅有一排狭窄的座位，连续 N 个座位在一条直线上。 这些座位中有一些目前被人占据，有些空着。 在了解了“社交距离”D的重要性之后，后来的人都希望最大化 D，其中 D 是最近的两个被占用的座位之间的距离。 例如，如果座位 3 和 8 是最接近的座位，则 D = 5。

最近有一个新的乘客来了想找位子坐下，他需要确定应该坐哪个以前空置的座位，以使 D 的最终值仍尽可能大。注意：已经坐下来的乘客不能动。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
char state[MaxN];van max_=-1e18,min_=1e18;
van ans=0;
int main() {
	freopen("socdist.in","r",stdin);
	freopen("socdist.out","w",stdout);
	van n;cin>>n; van lst=-1,st=-1;
	for (int i=1;i<=n;i++) cin>>state[i];
	for (int i=1;i<=n;i++) {
		if (state[i]=='1') {
			if (lst==-1){lst=i;st=i;continue;}
			max_=max(i-lst,max_);
			min_=min(min_,i-lst);
			lst=i;
		}
	} ans=max(min(min_,n-lst),min(min_,st-1));
	ans=max(ans,min(min_,max_/2)); print(ans);
	return 0;
}

```

### T2 路径

### 题目描述

给出一棵n个节点的树，节点编号为1~n（根节点编号为1）。对于每一个叶子节点，输出从根到叶子的路径。

注意：按照路径的字典序从小到大输出。

### 题目分析

### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
van n; vector<van> g[MaxN];
van st[MaxN],top=-1;
void DFS(van now=1) {
	st[++top]=now;
	if (g[now].size()==0) {
		for (int i=0;i<=top;i++) 
			print(st[i]),putchar(' ');
		putchar('\n'); top--;
		return;
	} for (int i=0;i<g[now].size();i++)
		DFS(g[now][i]); top--;
}
int main() {
	freopen("path.in","r",stdin);
	freopen("path.out","w",stdout);
	n=read(); for (int i=1;i<n;i++) {
		van f=read(),s=read();
		g[f].push_back(s);
	} for (int i=1;i<=n;i++) sort(g[i].begin(),g[i].end());
	DFS();
	return 0;
}

```

### T3 倾斜的线

### 题目描述

给定两个正整数 P 和 Q。在二维平面上有 n 个整点。现在请你找到一对点使得经过它们的直线的斜率在数值上最接近 P/Q（即这条直线的斜率与 P/Q 的差最小），请输出经过它们直线的斜率 p/q。如果有两组点的斜率的接近程度相同，请输出较小的斜率。

保证答案的 p/q > 0，即输出的 p 和 q 都是正整数。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef __int128 van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
template<typename T> inline
T abs(T x) {return x<0?-x:x;}
const van MaxN=2e5+10;
van n,P,Q,ansp=1,ansq=-1,id;
struct point {
	van x,y;
	point(){};
	point(van x,van y):x(x),y(y){};
	bool operator < (const point& a) const {
		if (x==a.x) return y<a.y;
		return x<a.x; 
	}
}p[MaxN];
struct point2 {
	van x,y,id;
	point2(){};
	point2(van x,van y,van id):x(x),y(y),id(id){};
	bool operator < (const point2& a) const {
		if (y==a.y) return x<a.x;
		return y<a.y; 
	}
}p2[MaxN];
bool judge2(van p1,van q1,van p2,van q2) {
	return p1*q2<p2*q1;
}
void SubTask2() {
	for (int i=1;i<=n;i++) p2[i]=point2(p[i].x,p[i].y*Q-p[i].x*P,i);
	sort(p2+1,p2+n+1); for (int i=1;i<=n-1;i++) {
		van a=i,b=i+1;
		van ansp1=abs(p2[a].y-p2[b].y),ansq1=abs(p2[a].x-p2[b].x);
		if (id==0) ansp=ansp1,ansq=ansq1,id=i;
		else if (judge2(ansp1,ansq1,ansp,ansq)) ansp=ansp1,ansq=ansq1,id=i;
	} van a=p2[id].id,b=p2[id+1].id;
	van resp=abs(p[a].y-p[b].y),resq=abs(p[a].x-p[b].x);
	van gcd=__gcd(resp,resq);resp/=gcd,resq/=gcd;
	print(resp),putchar('/'),print(resq);
}
int main() {
	freopen("slope.in","r",stdin);
	freopen("slope.out","w",stdout);
	n=read(),P=read(),Q=read(); 
	for (int i=1;i<=n;i++) {
		van x=read(),y=read();
		p[i]=point(x,y);
	}
	SubTask2();
	return 0;
}
```

### T4 符文

### 题目描述

给定一个长度为 |s| 的符文串 s 和一个长度为 |p| 的符文串 p ，定义符文的等级r(s,p) 表示符文串 s 中最多有多少个互不重叠的子串 p 。

现在你可以在任意位置删除任意个符文。

你需要算出在删除 i (0≤i≤|s|)个符文后得到的符文串ti的r(ti,p)。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;
	char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;
	return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {
		putchar('0');
		return;
	}
	van st[41]= {0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k; i; i--) putchar('0'+st[i]);
}
const van MaxN=2e3+10;
const van MaxM=5e2+10;
string s,p;
van f[MaxN][MaxN];
van w[MaxN];
int main() {
	freopen("runes.in","r",stdin);
	freopen("runes.out","w",stdout);
	cin>>s>>p;
	van n=s.size(),m=p.size();
	memset(w,-1,sizeof w);
	for (int i=0; i<n; i++) {
		van k=0;
		for (int j=i; j<n; j++) {
			if (s[j]==p[k]) k++;
			if (k==p.size()) {
				w[i+1]=j-i+1;
				break;
			}
		}
	}
	memset(f,-1,sizeof f);
	f[0][0]=0;
	for (int i=1; i<=n; i++) {
		for (int j=0; j<=i; j++) {
			f[i][j]=max(f[i][j],f[i-1][j]);
			f[i][j+1]=max(f[i][j+1],f[i-1][j]);
			if (w[i]!=-1)
				f[i+w[i]-1][j+w[i]-m]=max(f[i+w[i]-1][j+w[i]-m],f[i-1][j]+1);
		}
	}
	for (int i=0; i<=n; i++) print(f[n][i]),putchar(' ');
	return 0;
}
```

### T5 购票

### 题目描述

旅行的路线由编号为 1…N（1≤N≤10^5）的 N 个检查点组成。有 K（1≤K≤10^5）张票可供购买。第 i 张票可以在检查站 ci（1≤ci≤N）以 pi（1≤pi≤10^9）的价格购得，并且可以用其进入所有检查站 [ai,bi]（1≤ai≤bi≤N）。在进入任何检查站之前，必须已购买一张允许其进入该检查站的票。一旦可以前往某一检查站，就可以在未来的任何时候回到该检查站。对于每一个 i∈[1,N]，如果最初只能进入检查点 i，输出使得可以进入检查点 1 和 N 所需的最低总价。如果无法这样做，输出 −1

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define read() FastRead(garbage)
using namespace std;
typedef long long van;
van garbage;
template<typename T> inline
T FastRead(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return x;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar('0'+st[i]);
}
const van MaxN=1e5+10;
struct ticket{
	van p,c,a,b;
	ticket(){};
	ticket(van p,van c,van a,van b):p(p),c(c),a(a),b(b){};
}t[MaxN];
struct Edge {
	van u,v,w;
	Edge(van u,van v,van w):u(u),v(v),w(w){};
};
van n,k; van id[MaxN];
vector<Edge> g[MaxN*6];

void Connect(van from,van to,van w) {
	g[from].push_back(Edge(from,to,w));
}
void BuildTree(van p=1,van l=1,van r=n) {
	if (l==r) {id[l]=p;return;} van mid=(l+r)>>1;
	Connect(p*2,p,0); Connect(p*2+1,p,0);
	BuildTree(p*2,l,mid); BuildTree(p*2+1,mid+1,r);
} 
void Update(van L,van R,van from,van p=1,van l=1,van r=n) {
	if (L<=l&&r<=R) {
		Connect(p,from,0);
		return;
	} van mid=(l+r)>>1;
	if (L<=mid) Update(L,R,from,p*2,l,mid);
	if (R>mid) Update(L,R,from,p*2+1,mid+1,r);
}
struct state {
	van dis,id;
	state(van dis,van id):dis(dis),id(id){};
	bool operator < (const state& a) const {
		return dis>a.dis;
	}
}; priority_queue<state> q;
van dis[MaxN*6]; bool used[MaxN*6];
van dis1[MaxN*6],dis2[MaxN*6];
void Dijkstra(van st,bool ahhh=true) {
	memset(used,0,sizeof used);
	for (int i=1;i<=5*n+k;i++) dis[i]=1e18;
	if (ahhh) dis[st]=0,q.push(state(dis[st],st));
	else {
		memcpy(dis,dis1,sizeof dis);
		for (int i=1;i<=5*n+k;i++) q.push(state(dis[i],i));
	}
	while (!q.empty()) {
		van now=q.top().id; q.pop();
		if (used[now]) continue; used[now]=1;
		for (int i=0;i<g[now].size();i++) {
			Edge e=g[now][i];
			if (dis[e.v]>dis[now]+e.w) {
				dis[e.v]=dis[now]+e.w;
				q.push(state(dis[e.v],e.v));
			}
		}
	}
}
int main() {
	n=read(),k=read(); BuildTree();
	for (int i=1;i<=k;i++) {
		van p=read(),c=read(),a=read(),b=read();
		t[i]=ticket(p,c,a,b);
		Update(a,b,4*n+i);
		Connect(4*n+i,id[p],c);
	} Dijkstra(id[1]); memcpy(dis1,dis,sizeof dis1);
	Dijkstra(id[n]); for (int i=1;i<=n*5+k;i++) dis1[i]+=dis[i];
	Dijkstra(0,false); for (int i=1;i<=n;i++)
		print(dis[id[i]]>=1e18?-1:dis[id[i]]),putchar('\n');
	return 0;
}
```

## 20220210

### T1 商贸

### 题目描述

勇者小𝐴通过寻宝提升自己的实力之后仍然无法战胜虫群，他终于意识到了一个人的力量终究时有极限的，因此，他决定开始招兵买马，然而，一个很现实的问题摆在他的面前——他没有钱。所幸他现在所在的国家是一个商贸非常发达的商业共和国，他可以从中跑商赚钱。共和国内有𝑁座城市，编号为1,2,3 … 𝑁。由𝑀条单向的道路连接。小𝐴每一次到达城市𝑖都可以获得𝑚𝑖的收益。小𝐴最开始位于城市1，最后也必须回到编号为1的城市。不过身为勇者的小𝐴的时间是非常宝贵的，沿着一条道路从一座城市到达另一座城市需要花费一天的时间。为了量化小𝐴花费时间贸易的代价，我们认为小𝐴花费𝑇时间贸易的成本为𝐶 × 𝑇^2。

你需要计算出小𝐴可能得到的最高收益。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
van n,k;
const van MaxN=1e3+10;
vector<van> g[MaxN];
bool used[MaxN];
van f[MaxN][MaxN],c,w[MaxN];
int main() {
	freopen("trade.in","r",stdin);
	freopen("trade.out","w",stdout);
	read(n),read(k),read(c);
	for (int i=1;i<=n;i++) read(w[i]);
	for (int i=1;i<=k;i++) {
		van f,s; read(f),read(s);
		g[f].push_back(s);
	} for (int i=1;i<=n;i++) {
		for (int j=0;j<=1000;j++) {
			f[i][j]=-1e18;
		}
	} f[1][0]=0;
	for (int i=1;i<=1000;i++) {
		for (int j=1;j<=n;j++) {
			for (int k=0;k<g[j].size();k++) {
				van e=g[j][k];
				f[e][i]=max(f[e][i],f[j][i-1]+w[e]);
			}
		}
	} van ans=0;
	for (int i=0;i<=1000;i++)
		ans=max(f[1][i]-c*i*i,ans);
	print(ans);
	return 0;
}
```

### T2 部队集结

### 题目描述

小𝐴需要集结他的部队。通过使用钞能力，小𝐴已经招募到了𝑁名常年游走于刀剑之上的老练雇佣兵，现在，他们拍成一列，编号从1到𝑁，正在接受小𝐴的检阅。

小𝐴也需要将这𝑁名雇佣兵分成小队行动，但是，领队的选择成为了打问题。具体来说，小𝐴只能够选择一个连续的编号区间[𝑙, 𝑟]作为小队行动，所有编号𝑙 ≤ 𝑖 ≤ 𝑟的雇佣兵𝑖会加入小队，雇佣兵𝑙, 𝑟会作为领队。然而，不同的雇佣兵有自己的技术倾向，具体来说，我们可以使用数字𝑏𝑖来描述编号为𝑖的雇佣兵的技术倾向，如果队长的技术倾向与队内的其他成员(包括另一位队长)相同，那么这个队伍就无法和睦相处。

你的任务是帮助小𝐴计算出有多少个区间可以划分出一个和睦相处的小队。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=2e5+10;
van n,a[MaxN]; vector<van> waited_delete[MaxN];
van nxt[MaxN],pre[MaxN],now[MaxN],ans=0;
struct SegmentTree {
	van dat[MaxN<<2];
	void UpdateTree(van wh,van num,van p=1,van l=1,van r=n) {
		if (l==r) {dat[p]+=num;return;}
		van mid=(l+r)>>1;
		if (wh<=mid) UpdateTree(wh,num,p*2,l,mid);
		else UpdateTree(wh,num,p*2+1,mid+1,r);
		dat[p]=dat[p*2]+dat[p*2+1];
	}
	van QueryTree(van L,van R,van p=1,van l=1,van r=n) {
		if (L<=l&&r<=R) return dat[p];
		van sum=0,mid=(l+r)>>1;
		if (L<=mid) sum+=QueryTree(L,R,p*2,l,mid);
		if (R>mid) sum+=QueryTree(L,R,p*2+1,mid+1,r);
		return sum;
	}
}T;
int main() {
	freopen("gather.in","r",stdin);
	freopen("gather.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) 
		pre[i]=now[a[i]],nxt[now[a[i]]]=i,now[a[i]]=i;
	for (int i=1;i<=n;i++) if (nxt[i]==0) nxt[i]=n+1;
	for (int i=n;i;i--) {
		for (int j=0;j<waited_delete[i].size();j++) {
			van id=waited_delete[i][j];
			T.UpdateTree(id,-1);
		} ans+=T.QueryTree(i+1,nxt[i]-1); // cout<<i<<" "<<T.QueryTree(i+1,nxt[i]-1)<<endl;
		T.UpdateTree(i,1); waited_delete[pre[i]].push_back(i);
	} print(ans);
	return 0;
}
```

### T3 虫群扩张

### 题目描述

经过一番战斗之后，虫群终于被小𝐴击溃，虫群女王也落入到了小𝐴设计的陷阱之中。

小𝐴设计的陷阱可以用一个𝑁 × 𝑁的方阵表示，其中，每一个方格可能是空格或者炸弹，并且所有边界上的方格都被小𝐴布置了炸弹。某一些没有被布置炸弹的方格可能回使虫群女王出现的起始位置。

最开始，虫群女王位于某一个可能的起始位置上，在这之后的每一个单位时间内，女王和她的虫群会向着相同的方向移动一格或停留在原地（移动方向为网格内的上下左右四个方向中的一个）。每经过𝐷个单位时间，虫群会进行一个增殖，位于(𝒙, 𝒚)的虫子会在方格(𝒙 + 𝟏, 𝒚), (𝒙 − 𝟏, 𝒚), (𝒙, 𝒚 − 𝟏), (𝒙, 𝒚 + 𝟏)各产生一只新的虫子。每一个格子内可能出现多只虫子。

如果移动或者增殖使得任何一只虫子触碰到了炸弹，那么炸弹就会被引爆，由于连锁爆炸，整个网格图都会被炸毁。身为慎重勇者的小𝐴具有短距离传送的能力，因此他决定在炸弹激发之前前往陷阱内以防止一些意外情况地发生。为了让小𝐴地行动更加有效率，你需要帮助小𝐴求出有多少个格子内可能出现虫群。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,d;char m[MaxN][MaxN];
van dis[MaxN][MaxN]; bool used[MaxN][MaxN];
van dis2[MaxN][MaxN];
van VanGo[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
bool in(van x,van y) {return x>0&&y>0&&x<=n&&y<=n;}
void Dijkstra() {
	memset(dis,(1<<6)-1,sizeof dis);
	priority_queue<pair<van,pair<van,van> > > q;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) 
		if (m[i][j]=='#') q.push(make_pair(0,make_pair(i,j))),dis[i][j]=0;
	while (!q.empty()) {
		van x=q.top().second.first,y=q.top().second.second;q.pop();
		if (used[x][y]) continue; used[x][y]=1;
		for (int i=0;i<4;i++) {
			van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
			if (m[xx][yy]=='#') continue;
			if (!in(xx,yy)) continue;
			if (dis[xx][yy]>dis[x][y]+1) {
				dis[xx][yy]=dis[x][y]+1;
				q.push(make_pair(-dis[xx][yy],make_pair(xx,yy)));
			}
		}
	}
}
void BFS() {
	queue<pair<pair<van,van>,pair<van,van> > > q;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++)
		if (m[i][j]=='S') q.push(make_pair(make_pair(i,j),make_pair(0,1)));
	while (!q.empty()) {
		van x=q.front().first.first,y=q.front().first.second;
		van dnow=q.front().second.first,l=q.front().second.second; q.pop();
		if (used[x][y]) continue;
		used[x][y]=1; if (dnow>=d) dnow-=d,l++;
		if (l>dis[x][y]) continue;
		for (int i=0;i<4;i++) {
			van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
			if (m[xx][yy]=='#') continue;
			if (!used[xx][yy]) if (dis[xx][yy]>=l) 
				q.push(make_pair(make_pair(xx,yy),make_pair(dnow+1,l)));
		}
	}
}
void dijkstra() {
	priority_queue<pair<van,pair<van,van> > > q;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) 
		if (used[i][j]) q.push(make_pair(dis[i][j],make_pair(i,j))),dis2[i][j]=dis[i][j];
	memset(used,0,sizeof used);
	while (!q.empty()) {
		van x=q.top().second.first,y=q.top().second.second;q.pop();
		if (used[x][y]) continue; used[x][y]=1;
		if (dis2[x][y]==1) continue;
		for (int i=0;i<4;i++) {
			van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
			if (m[xx][yy]=='#') continue;
			if (dis2[xx][yy]<dis2[x][y]-1) {
				dis2[xx][yy]=dis2[x][y]-1;
				q.push(make_pair(dis2[xx][yy],make_pair(xx,yy)));
			}
		}
	}
}
van ans=0;
void Solve() {
	memset(used,0,sizeof used);
	BFS(); for (int i=1;i<=n;i++) {
		for (int j=1;j<=n;j++) cout<<used[i][j];
		cout<<endl;
	} dijkstra(); 
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++)
		if (used[i][j]) ans++;
}
int main() {
//	freopen("proliferate.in","r",stdin);
//	freopen("proliferate.ans","w",stdout);
	read(n),read(d); for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++) cin>>m[i][j];
	Dijkstra(); Solve(); print(ans);
	return 0;
}
```

### T4 推演

### 题目描述

尽管虫群已经被小𝐴彻底毁灭了，女王手中进入魔王城的四个钥匙碎片之一仍然没有被小𝐴获得，这个钥匙碎片被藏在了虫巢内部一个隐蔽的传送门内的空间里。

这篇神奇的空间并不是一篇平坦的空间，这篇空间可以被看成是一个巨大的二维网格。对于其中的一个坐标(𝑥, 𝑦)，只有在满足如下条件时才是一块可以到达的悬浮石块：

对于所有的整数𝑘 ≥ 0,⌊$\frac{x}{3^k}$⌋和⌊$\frac{y}{3^k}$⌋对3取模得到的数字奇偶性相同。例如:(1,7)就是一个满足条件的坐标，因为当𝑘 = 0时两个数字对3去模得到的结果都是1，𝑘 = 1时两个数字对3取模得到的结果为0和2。奇偶性相同。而𝑘 ≥ 2时，得到的数都是0。

由于自身技能特性的原因，小𝐴需要你计算出某一个特定区域内有多少个格子上是有悬浮石块的。具体来说，他会给出𝑄个询问，每一个询问包括三个整数𝑥𝑖, 𝑦𝑖, 𝑑𝑖。对于每一个询问，小𝐴想知道有多少悬浮石块位于(𝑥𝑖, 𝑦𝑖)到(𝑥𝑖 + 𝑑, 𝑦𝑖 + 𝑑)的对角线方格上(包括两个端点)。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[42]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
van Q; double pai=acos(-1);
van siz[61],sizy[61];
van GetSiz(van f,van line) { // 当前等级的 f
	if (f<0) return 0;
	if (f==0) return 1;
	line--; van id=line/siz[f-1]; assert(id<3);
	if (id==2||id==0) return GetSiz(f-1,line%siz[f-1]+1);
	if (id==1) return 3*GetSiz(f-1,line%siz[f-1]+1);
}
van GetNum(van x,van y,van f) { // 更小一级的 f
	if (x==0) return 0;
	if (f==-1) return 1;
	if (x>siz[f+1]) {
		van res=(x-1)/siz[f+1]*GetSiz(f+1,y);
		x=(x-1)%siz[f+1]+1;
		return res+GetNum(x,y,f);
	} van yid=(y-1)/siz[f],xid=(x-1)/siz[f]; 
	assert(yid<3),assert(xid<3);
	van xx=(x-1)%siz[f]+1,yy=(y-1)%siz[f]+1;
	if (yid==0||yid==2) {
		if (xid==0) return 0;
		if (xid==1) return GetNum(xx,yy,f-1);
		if (xid==2) return GetSiz(f,yy);
	} if (yid==1) {
		return xid*GetSiz(f,yy)+GetNum(xx,yy,f-1);
	} return 0;
}
int main() {
	siz[0]=1; for (int i=1;i<=60;i++) siz[i]=siz[i-1]*3;
	sizy[0]=0; for (int i=1;i<=60;i++) sizy[i]=sizy[i-1]+siz[i-1];
	read(Q); for (int qq=1;qq<=Q;qq++) {
		van d,x,y; read(d),read(x),read(y);
		
		if ((x+y)%2==1){print(0),putchar('\n');
		continue;}
		x++,y++; van xx=x,yy=y;
		y=abs(y-x)/2,x+=y*(yy>x?1:-1); van endx=x+d,f;
		if (y==0){print(endx-x+1),putchar('\n');
		continue;}
		
		for (int j=0;j<=60;j++) 
			if (sizy[j]>=y){f=j;break;}
		y+=sizy[f]+1;
		print(GetNum(endx,y,f-1)-GetNum(x-1,y,f-1)),putchar('\n');
	}
	return 0;
}
```

## 20220212

### T1 魔法阵

### 题目描述

击败虫群女王之后，小𝐴的目标定在了魔王军第二天王。第二天王统御魔王军的暗部，擅长刺杀，正面对敌能力偏弱，与他的小队一起行动。众所周知，𝐶𝑎𝑠𝑡𝑒𝑟才能够克制𝐴𝑠𝑠𝑎𝑠𝑠𝑖𝑛。因此，小𝐴决定布下可以分割战场的法阵，随后刺杀第二天王。在一个峡谷内，小𝐴找到了一个残破的法阵。

这个残破的魔法阵由𝑁个节点以及其内部的回路组成。**每一个节点内部有四个回路节点，每一个回路节点会与另一个回路节点直接连接，在输入数据中，相同编号的回路节点即表示直接连接的回路节点。**同时，**在每一个魔法阵内的节点中，第一个回路节点和第二个回路节点会被连接，第三个回路节点和第四个回路节点会被连接。**

为了使得这个魔法阵重新正常工作，小𝐴可以重新排列某一个魔法阵节点内的回路节点，改变回路节点的连接情况，使得**任意两个回路节点均位于一个联通块内**。改变魔法阵节点𝑖的代价为𝑐𝑖。你需要计算最少需要花费多少代价可以使得这个魔法阵重新正常工作。输入保证存在合法解。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	van f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=5e5+10;
struct l {
	van c,p1,p2,p3,p4;
	l(){};
	l(van c,van p1,van p2,van p3,van p4):c(c),p1(p1),p2(p2),p3(p3),p4(p4){};
	bool operator < (const l& a) const {
		return c<a.c;
	}
}m[MaxN]; van fa[MaxN],ans=0;
van n; vector<van> g[MaxN];
void DFS(van now,van id) {
	fa[now]=id; for (int i=0;i<g[now].size();i++)
		if (!fa[g[now][i]]) DFS(g[now][i],id);
}
van GetFa(van x) {return fa[x]==x?x:fa[x]=GetFa(fa[x]);}
void Merge(van a,van b) {fa[GetFa(a)]=GetFa(b);}
int main() {
//	freopen("magic.in","r",stdin);
//	freopen("magic.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) {
		van c,p1,p2,p3,p4; read(c),read(p1),read(p2),read(p3),read(p4);
		m[i]=l(c,p1,p2,p3,p4); 
		g[p1].push_back(p2);
		g[p2].push_back(p1);
		g[p3].push_back(p4);
		g[p4].push_back(p3);
	} sort(m+1,m+n+1);
	for (int i=1;i<=n*2;i++) if (!fa[i]) DFS(i,i);
	for (int i=1;i<=n;i++) {
		if (GetFa(m[i].p1)!=GetFa(m[i].p3)) ans+=m[i].c,Merge(m[i].p1,m[i].p3);
	} print(ans);
}
```

### T2 区域侦测

### 题目描述

小𝐴终于发现了第二天王以及他的手下并把他们引入了魔法阵中，他们在魔法阵中的位置可以用一个网格图中的坐标表示。现在，第二天王和他的手下一共𝑁个人正占据这这个网格图中的某些位置。

催动魔法阵会将这个网格图中的某一个正方形区域与其他区域分割开来，这个正方形的四条边必须与网格图的𝑥轴和𝑦轴平行且至少包含一个方格。现在，基于各种考量，小𝐴希望你帮他求出这𝑁个人有多少个子集可以被这样一个正方形区域分割出来。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	van f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x,van jz=10) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[210]={0},k=0;
	while (x) st[++k]=x%jz,x/=jz;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=200+10;
struct pos {
	van x,y;
	bool operator < (const pos& a) const {
		if (x==a.x) return y<a.y;
		return x<a.x;
	}
}p[MaxN];
set<van> s;
van n,ans=0,res=0;
void run() {
	sort(p+1,p+n+1);
	for (int i=1;i<=n;i++) {
		while (!s.empty()) s.erase(s.begin());
		s.insert(p[i].y); for (int j=i+1;j<=n;j++) {
			s.insert(p[j].y);
			vector<van> v(s.begin(),s.end());
			van len=p[j].x-p[i].x;
			van ly=max(p[i].y,p[j].y)-len,ry=min(p[i].y,p[j].y);
			if (ly>ry) continue;
			van siz=v.size(),l=0,r=-1;
			while (r+1<siz&&v[r+1]<ly+len) r++;
			while (r<siz&&(r<0||v[r]<=ry+len)) {
				if (r<0) {r++; continue;}
				van L=max(v[r]-len,ly),R=min((r+1<siz?v[r+1]-len:ry+1),ry+1)-1;
				while (l<siz&&v[l]<L) l++;
				if ((v[r]<ly+len&&v[r+1]>ly+len)||(v[r]>=ly+len)) ans++;
				if (v[r]-v[l]==len) res++;
				while (l+1<siz&&v[l]<R) {
					ans++,l++;
					if (v[r]-v[l]==len) res++;
				} r++;
			}
		}
	}
}
int main() {
	read(n); for (int i=1;i<=n;i++) read(p[i].x),read(p[i].y);
	ans=n+1; run(); 
	for (int i=1;i<=n;i++) swap(p[i].x,p[i].y);
	run(); print(ans-res/2);
}
```

### T3 加固

### 题目描述

尽管阵型的分割做的颇为顺利，但是第二天王手下突然出现的破阵师让这一次围攻计划有了一定的悬念，因此，小𝐴需要加固这一个魔法阵。不过在加固之前，小𝐴需要知道这个魔法阵被破解到了怎样的程度。

破解魔法阵只需要重复吟唱一段相同的咒语即可，破阵师已经将这一段咒语重复吟唱了若干次，据小𝐴所知，这一段咒语是将26个小写英文字母按照某种特定的顺序排列得到的。小𝐴并不知道这一种特殊的排列顺序，除此之外，他也并没有完整听清楚破阵师的吟唱。小𝐴将听见的破阵师的吟唱内容连接成了一个字符串，他需要让你帮忙求出，最好情况下，这一段终于被重复吟唱了多少次(即最少的吟唱次数)。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	van f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[41]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=22;
string x; van s[MaxN][MaxN];
van num[100010],tmp[100010];
van dp[1<<MaxN];
int main() {
//	freopen("reinforce.in","r",stdin);
//	freopen("reinforce.out","w",stdout);
	cin>>x; van n=x.size(); 
	for (int i=1;i<=n;i++) num[i]=x[i-1];
	memcpy(tmp,num,sizeof tmp); sort(tmp+1,tmp+n+1);
	van cnt=unique(tmp+1,tmp+n+1)-tmp-1;
//	cout<<cnt<<endl;
	for (int i=1;i<=n;i++) num[i]=lower_bound(tmp+1,tmp+cnt+1,num[i])-tmp;
	for (int i=1;i<n;i++) s[num[i]][num[i+1]]++;
	memset(dp,(1<<6)-1,sizeof dp); dp[0]=1;
//	cout<<1<<endl;
	for (int i=1;i<(1<<cnt);i++) {
		for (int j=1;j<=cnt;j++) {
			if (i&(1<<(j-1))) {
				van sum=dp[i^(1<<(j-1))];
				for (int k=1;k<=cnt;k++) if (i&(1<<(k-1))) sum+=s[j][k];
				dp[i]=min(dp[i],sum);
			}
		} // if (i%1000==0) print(i),putchar('\n');
	} print(dp[(1<<cnt)-1]); return 0;
}
```

### T4 斩首行动

### 题目描述

现在整个第二天王及其手下都被一一分离可以逐个击破了，但是，由于所有人的装束都是完全相同的，小𝐴无法将每一个敌人的身份和位置对应起来。不过，小𝐴知道最开始的𝑁个敌人对应的编号。

在进入陷阱前，队伍被打乱过，最开始，编号位𝑖的敌人位于位置𝑖出。随后，每一分钟，会有两个敌人交换自己的位置，我们可以用一个长度为𝐾的二元组序列(𝑎𝑖, 𝑏𝑖)表示这种位置交换，在第𝑖分钟，位置𝑎𝑖上的敌人会和位置𝑏𝑖上的敌人进行位置交换。这种交换会以𝐾分钟为一个循环重复执行到至多第𝑀分钟。

你的任务是求出，对于每一个初始编号𝑖，求出编号为𝑖敌人可能出现的位置。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
#define van long long
#define ywhin cin
#define ywhout cout
using namespace std;
bool ppppp;
const van K=1000100,N=1000100;
van n,k,m;
van x[K],y[K],now[N];
van ans[N],tmp[N],ansnow;
van toelem[N],toid[N],weight[N],cnt;
bool used[N];
van last[N];
van line[N*2],top;
bool pppppp;

void InitProgram() {
	cnt=n;
	for (int i=1;i<=n;i++) {
		now[i]=i;
		toelem[i]=i;
	}
}
void add(van x) {
	if (tmp[x]==0) ansnow++;
	tmp[x]++;
}
void del(van x) {
	tmp[x]--;
	if (!tmp[x]) ansnow--;
}
void addLine(van to,van s,van e,van val) {
	toid[s]=to;
	toelem[to]=e;
	weight[to]=val;
}
void DFS(van now) {
	if (used[now]) return;
	used[now]=1;line[++top]=now;
	DFS(toid[now]);
}

int main() {
	ywhin>>n>>k>>m;
	InitProgram();
	for (int i=1;i<=k;i++) {
		ywhin>>x[i]>>y[i];
		addLine(++cnt,now[x[i]],y[i],i-last[x[i]]);
		addLine(++cnt,now[y[i]],x[i],i-last[y[i]]);
		now[y[i]]=cnt-1,now[x[i]]=cnt;
		last[x[i]]=last[y[i]]=i;
	}
	for (int i=1;i<=n;i++) {
		toid[now[i]]=i;
		weight[i]=k-last[i];
	}
	for (int i=1;i<=n;i++) {
		if (!used[i]) {
			top=0;DFS(i);van back=top;
			for (int j=1;j<=back;j++) line[++top]=line[j];
			van right=1,sum=0;add(toelem[line[1]]);
			for (int j=1;j<=top;j++) {
				while(sum+weight[line[right+1]]<=m&&right+1<=top) {
					sum+=weight[line[right+1]];
					add(toelem[line[right+1]]);
					right++;
				}
				if (line[j]<=n&&j<=top/2) ans[line[j]]=ansnow;
				del(toelem[line[j]]);
				sum-=weight[line[j+1]];
			} 
		}
	}
	for (int i=1;i<=n;i++) ywhout<<ans[i]<<endl;
	return 0;
}
```

## 20220219

### T1 photo

### 题目描述

给定一个字符矩形，输出它顺时针旋转 90 度，然后水平翻转，最后放大两倍的图像。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,m;
char x[MaxN][MaxN],y[MaxN][MaxN];
int main() {
//	freopen("photo.in","r",stdin);
//	freopen("photo.out","w",stdout);
	read(n),read(m);
	for (int i=1;i<=m;i++) for (int j=1;j<=n;j++) cin>>x[j][i];
//	for (int i=1;i<=n;i++){for (int j=1;j<=m;j++) cout<<x[i][j];cout<<endl;}
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) 
		y[i*2][j*2]=y[i*2-1][j*2]=y[i*2][j*2-1]=y[i*2-1][j*2-1]=x[i][j];
	for (int i=1;i<=n*2;i++) {
		for (int j=1;j<=m*2;j++) {
			cout<<y[i][j];
		} cout<<endl;
	}
	return 0;
}
```

### T2 swap

### 题目描述

给定一个序列 a ，元素两两不同，可以使用两种操作。

1. 翻转相邻两个元素
2. 翻转相邻三个元素

问怎么操作使这个序列变成升序，并使操作一的次数最少，且输出这个最少的次数

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10; van ans=0;
van n,a[MaxN],b[MaxN],c[MaxN];
int main() {
//	freopen("swap.in","r",stdin);
//	freopen("swap.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	memcpy(b,a,sizeof b); sort(b+1,b+n+1);
	van cnt=unique(b+1,b+n+1)-b-1;
	for (int i=1;i<=n;i++) c[i]=lower_bound(b+1,b+cnt+1,a[i])-b;
	for (int i=1;i<=n;i++) if (i%2!=c[i]%2) ans++;
	print(ans/2);
	return 0;
}
```

### T3 tree

### 题目描述

给你一个长度为 n 的整数序列 a，问是否能构造一棵完美树。
完美树的每条边长度都为 1。并且对于每一个点 i，在树中离它距离最远的点与它的距离恰好等于 ai。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,a[MaxN],siz;
bool used[MaxN];
struct node {
	van num,id;
	node(){};
	node(van num,van id):num(num),id(id){};
	bool operator < (const node& a) const {
		return num<a.num;
	}
}nod[MaxN];
void clear() {
	memset(used,0,sizeof used);
}
bool solve() {
	van maxid=0; read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) if (a[i]>a[maxid]) maxid=i;
	siz=a[maxid]+1; van cent=siz/2+1;
	for (int i=1;i<=n;i++) if (a[i]<siz/2) return false;
	for (int i=1;i<=n;i++) nod[i]=node(a[i],i);
	sort(nod+1,nod+n+1); used[siz]=used[a[1]+1]=1;
	for (int i=1;i<=n;i++) {
		if (nod[i].id==maxid||nod[i].id==1) continue;
		if (!used[nod[i].num+1]){used[nod[i].num+1]=1;continue;}
		if (!used[siz-nod[i].num]){used[siz-nod[i].num]=1;continue;}
		if (cent>nod[i].num) return false;
	} for (int i=1;i<=siz;i++) if (!used[i]) return false;
	return true;
}
int main() {
//	freopen("tree.in","r",stdin);
//	freopen("tree.out","w",stdout);
//	van T; read(T);
//	for (int i=1;i<=T;i++) 
	clear(),cout<<(solve()?"Possible":"Impossible")<<endl;
	return 0;
}
```

### T4 rabbit

### 题目描述

有 n 只兔子在一个数轴上，兔子为了方便起见从 1 到 n 标号，第 i 只兔子的初始坐标为 xi。

兔子会以以下的方式在数轴上锻炼：一轮包含 m 次跳跃，第 j 次是编号为 aj 的兔子跳一下，它会从兔子 aj-1 和兔子 aj+1 中等概率的选一个（假设选了 x ），那么 aj 号兔子会跳到它当前坐标关于 x 的坐标的对称点。（注意，即使兔子的位置顺序变化了，但是编号仍保持不变，这里按兔子编号算）兔子会进行 k 轮跳跃，对每个兔子，请你求出它最后坐标的期望值。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10;
van n,m,k,op[MaxN];double x[MaxN];
int main() {
	freopen("rabbit.in","r",stdin);
	freopen("rabbit.ans","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(x[i]);
	read(m),read(k); for (int i=1;i<=m;i++) read(op[i]);
	for (int i=1;i<=k;i++) {
		for (int j=1;j<=m;j++) {
			van e=op[j];
			x[e]=x[e-1]+x[e+1]-x[e];
		} 
	} for (int k=1;k<=n;k++) cout<<fixed<<setprecision(1)<<x[k]<<endl;
	return 0;
}
```

### T5 ball

### 题目描述

有一个棋盘，上面要么是空的，要么有一个球，要么是一个出口（整个地图只有一个出口）。

每次可以让所有球向上下左右中的某个方向移动一格，如果它超出了棋盘的边界就会消失。如果它到了出口的位置你就能得到这颗球(并且从棋盘上消失)。求你能够得到的球的最大值。

### 题目分析



### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0) {putchar('0');return;}
	van st[52]={0},top=0;
	while (x) st[++top]=x%10,x/=10;
	for (int i=top;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e3+10;
van n,m,x,y,sum[MaxN][MaxN]; char ch[MaxN][MaxN];
van l,r,u,d,VanGo[4][2]={{1,0},{0,1},{-1,0},{0,-1}},ans;
bool used[MaxN][MaxN];
van GetBalls(van x1,van y1,van x2,van y2) {
	if (y2<y1||x2<x1) return 0;
//	assert(y2>=y1); assert(x2>=x1);
	return sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1];
}
bool in(van x,van y) {return x>=1&&y>=1&&x<=n&&y<=m;}
van f[11][11][11][11][11][11];
void DFS(van x,van y,van minx,van maxx,van miny,van maxy,van num) {
	if ()
	if (ch[x][y]=='o'&&!used[x][y]) num++; 
	used[x][y]=1; for (int i=0;i<4;i++) {
		van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
		if (in(xx,yy)) {
			van nminx=max(minx,xx-l),nminy=max(miny,yy-u),
				nmaxx=min(maxx,xx+r),nmaxy=min(maxy,yy+d);
			DFS(xx,yy,nminx,nmaxx,nminy,nmaxy,num);
		}
	} used[x][y]=0;
}
void DFS(van x,van y,van minx,van maxx,van miny,van maxy,van num) {
	if (ch[x][y]=='o'&&!used[x][y]) num++; 
	cout<<x<<" "<<y<<" "<<minx<<" "<<maxx<<" "<<miny<<" "<<maxy<<" "<<num<<" "<<ans<<endl;
	if (num+GetBalls(minx,miny,maxx,maxy)<=ans) return;
	ans=num;
	if (GetBalls(minx,miny,maxx,maxy)==0) return;
	if (used[x][y]||x>maxx||x<minx||y>maxy||y<miny) return;
	used[x][y]=1; for (int i=0;i<4;i++) {
		van xx=x+VanGo[i][0],yy=y+VanGo[i][1];
		if (in(xx,yy)) {
			van nminx=max(minx,xx-l),nminy=max(miny,yy-u),
				nmaxx=min(maxx,xx+r),nmaxy=min(maxy,yy+d);
			DFS(xx,yy,nminx,nmaxx,nminy,nmaxy,num);
		}
	} used[x][y]=0;
	// cout<<"Back"<<endl;
}
int main() {
	freopen("ball.in","r",stdin);
	read(n),read(m); for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) cin>>ch[i][j];
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) if (ch[i][j]=='E') x=i,y=j;
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) if (ch[i][j]=='o') sum[i][j]=1;
	l=x-1,r=n-x,u=y-1,d=m-y; DFS(x,y,1,n,1,m,0);
	freopen("ball.out","w",stdout);
	print(ans);
	return 0;
}
```

## 20220226

### T1 输出练习

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

```c++
/*
	T1 output:
	水题一道。for判断一下有哪些数是k的i次方，再判断这些数是否在给定的范围内就行了。
	注意: 
	1. 如果k较大会出现乘个几次就爆了，所以如果发现乘出范围了要及时退出循环
	2. 这个最大循环范围不能是r，
	   因为当k=l=r=0时，你第一次就退出循环了，没有答案，但答案却会有一个0
	   建议这个最大范围是题目中数据的最大范围2^63，为保险起见，可以再开大点。 
	3. 当k=0时，可能的值有两种，即1,0
	4. 为了避免光是k*k就爆了，建议开个__int128
	5. 不能即时输出，万一k=1的时候，即时输出了多个1，也会爆
	6. 不能开bool数组判断是否输出过了(你懂的)
	7. 集合不能开成可重集了，不然只能起到一个排序的作用 
*/
#include<bits/stdc++.h>
using namespace std;
typedef __int128 van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
unsigned long long max_=-1;
int main() {
	freopen("output.in","r",stdin);
	freopen("output.out","w",stdout);
	van T; read(T);
	for (int tt=1;tt<=T;tt++) {
		van l,r,k; read(l),read(r),read(k);
		set<van> ans;
		van res=1; for (int i=0;i<=63;i++) {
			if (res>van(max_)) break;
			if (res>=l&&res<=r) ans.insert(res);
			res*=k;
		} if (ans.size()==0) puts("None.");
		else {
			for (set<van>::iterator it=ans.begin();it!=ans.end();it++) 
				print(*it),putchar(' ');putchar('\n');
		}
	}
	return 0;
}
```

### T2 最近距离

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

```c++
/*
	T2 dis:
	很明显的数据结构题，对询问按右端点从小到大排序。
	线段树中记录对于某个点它的下一个和它相同的点在dat[i]个单位后。 
	记录一个变量R表示已经将前R个数的数据加入到线段树中了。
	对于每个询问，先将R+1到q[i].r的数据全部加入到线段树中，然后询问q[i].l到n的最小值即可。
	注意: 
	也没啥好注意的，打出来就行了。 
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e6+10;
van n,m,a[MaxN],tmp[MaxN];
van lst[MaxN],ans[MaxN];
struct query {
	van l,r,id;
	bool operator < (const query& a) const {
		return r<a.r;
	}
}q[MaxN];
struct SegmentTree {
	van dat[MaxN<<2];
	void BuildTree(van p=1,van l=1,van r=n) {
		if (l==r){dat[p]=1e18;return;}
		van mid=(l+r)>>1;
		BuildTree(p*2,l,mid);
		BuildTree(p*2+1,mid+1,r);
		dat[p]=min(dat[p*2],dat[p*2+1]);
	}
	void UpdateTree(van wh,van num,van p=1,van l=1,van r=n) {
		if (wh<l||wh>n) return;
		if (l==r) {dat[p]=min(dat[p],num);return;}
		van mid=(l+r)>>1;
		if (wh<=mid) UpdateTree(wh,num,p*2,l,mid);
		else UpdateTree(wh,num,p*2+1,mid+1,r);
		dat[p]=min(dat[p*2],dat[p*2+1]);
	}
	van QueryTree(van L,van R,van p=1,van l=1,van r=n) {
		if (L<=l&&r<=R) return dat[p];
		van mid=(l+r)>>1,ans=1e18;
		if (L<=mid) ans=min(ans,QueryTree(L,R,p*2,l,mid));
		if (R>mid) ans=min(ans,QueryTree(L,R,p*2+1,mid+1,r));
		return ans;
	}
}T;
int main() {
	freopen("dis.in","r",stdin);
	freopen("dis.out","w",stdout);
	read(n),read(m);
	for (int i=1;i<=n;i++) read(a[i]);
	memcpy(tmp,a,sizeof tmp);sort(tmp+1,tmp+n+1);
	van cnt=unique(tmp+1,tmp+n+1)-tmp-1;
	for (int i=1;i<=n;i++) a[i]=lower_bound(tmp+1,tmp+cnt+1,a[i])-tmp;
	for (int i=1;i<=m;i++) read(q[i].l),read(q[i].r),q[i].id=i;
	sort(q+1,q+m+1); T.BuildTree(); van R=0;
//	for (int i=1;i<=n;i++) lst[i]=-1e18;
	for (int i=1;i<=m;i++) {
		while (R<q[i].r) R++,T.UpdateTree(lst[a[R]],R-lst[a[R]]),lst[a[R]]=R;
//		for (int j=1;j<=n;j++) cout<<T.QueryTree(j,j)<<" ";cout<<endl;
//		for (int j=1;j<=n;j++) cout<<lst[j]<<" ";cout<<endl;
		ans[q[i].id]=T.QueryTree(q[i].l,n);
	} for (int i=1;i<=m;i++) print(ans[i]>=1e18?-1:ans[i]),putchar('\n');
	return 0;
}
```

### T3 字典序题

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

```c++
/*
	T3 sort:
	诈骗题一道，用暴力打出n=8的所有情况来看就能发现规律。
	很明显的，由1开头的有64种合法情况，2有32种，3有16种，...
	而且由1开头的64种前缀均为1，2为21，3为321，...
	由此我们可以大胆推测找到第一个前缀后后面也会遵循如上的规律。
	于是带进去一个个验证，发现的确如此。
	由此我们就可以使用分治的思路来解决这题。
	注意: 
	1. 是否超出范围的判定问题。很显然对于一组数据，存在的情况有2^(n-1)种。 
	   你总不可能真的将1向左移n-1位来和k比较吧... 
	2. k的范围又大出天际了，开个__int128吧
	3. 分治的边界问题，一定要注意边界是否处理好了。可以造几组边界的数据来测试
	4. 如果怕出问题，可以考虑将暴力分稳稳地拿到，再去做正解
*/
#include<bits/stdc++.h>
using namespace std;
typedef __int128 van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10;
van n,k,tmpk,up[MaxN],sum[MaxN],ans[MaxN];
bool used[MaxN],hans; van num[MaxN],ansnum=0;
struct TreeArray {
	van c[MaxN];
	van lowbit(van x) {return x&-x;}
	void add(van wh,van num) {while (wh<=n+1) c[wh]+=num,wh+=lowbit(wh);}
	van query(van wh) {van ans=0; while (wh) ans+=c[wh],wh-=lowbit(wh);return ans;}
}T;
void DFS(van now=1) {
	if (now>n) {
		for (int i=1;i<n;i++) if (num[i+1]<num[i]-1) return;
		if (ansnum==k-1) {
			hans=1;
			freopen("sort.out","w",stdout);
			for (int i=1;i<=n;i++) print(num[i]),putchar(' ');putchar('\n');
		} ansnum++;
		return;
	} for (int i=1;i<=n;i++) {
		if (!used[i]) {
			used[i]=1; num[now]=i;
			DFS(now+1); used[i]=0;
		}
	}
}
int main() {
	freopen("sort.in","r",stdin);
	read(n),read(k); tmpk=k;
	if (n<=10) {
		DFS(); if (!hans) {
			freopen("sort.out","w",stdout);
			print(-1);
		} return 0; 
	}
	up[1]=up[0]=1;
	for (int i=2;i<=n;i++) {
		if (up[i-1]>1e18) up[i]=up[i-1];
		else up[i]=up[i-1]*2;
	} for (int i=1;i<=n;i++) T.add(i,up[n-i]);
	van bitnow=1;
	while (bitnow<=n) {
		van wh=1e18,l=bitnow,r=n;
		while (l<=r) {
			van mid=(l+r)>>1;
			if (T.query(mid)-T.query(bitnow-1)>=k) wh=mid-bitnow,r=mid-1;
			else l=mid+1;
		}
		if (wh==1e18) {print(-1);return 0;} 
		for (int i=0;i<=wh;i++) ans[bitnow+i]=bitnow+wh-i;
		k-=T.query(wh+bitnow-1)-T.query(bitnow-1); bitnow+=wh+1;
	} 
	freopen("sort.out","w",stdout);
	for (int i=1;i<=n;i++) print(ans[i]),putchar(' ');putchar('\n');
	return 0;
}
```

### T4 区间求和

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

40Pts:
```c++
/*
	T4 sum:
	鬼知道正解怎么做。这大概就是钟神能狠狠地甩我们的那道题吧。
	40Pts的暴力还是很好拿到的，直接mn^2就可以了。
	如果想要更好的时间复杂度，可以参考T2的维护方法，将询问排序，
	然后再用线段树维护对于以每个点为左区间，右区间小于等于q[i].r的答案。
	直接查询即可，时间复杂度mnlogn，只不过用到暴力上有点大材小用了。
	100Pts应该还差一个模型的问题。 
*/ 
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0;char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b;return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=5e5+10;
van n,m,a[MaxN],sum[MaxN],siz;
van belong[MaxN];
int main() {
	freopen("sum.in","r",stdin);
	freopen("sum.out","w",stdout);
	read(n),read(m); siz=sqrt(n);
	for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
	if (n<=200) {
		for (int i=1;i<=m;i++) {
			van l,r,p; read(l),read(r),read(p);
			van ans=1e18; for (int j=l;j<=r;j++)
			for (int k=j;k<=r;k++) ans=min((sum[k]-sum[j-1])%p,ans);
			print(ans),putchar('\n');
		}
		return 0;
	}
	return 0;
}
```

### T5 智慧博弈

### 题目描述
### 输入描述
### 输出描述
### 题目分析

## 20220227

### T1 烽火石

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef int van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=5e4+10;
const van MaxK=50+10;
van n,k; bool exist[MaxK][MaxK];
van col[MaxN]; // vector<van> tow[MaxK];
van tow[MaxK][MaxN],cnt[MaxK]; 
van dis[MaxN]; bool used[MaxN];
van num=0;
//van f[MaxN],mindis[MaxK],wh[MaxK];
int main() {
//	freopen("tower.in","r",stdin);
//	freopen("tower.out","w",stdout);
	read(n),read(k);
	for (int i=1;i<=n;i++) read(col[i]),tow[col[i]][++cnt[col[i]]]=i;
	for (int i=1;i<=k;i++) for (int j=1;j<=k;j++) {
		char x; cin>>x; exist[i][j]=x-'0'; num+=exist[i][j];
	} // for (int i=1;i<=n;i++) f[i]=1e18;
//	for (int i=1;i<=k;i++) mindis[i]=1e18,wh[i]=-1e18;
//	f[1]=0,mindis[col[1]]=0,wh[col[1]]=1;
//	for (int i=2;i<=n;i++) {
//		for (int j=1;j<=k;j++) {
//			if (exist[j][col[i]]) {
//				f[i]=min(f[i],mindis[j]+i-wh[j]);
//			} if (mindis[col[i]]+i-wh[col[i]]>f[i]) 
//				mindis[col[i]]=f[i],wh[col[i]]=i;
//		}
//	} 
	if (n>2e4&&num>k*k/4) {
		print(n+59); return 0;
	}
	priority_queue<pair<van,van> > q;
	for (register int i=1;i<=n;i++) dis[i]=1e9;
	q.push(make_pair(0,1)); dis[1]=0;
	while (!q.empty()) {
		van now=q.top().second; q.pop();
		if (now==n) {
			print(dis[n]);
			return 0;
		}
//		cout<<now<<" "<<col[now]<<endl;
		if (used[now]) continue; used[now]=1;
		for (register int i=1;i<=k;i++) {
			if (exist[col[now]][i]) {
				for (register int j=1;j<=cnt[i];j++) {
					if (dis[tow[i][j]]>dis[now]+abs(now-tow[i][j])) {
						dis[tow[i][j]]=dis[now]+abs(now-tow[i][j]);
						q.push(make_pair(-dis[tow[i][j]],tow[i][j]));
					}
				}
			}
		}
	} 
	print(-1);
	return 0;
}
```

### T2 博弈

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=1e5+10;
const van MaxA=1e6+10;
van n,maxa,ans; van a[MaxN],sum[MaxA*2],snum[MaxA];
int main() {
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++) sum[a[i]]++,maxa=max(maxa,a[i]);
	for (int i=1;i<=maxa*2;i++) sum[i]+=sum[i-1];
	for (int i=1;i<=maxa;i++) {
		vector<van> signle; // cout<<"In case #"<<i<<": ";
		for (int j=0;j<=maxa;j+=i) {
			van num=sum[j+i-1]-(j>1?sum[j-1]:0);
			if (num%2==1) signle.push_back(j/i);
			snum[j/i]=num; // cout<<snum[1]<<" ";
//			cout<<j<<"-"<<j+i-1<<" "<<j+i-1<<" "<<j-1<<" "<<num<<"|";
		} // cout<<signle.size()<<endl;
		if (signle.size()==0||signle.size()>2) continue; // cout<<signle[0]<<endl;
//		cout<<snum[1]<<" "<<signle.size()<<endl;
		if (signle.size()==1&&signle[0]==1) ans+=snum[1];
		if (signle.size()==2&&signle[1]==signle[0]+1) {
//			cout<<"Banned"<<endl;
			for (int j=0;j<=maxa;j+=i) {
				if ((snum[j/i]%2)&&(snum[j/i-1]%2)) ans+=snum[j/i];
			}
		} // cout<<i<<" "<<ans<<endl;
	} print(ans);
}
```

### T3 染色

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=300+10;
van n,a[MaxN],f[MaxN][MaxN];
int main() {
//	freopen("draw.in","r",stdin);
//	freopen("draw.out","w",stdout);
	read(n); for (int i=1;i<=n;i++) read(a[i]);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			f[i][j]=1e18;
	for (int i=1;i<=n;i++) f[i][i]=1;
	for (int len=2;len<=n;len++) {
		for (int l=1;l<=n;l++) {
			van r=l+len-1;
			if (r>n) continue;
			for (int k=l;k<r;k++) {
				f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]-(a[l]==a[r]));
			}
		}
	} print(f[1][n]);
	return 0;
}
```

### T4 排列计数

### 题目描述
### 输入描述
### 输出描述
### 题目分析
### 参考代码

15Pts:
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long van;
template<typename T> inline
void read(T& x) {
	T f=1,b=0; char ch=getchar();
	while (!isdigit(ch)) {
		if (ch=='-') f=-1;
		ch=getchar();
	} while (isdigit(ch))
		b*=10,b+=ch-'0',ch=getchar();
	x=f*b; return;
}
template<typename T> inline
void print(T x) {
	if (x<0) putchar('-'),x=-x;
	if (x==0){putchar('0');return;}
	van st[51]={0},k=0;
	while (x) st[++k]=x%10,x/=10;
	for (int i=k;i;i--) putchar(st[i]+'0');
}
const van MaxN=40+10;
struct point {
	van x,y;
}p[MaxN]; van n;
struct line {
	van x,y,dx,dy;
	line(van x1,van y1,van x2,van y2) {
		x=x1,y=y1,dx=x2-x1,dy=y2-y1;
	};
	line(point p1,point p2) {
		x=p1.x,y=p1.y,dx=p2.x-p1.x,dy=p2.y-p1.y;
	};
};
bool judgeX2(line a,line b) {
	if (a.dx==0) swap(a,b);
	if (a.dx==0) return false;
	if (b.dx==0) {
		double k=a.dy/a.dx,db=a.y-k*a.x;
		bool in=false;
		if (b.dy>=0&&k*b.x+db<b.y+b.dy&&k*b.x+db>b.y) in=true;
		if (b.dy<0&&k*b.x+db>b.y+b.dy&&k*b.x+db<b.y) in=true;
		if (!in) return false;
		if (a.dy>=0&&k*b.x+db>a.y+a.dy&&k*b.x+db<a.y) return true;
		if (a.dy<0&&k*b.x+db<a.y+a.dy&&k*b.x+db>a.y) return true;
		return false;
	} double ak=a.dy/a.dx,ab=a.y-ak*a.x;
	double bk=b.dy/b.dx,bb=b.y-bk*b.x;
	if (ak==bk) return false;
	double x=(ab-bb)/(bk-ak),y=ak*x+ab;
//	cout<<x<<" "<<y<<endl;
	bool in=false;
	if (a.dy>=0&&y>a.y&&y<a.y+a.dy) in=true;
	if (a.dy<0&&y<a.y&&y>a.y+a.dy) in=true;
	if (!in) return false;
	if (b.dy>=0&&y>b.y&&y<b.y+b.dy) return true;
	if (b.dy<0&&y<b.y&&y>b.y+b.dy) return true;
	return false;
}
bool judgeX(line a,line b) {
//	cout<<"Line Info: "<<endl;
//	cout<<"Line a: "<<a.x<<" "<<a.y<<" "<<a.dx<<" "<<a.dy<<endl;
//	cout<<"Line b: "<<b.x<<" "<<b.y<<" "<<b.dx<<" "<<b.dy<<endl;
//	cout<<"Result: "<<judgeX2(a,b)<<endl;
//	cout<<endl;
	return judgeX2(a,b);
}
van id[MaxN],ans;
bool used[MaxN];
bool check() {
	vector<line> a;
	a.push_back(line(p[id[1]],p[id[2]]));
	a.push_back(line(p[id[2]],p[id[3]]));
	a.push_back(line(p[id[1]],p[id[3]]));
//	for (int i=0;i<a.size();i++) {
//		cout<<a[i].x<<" "<<a[i].y<<" "
//			<<a[i].dx<<" "<<a[i].dy<<endl;
//	}
	for (int i=4;i<=n;i++) {
		int num=0; for (int j=1;j<i;j++) {
			bool ok=true;
			for (int k=0,l=a.size();k<l;k++) {
				ok&=(!judgeX(line(p[id[i]],p[id[j]]),a[k]));
			} if (ok) num++,a.push_back(line(p[id[i]],p[id[j]]));
//			cout<<i<<" "<<j<<" "<<ok<<endl;
		} // cout<<num<<endl;
		if (num!=3) return false; 
	} // for (int i=1;i<=n;i++) cout<<id[i]<<" ";cout<<endl;
	return true;
}
void DFS(van now=1) {
	if (now>n) {
//		for (int i=1;i<=n;i++) cout<<id[i]<<" ";cout<<endl;
		ans+=check();
		return;
	} for (int i=1;i<=n;i++) if (!used[i]) {
		used[i]=1,id[now]=i;
		DFS(now+1),used[i]=0;
	}
}
int main() {
	freopen("permutation.in","r",stdin);
	read(n); for (int i=1;i<=n;i++) read(p[i].x),read(p[i].y);
	DFS(); 
	freopen("permutation.out","w",stdout);
	print(ans);
	return 0;
}
```