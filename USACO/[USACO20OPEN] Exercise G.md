[Pixiv: 72086659]: 'https://cdn.jsdelivr.net/gh/LittleYang0531/Photo/72086659_p0.jpg'

## [USACO20OPEN] Exercise G 做题记录

### 题目描述:

​YC 中学最近决定更换大课间的锻炼方案了！ 

​现在，老师会将 $N$ 个学生排成一排，对于 $1\leq i\leq N$ 的每一个 $i$，我们将从左到右的第 $i$ 位同学编号为 $i$。在锻炼开始之前，老师会给出一个长度为 $N$ 的排列 $A$，锻炼开始时，每一步，编号为 $i$ 的同学会更换位置到编号为 $A_i$ 的位置，直到变回原来的顺序。

​例如，如果 $A=(2,3,1,5,4)$。那么一共会进行 6 步锻炼。从第一步开始，每一步 0 结束之后的状态如下：一步：$(3,1,2,5,4)$，两步：$(2,3,1,4,5)$，三步：$(1,2,3,5,4)$，四步：$(3,1,2,4,5)$，五步： $(2,3,1,5,4)$，六步：$(1,2,3,4,5)$。 

​**你的任务是求出所有正整数 $K$ 的和，使得存在一个长为 $N$ 的排列使得学生们的锻炼需要进行 $K$ 步，**答案对 $M$ 取模。

### 输入描述:

​输入的第一行包括两个正整数 $N,M(1\leq N\leq 10^4,10^8\leq M\leq 10^9+7)$，保证$M$是一个质数。

### 输出描述:

​输出一个整数，表示所有满足条件的 $K$ 的和。

### 测试样例:

#### 【样例1输入】

```
5 1000000007
```

#### 【样例1输出】

```
21
```

#### 【样例1解释】

​存在排列使得同学们需要进行 1，2，3，4，5 以及 6 步，因此，答案为 $1+2+3+4+5+6=21$。

### 数据范围与提示:

| 子任务 | 分数 |   特殊性质   |
| :----: | :--: | :----------: |
|   1    |  30  | $N\leq 100$  |
|   2    |  30  | $N\leq 1000$ |
|   3    |  40  |  无特殊性质  |

### 题目分析:

​一个显而易见的结论：这玩意儿会形成很多个环，且某一个 $K$ 的值为这些环的最小公倍数。

​于是这个题就变成了求一个小于等于 $N$ 的所有环能形成的最小公倍数的和。（至于为什么小于也可以，读者可以自行思考一下）

​如何求最小公倍数之和？首先求出小于等于 $N$ 的所有质数，再由这些质数的 $q$ 次方来构成最小公倍数。由于同一个质数的 $q_1$ 与 $q_2$ 次方的最小公倍数为更小的那一个，因此我们只需要在每一个质数里面只需要选择一个 $p^q$ 就行了。

​于是我们就可以用 DP 了。设 $f[i][j]$ 为枚举到第 $i$ 个质数且前 $i$ 个质数的 $q$ 次方的和小于等于 $j$ 时 $K$ 的和，则 $dp[i][j]=\sum_{x=1}^{\log_{p_{i-1}}j}dp[i-1][j-p_{i-1}^x]*p_{i-1}^x$。最后 $dp[cnt][n]$ 即为所求答案( $cnt$ 为小于等于 $n$ 的质数个数 )。

​由于 $N\leq 10000$，因此我们需要使用滚动数组来节省空间。

​时间复杂度约为 $O(\frac{N^2}{\ln N})$。

### AC代码:

```C++
#include<bits/stdc++.h>
#define van long long
using namespace std;
const van N = 101000;
bool ppppp;
van n,m,p[N],cnt;
bool v[N];
van dp[4][N];
bool pppppp;
void get_prime_table(van n) {
	for (int i=2; i<=n; i++) {
		if (!v[i]) {
			p[++cnt]=i;
			for (int j=i*i; j<=n; j+=i) {
				v[j]=true;
			}
		}
	}
}//获取质数表
void init() {
	for (int i=0; i<=n; i++) {
		dp[0][i]=1;
	}
}//初始化dp数组
int main() {
	cin>>n>>m;
	get_prime_table(n);
	init();
	for (int i=1; i<=cnt; i++) {
		memcpy(dp[i&1],dp[(i&1)^1],sizeof dp[i&1]);
		for (int j=1; j<=n; j++) {
			for (int k=p[i]; k<=j; k*=p[i]) {
				dp[i&1][j]+=dp[(i&1)^1][j-k]*k;
				dp[i&1][j]%=m;
			}
		}
	}//dp全过程
	cout<<dp[cnt&1][n];
}
```

